// code:#END_OF_PROC_FUNCTIONS
// code:#END_OF_EVENT


#include "stdafx.h"
#include "PrimitiveTypedef.h"
#include "Procedure.h"
#include "KncP2PLib/KncP2P.h"
#include "GCUI/GCGuildMemo.h"
#include "GCUI/GCGameOverlayUI.h"
#include "GCUI/KGCIndigoSelect.h"
#include "GCUI/GCOptionMusic.h"
#include "GCUI/GCOptionSound.h"
#include "GCUI/GCRankingDlg.h"
#include "Controls.h"
#include "Headup Display.h"
#include "GCNetwork.h"
#include "Message.h"
#include "KGCGameBoard.h"
#include "KSingleton.h"
#include "KStats.h"
#include "GCUI/GCNickNameBox.h"
#include "GCUI/GCCashShopScene.h"
#include "GCUI/GCGPShopScene.h"
#include "GCUI/KGCPetMessage.h"
#include "GCStateGame.h"
#include "GCStateRoom.h"
#include "GCUI/KGCAttendanceCalendar.h"
#include "GCDropItemManager.h"
#include "QuestGameManager.h"
#include "zlib.h"
#include "HShield.h"
#include "HackShield.h"
#include "GCUI/GCMyInfoScene.h"
#include "GCUI/GCInfoPanel.h"
#include "KGCNewTerm.h"
#include "ClientErr.h"
#include "GCUI/GCServerScene.h"
#include "GCUI/GCMatchScene.h"
#include "KGCChannelManager.h"
#include "KGCRoomManager.h"
#include "GCUI/KGCChannelListBox.h"
#include "GCUI/KGCRoomList.h"
#include "KGCWorldMapManager.h"
#include "KGCElvis.h"
#include "Replay.h"
//#include "GCUI/KGCSquareEnterWnd.h"
#include "./Square/GCSquare.h"
#include "./Square/GCSquarePeople.h"
#include "GCUI/KGCSquareOverlayUI.h"

#include "GCUI/GCInviteRequestBox.h"
#include "KGCAnnounceMgr.h"
#include "gcui/KGCTreasureItemBox.h"

#include "GCStateLoading.h"
#include "gcui/KGCWelcomBack.h"
#include "KGCMinigameManager.h"
#include "gcui/KGCMiniGameDlg.h"
#include "Controls.h"

#include "KGCDeathMatch.h"
//
#include "gcui/KGCTitleWindow.h"
#include "gcui/KGCPetPreview.h"

#include "BuddySystem/KFriendShip.h"
#include "GCUI/GCNateOnChat.h"
#include "gcui/GCTalkList.h"
#include "gcui/GCSkillTreeDlg.h"
#include "GCSKT.h"
#include "gcui/GCNateOnMsg.h"
#include "gcui/KGCNewClearSealDlg.h"
#include "GCCoupleSystem.h"
#include "gcui/GCCoupleViewer.h"
#include "KGCContributionManager.h"
#include "gcui/KGCContributionDlg.h"
#include "gcui/KGCHappyNewYearNPCDlg.h"
//#include "gcui/KGCValentineDayDlg.h"
//#include "../KGCValentineDayManager.h"
#include "gcui/kGCGPCapsuleDlg.h"
#include "gcui/KGCGPCapsuleObtainWnd.h"
#include "gcui/KGCCouponNPCDlg.h"
#include "gcui/GCItemReceiveBox.h"
#include "gcui/KGCCooperationEventDlg.h"
#include "gcui/KGCGuildMarkRegistDlg.h"
#include "gcui/KGCGuildLobbyDlg.h"

//#include "gcui/KGCGWCDonationDlg.h"
#include "gcui/GCInventoryFullMsg.h"

#include "gcui/KGCBingo.h"
#include "gcui/KGCQuiz.h"
#include "gcui/GCGawibawiboGame.h"
#include "gcui/GCBonusBoxSelect_S4.h"
#include "GCStateExitGame.h"

#include "gcui/GCPlantTree.h"


#include "KGCPartyManager.h"

#include "KGCAgitGameManager.h"
#include "GCUI/GCAgitOverlayUI.h"
#include "KGCAgit.h"

#include "GCJustInTime.h"
#include "KGCPostLetterManager.h"
#include "./KGCDepotManager.h"
#include "./gcui/GCDepotDlg.h"

#include "GCUI/KGCWelcomeBackNew.h"
#include "KGCRoomListManager.h"
#include "KGCSyncObject.h"
#include "KGCFaceLift.h"
#include "KGCQALogManager.h"
#include "gcui/GCNewNecklaceEnchantDlg.h"
#include "gcui/KGCSavingGauge.h"
#include "KGCBillboardChatManager.h"
#include "GCPetMagicStone.h"

#if defined( USE_XTRAP) && !defined(_DEBUG)
#include "Xtrap_C_Interface.h"
#endif

#if defined( _DEBUG ) || !defined( __PATH__ )
#pragma comment( lib, "shell32.lib" )
//


#include <ShellAPI.h>

#include "KGCAngelsEgg.h"

void OnDragDrop( HDROP hDropInfo )
{
    JIF( g_MyD3D != NULL );

    // 2007/1/22. iridology. 우리도 리소스 드래그로 리로드 해보아요..
    char cDropFiles[MAX_PATH];
    UINT iCount = DragQueryFileA( hDropInfo, 0xFFFFFFFF, cDropFiles, MAX_PATH );

    for( UINT i = 0; i < iCount; ++i )
    {
        DragQueryFileA( hDropInfo, i, cDropFiles, MAX_PATH );

        std::string strFile = cDropFiles;
        std::string strFile2;
        strFile2 = strFile.substr( strFile.find_last_of("\\") + 1 );

        using std::transform;
        transform( strFile2.begin(), strFile2.end(), strFile2.begin(), toupper );

        char cExt[3];
        cExt[0] = strFile2.at( strFile2.find( '.' ) + 1 );
        cExt[1] = strFile2.at( strFile2.find( '.' ) + 2 );
        cExt[2] = strFile2.at( strFile2.find( '.' ) + 3 );
        DWORD dwFileExt = MAKEFOURCC( '.', cExt[0], cExt[1], cExt[2] );

        g_pGCDeviceManager->GetMassFileManager()->AddRealFile( strFile );

        // 확장자 검사, 진짜 포맷검사, -> 파일 패스 받아오기!! ㅎ
        if ( g_pkUIScene->m_pkGuildMarkRegistDlg->IsRenderOn() && g_pkUIScene->m_pkGuildMarkRegistDlg->IsEnableDrag() )
        {
            g_pkUIScene->m_pkGuildMarkRegistDlg->DragTexture( strFile );
        }

#if defined( _DEBUG ) || !defined( __PATH__ )
        switch( dwFileExt )
        {
#if defined( USE_SHADER_LOAD_HLSL )
        case MAKEFOURCC( '.', 'K', 'F', 'X' ):
            {
                g_pRenderState->OnReLoadShader();
            }
            break;
#endif
        case MAKEFOURCC( '.', 'K', 'T', 'P' ):
            {
                std::string strParticle = g_strCurrentPath + "Stage\\";
                strParticle += strFile2;
                g_ParticleManager->Load( (char*)strParticle.c_str(), "");
            }
            break;
        case MAKEFOURCC( '.', 'S', 'T', 'G' ):
        case MAKEFOURCC( '.', 'L', 'U', 'A' ):		
            {
                // 특수한 처리가 필요한 애들 이리로..
                // 깨끗하게 함수 포인터 처리를 하고 싶었는데...
                if( !strFile2.compare( "FIREINFO.STG" ) )
                {
                    g_kStatsManager.OnReloadFireInfo();
                }
                //else if( !strFile2.compare( "MONSTERTEMPLATE.STG" ) )
                //{
                //    g_kStatsManager.OnReloadMonster();
                //}
                //else if( strFile2.find( "AI" ) == 0 )
                //{
                //    g_kStatsManager.OnReloadAI( strFile2 );
                //}
#ifdef _DEBUG
                else if( !strFile2.compare( "DEV.LUA" ) )
                {
                    g_kGlobalValue.LoadDevLua();
                }
#endif
                else if( !strFile2.compare( "GCMAPANIM.STG" ) )
                {
                    g_MyD3D->m_pMapAnim->Compile( "GCMapAnim.stg" );
                }
                else if( !strFile2.compare( "GCPETANIM.STG" ) )
                {
                    g_MyD3D->m_pPetAnim->Compile( "GCPetAnim.stg" );
                }
                else if( !strFile2.compare( "GCUIANIM.STG") )
                {
                    g_MyD3D->m_pUIAnim->Compile( "GCUiAnim.stg" );
                }
                else if( !strFile2.compare( "GCNEWMAPPARTICLESCRIPT.STG" ) )
                {
                    std::string strParticle = g_strCurrentPath + "Stage\\GCNewMapParticleScript.stg";
                    std::string strItemLua = "ParticleEff.stg";
                    g_ParticleManager->Clear();
                    g_ParticleManager->Load( (char*)strParticle.c_str(), (char*)strItemLua.c_str() );
                }
#ifdef NATION_EUROPE
                else if( !strFile2.compare( "STR_EU.STG" ))
                {
                    g_pkStrLoader->Load( ".\\Stage\\str_eu.stg" );
                }
#else
                else if( !strFile2.compare( "STR_EN.STG" ))
                {
                    g_pkStrLoader->Load( ".\\Stage\\str_en.stg" );
                }
#endif

                else if( !strFile2.compare( "NEONSIGN.LUA" ) )
                {
                    SiKNeonSign()->LoadNeonSign();
                }
                else if( !strFile2.compare( "GCGUIDE.LUA" ) )
                {
                    g_MyD3D->m_kGuideMgr.LoadScript();
                }
                else if( !strFile2.compare( "RANKERREWARD.STG" ) )
                {
                    g_kGlobalValue.m_kRanking.LoadRankgerReward();
                }
                else if( !strFile2.compare( "INITSKILLTREE.LUA" ) )
                {
#if defined(NATION_JAPAN)
                    //std::string strSkillScript( "InitSkillTree_jp.lua" );
                    std::string strSkillString( "./stage/str_Skill_jp.stg" );
#elif defined(NATION_HONGKONG)
                    //std::string strSkillScript( "InitSkillTree_hk.lua" );
                    std::string strSkillString( "./stage/str_Skill_hk.stg" );
#elif defined(NATION_TAIWAN)
                    //std::string strSkillScript( "InitSkillTree_tw.lua" );
                    std::string strSkillString( "./stage/str_Skill_tw.stg" );
#elif defined(NATION_CHINA)
                    std::string strSkillString( "./stage/str_Skill_cn.stg" );
#elif defined(NATION_BRAZIL)
                    //std::string strSkillScript( "InitSkillTree_br.lua" );
                    std::string strSkillString( "./stage/str_Skill_br.stg" );
#elif defined( NATION_USA )
                    //std::string strSkillScript( "InitSkillTree_us.lua" );
                    std::string strSkillString( "./stage/str_Skill_us.stg" );
#elif defined( NATION_IDN )
                    //std::string strSkillScript( "InitSkillTree_id.lua" );
                    std::string strSkillString( "./stage/str_Skill_id.stg" );
#elif defined( NATION_THAILAND )
                    //std::string strSkillScript( "InitSkillTree_th.lua" );
                    std::string strSkillString( "./stage/str_Skill_th.stg" );
#elif defined( NATION_PHILIPPINE )
                    //std::string strSkillScript( "InitSkillTree_ph.lua" );
                    std::string strSkillString( "./stage/str_Skill_ph.stg" );
#elif defined( NATION_LATINAMERICA )
                    //std::string strSkillScript( "InitSkillTree_la.lua" );
                    std::string strSkillString( "./stage/str_Skill_la.stg" );
#elif defined( NATION_EU )
                    //std::string strSkillScript( "InitSkillTree_eu.lua" );
                    std::string strSkillString( "./stage/str_Skill_eu.stg" );
#else	// NATION_KOREA                    
                    std::string strSkillString( "./stage/str_Skill.stg" );
#endif


                    KLuaManager kSkillTreeLua;
                    GCFUNC::LoadLuaScript(kSkillTreeLua, "Enum.stg" );
                    GCFUNC::LoadLuaScript(kSkillTreeLua, "MotionEnum.stg" );

                    for( int i = 0; i < GC_CHAR_NUM; i++ ) {
                        for( int j = 0; j < NUM_JOB_LEVEL; j++ ) {
                            std::stringstream strSkillScript;
                            strSkillScript << "InitSkillTree" << i << "_" << j << ".lua";
                            if( GCFUNC::LoadLuaScript( kSkillTreeLua, strSkillScript.str() ) ) {
                                SiGCSKT()->_D_ReloadUIinfo( kSkillTreeLua );
                            }                            
                        }
                    }                                        
                }
                else if( !strFile2.compare( "QUESTDIALOGUE.STG" ) )
                {
                    g_pkQuestManager->LoadDialogueTable();
                }
                else if( !strFile2.compare( "ANGELSEGG.LUA" ) )
                {
#if defined( ANGELS_EGG_REFORM )
                    ((KGCAngelsEgg*)((KGCStateGame*)g_MyD3D->m_pStateMachine->GetStatePtr( GS_GAME ))->GetGameModePtr( GC_GMC_ANGELS_EGG ))->LoadReformScript();
#else
                    ((KGCAngelsEgg*)((KGCStateGame*)g_MyD3D->m_pStateMachine->GetStatePtr( GS_GAME ))->GetGameModePtr( GC_GMC_ANGELS_EGG ))->LoadScript();
#endif
                }
#if defined( NATION_TAIWAN )
                else if( !strFile2.compare( "STR_CT.STG" ))
                {
                    g_pkStrLoader->Load( ".\\Stage\\str_ct.stg" );
                }
#elif defined( NATION_HONGKONG )
                else if( !strFile2.compare( "STR_HK.STG" ))
                {
                    g_pkStrLoader->Load( ".\\Stage\\str_hk.stg" );
                }
#elif defined( NATION_THAILAND )
                else if( !strFile2.compare( "STR_TH.STG" ))
                {
                    g_pkStrLoader->Load( ".\\Stage\\str_th.stg" );
                }
#elif defined( NATION_BRAZIL )
                else if( !strFile2.compare( "STR_BR.STG" ))
                {
                    g_pkStrLoader->Load( ".\\Stage\\str_br.stg" );
                }
#elif defined( NATION_LATINAMERICA )
                else if( !strFile2.compare( "STR_LA.STG" ))
                {
                    g_pkStrLoader->Load( ".\\Stage\\str_la.stg" );
                }
#else
                else if( !strFile2.compare( "STR.STG" ))
                {
                    g_pkStrLoader->Load( ".\\Stage\\str.stg" );
                }
#endif
                else if( !strFile2.compare( SiKGCMultipleLanguages()->ConvertNationStringFileNameA("STR_").c_str() ) )
                {
                    std::string strFileName = SiKGCMultipleLanguages()->ConvertNationStringFileNameA("STR_");
                    g_pkStrLoader->LoadFromKom( strFileName.c_str() );
                }
                else if( !strFile2.compare( "PETCOSTUME.STG" ) )
                {
                    KPet::LoadPetCostume();
                }
#if defined(NATION_JAPAN)
                else if( !strFile2.compare( "GAMEMODETABLE_JP.LUA" ) )
#elif defined(NATION_HONGKONG)
                else if( !strFile2.compare( "GAMEMODETABLE_HK.LUA" ) )
#elif defined(NATION_TAIWAN)
                else if( !strFile2.compare( "GAMEMODETABLE_TW.LUA" ) )
#elif defined(NATION_CHINA)
                else if( !strFile2.compare( "GAMEMODETABLE_CN.LUA" ) )
#elif defined(NATION_BRAZIL)
                else if( !strFile2.compare( "GAMEMODETABLE_BR.LUA" ) )
#elif defined( NATION_USA )
                else if( !strFile2.compare( "GAMEMODETABLE_US.LUA" ) )
#elif defined( NATION_PHILIPPINE )
                else if( !strFile2.compare( "GAMEMODETABLE_PH.LUA" ) )
#elif defined( NATION_LATINAMERICA)
                else if( !strFile2.compare( "GAMEMODETABLE_LA.LUA" ) )
#elif defined( NATION_EU)
                else if( !strFile2.compare( "GAMEMODETABLE_EU.LUA" ) )
#elif defined( NATION_THAILAND )
                else if( !strFile2.compare( "GAMEMODETABLE_TH.LUA" ) )
#else	// NATION_KOREA
                else if( !strFile2.compare( "GAMEMODETABLE.LUA" ) )
#endif
                {
                    SiKGCRoomManager()->LoadGameMode();
                }
                else if( !strFile2.compare( "SQUARE3DOBJECT.LUA" ) )
                {
                    SiGCSquare()->ClearSquareObj();
                    SiGCSquare()->LoadObjectScript();
                    SiGCSquare()->Load3DObjcetScript();
                    while( SiGCSquare()->SquareObjInit() == false );
                }
                else if( !strFile2.compare( "PETTEMPLATE.STG" ))
                {
                    KPet::LoadPetTemplate();
                }
                else if( !strFile2.compare( "SERVERNEWS.LUA" ) )
                {
                    g_pkUIScene->m_pkServerScene->Initialize();
                }
                else if( !strFile2.compare( "SAMEIMAGEINDEX.LUA" ) )
                {
                    g_pItemMgr->LoadSameImageIndexScript();
                }
                else if( !strFile2.compare( "EMOTICONLIST.STG" ) )
                {
                    SiKGCEmoticonManager()->LoadFromLuaScript("EmoticonList.stg");
                }
                else if( !strFile2.compare( "EMBLEM.LUA" ) )
                {
                    g_pkSquareOverlayUI->LoadSquareParticleList();
                }
                else if( !strFile2.compare( "EGOITEMLIST.STG" ) )
                {
                    SiKGCObjectEgoMgr()->LoadFromLuaScript("EgoItemList.stg");
                }
                else if( !strFile2.compare( "CHARACTERSTATS_MID_LIST.STG" ) )
                {
                    g_kGlobalValue.LoadStatsMIDList("CharacterStats_MID_List.stg");
                }
                else if( !strFile2.compare( "GachaItemList.stg" ) )
                {
                    g_MyD3D->m_kItemMgr.LoadGachaList();
                }
                else if( strstr(strFile2.c_str(), "PLAYERTEMPLATE") )
                {
                    if( g_pkUIScene->m_pkCharGetInfoDlg )
                        g_pkUIScene->m_pkCharGetInfoDlg->LoadScript();
                }
                else if( !strFile2.compare( "RECOM.LUA" ) )
                {
                    g_pItemMgr->LoadRecomFiles();
                }
                else if( !strFile2.compare( "DOTATEMPLATE.STG" ) )
                {
                    KGCDota::LoadScript();
                }
                else if( !strFile2.compare( "AGITOBJECTINFO.STG" ) )
                {
                    SiKGCAgitGameManager()->LoadObjectInfo("AgitObjectInfo.stg");
                }
                else if( !strFile2.compare( "AGITSPECIALOBJECTINFO.STG" ) )
                {
                    SiKGCAgitGameManager()->LoadSpecialObjectInfo("AgitSpecialObjectInfo.stg");
                }
                else if( !strFile2.compare( "AZITTEMPLATE.STG") )
                {
                    KGCAgit::LoadAzitMotion();
                }
                else if( !strFile2.compare( "ENCHANTEFFECT.STG" ) )
                {
                    g_kGlobalValue.LoadEnchantEffectInfo("EnchantEffect.stg");
                }
                else if( !strFile2.compare( "ITEMDROPRECT.STG" ) )
                {
                    SiKGCDropItemManager()->LoadDropRect();
                }
                else if(!strFile2.compare( "BOSSIMAGEINFO.LUA" ))
                {
                    SiKGCRoomListManager()->LoadBossImageFileInfo();
                }
                else if( strstr(strFile2.c_str(), "WEATHERSYSTEMINFO") )
                {
                    SiKGCWeatherSystem()->LoadWeatherInfo();
                }
                else if( !strFile2.compare( "BUFFINFO.STG" ) )
                {
                    g_pMagicEffect->LoadFromLuaScript( "BuffInfo.stg" );
                }
                else if( !strFile2.compare( "DUNGEONINFO.LUA" ) )
                {
                    SiKGCWorldMapManager()->LoadDungeonInfo();
                }
                else if( !strFile2.compare( "SYNCOBJECTINFO.LUA" ) )
                {
                    SiKGCSyncObjectManager()->LoadScript();
                }
                else if( !strFile2.compare( "SETFACELIFT.STG" ) )
                {
                    SiKGCFaceLift()->LoadFromLuaScript( "SetFaceLift.stg" );
                }
                else if( !strFile2.compare( "AUTOMATCHBALLANCE.LUA" ) )
                {
                    SiGCAutoMatchManager()->LoadScript();
                }
                else if( !strFile2.compare( "EMBARKTEMPLATE.STG" ) || !strFile2.compare( "EMBARKSETTINGINFO.STG" ) )
                {
                    SiKGCEmbarkManager()->LoadScript();
                }
                else if( !strFile2.compare( "WALLTEMPLATE.STG" ) )
                {
                    SiKGCWallManager()->LoadScript();
                }
                else if( !strFile2.compare( "SUBJECTTEMPLATE.STG" ) )
                {
                    SiKGCSubjectManager()->LoadScript();
                }
				else if( !strFile2.compare( "AGREEMENT.STG" ) )
				{
					g_pkUIScene->m_pkAgreement1301->LoadAgree();
				}
                else if( !strFile2.compare( "CHARSAVINGINFO.STG" ) )
                {
                    if( g_pkUIScene ) {
                        g_pkUIScene->m_pkGameOverlayUI->GetHeadUp()->m_pMyHeadup->m_pkSavingGauge->LoadCharSavingInfo();
                        g_pkUIScene->m_pkGameOverlayUI->GetHeadUp()->m_pMyHeadup->m_pkSavingGauge->InitCurCharSavingInfo();
                    }
                }
                else if( !strFile2.compare( "RANKCORRECTIONVALUE.STG" ) )
                {
                    g_pkQuestManager->LoadRankCorrectionScript();
                }
                else
                {                    
                    for( int i = 0; i < GC_CHAR_NUM; i++ ) {
                        for( int j = 0; j < NUM_JOB_LEVEL; j++ ) {
                            std::stringstream strSkillScript;
                            strSkillScript << "INITSKILLTREE" << i << "_" << j << ".LUA";
                            
                            if( !strFile2.compare( strSkillScript.str() ) ) {
                                KLuaManager kSkillTreeLua;
                                GCFUNC::LoadLuaScript(kSkillTreeLua, "Enum.stg" );
                                GCFUNC::LoadLuaScript(kSkillTreeLua, "MotionEnum.stg" );
                                strSkillScript.str("");
                                strSkillScript << "InitSkillTree" << i << "_" << j << ".lua";
                                if( GCFUNC::LoadLuaScript( kSkillTreeLua, strSkillScript.str() ) ) {
                                    SiGCSKT()->_D_ReloadUIinfo( kSkillTreeLua );
                                }
                                g_pkUIScene->m_pkSkillTree->Update();
                                g_pkUIScene->m_pkSkillTree->UpdateTab();
                                return;
                            }                                                                                                 
                        }                         
                    }                                                 
                    GCFUNC::LoadLuaScript( KGCLuabinder::getInstance(), strFile2 );
                }
            }
            break;
        case MAKEFOURCC( '.', 'D', 'D', 'S' ):
        case MAKEFOURCC( '.', 'D', 'D', '0' ):
        case MAKEFOURCC( '.', 'D', 'D', '1' ):
        case MAKEFOURCC( '.', 'P', '3', 'M' ):
        case MAKEFOURCC( '.', 'F', 'R', 'M' ):
            {
                GCDevice* pDevice = g_pGCDeviceManager->FindDevice( strFile2 );
                if( pDevice == NULL )
                {
                    if( dwFileExt == MAKEFOURCC( '.', 'D', 'D', 'S' ) ||
                        dwFileExt == MAKEFOURCC( '.', 'D', 'D', '0' ) ||
                        dwFileExt == MAKEFOURCC( '.', 'D', 'D', '1' ) )
                    {
                        pDevice = g_pGCDeviceManager->CreateTexture( strFile2 );
                        if( pDevice == NULL )
                            MessageBoxA( NULL, "DeviceTexture Reload Failed", NULL, MB_OK );
                    }
                    else if( dwFileExt == MAKEFOURCC( '.', 'P', '3', 'M' ) )
                    {
                        pDevice = g_pGCDeviceManager->CreateMeshP3M( strFile2 );
                        if( pDevice == NULL )
                            MessageBoxA( NULL, "DeviceP3M Reload Failed", NULL, MB_OK );
                    }
                    else if( dwFileExt == MAKEFOURCC( '.', 'F', 'R', 'M' ) )
                    {
                        pDevice = g_pGCDeviceManager->CreateMotionFRM( strFile2 );
                        if( pDevice == NULL )
                            MessageBoxA( NULL, "DeviceMotionFRM Reload Failed", NULL, MB_OK );
                    }
                }
                else
                {
                    pDevice->Reload();
                }
            }
            break;
        case MAKEFOURCC( '.', 'W', 'A', 'V' ):
            {
                g_KDSound.Reload( strFile2 );
                break;
            }
        default:
            {
                MessageBoxA( NULL, "This File Cannot be Reload", NULL, MB_OK );
            }
            break;
        }

        START_LOG( clog, "FileChanged : " )
            << BUILD_LOG( cDropFiles );
#endif
    }
}
#endif

#if defined( BUG_TRAP )
#if defined( _DEBUG )
#pragma comment(lib, "BugTrapD")
#else
#pragma comment(lib, "BugTrap")
#endif
#else
// 크래쉬 리포트 라이브러리 임포트

#pragma comment(lib, "KNCCrashRpt")
#endif

void ItemDiff( IN const std::vector<KItem>& vecRecv, IN OUT std::vector<KDropItemInfo>& vecOut ) {

    for(int i = 0; i < (int)vecRecv.size(); i++ )
    {
        GCItem* kItem = g_pItemMgr->GetItemData( vecRecv[i].m_ItemID / 10 );
        CONTINUE_NIL( kItem );

        KDropItemInfo kDiffInfo;
        kDiffInfo.m_ItemID = kItem->dwGoodsID;
        if( vecRecv[i].m_nCount == KItem::UNLIMITED_ITEM ) {
            kDiffInfo.m_nDuration = KItem::UNLIMITED_ITEM;
        }
        else {
            DWORD dwReceivedCount = vecRecv[i].m_nCount;
            KItem* pkItem = g_pItemMgr->m_kInventory.FindItemByItemID( kItem->dwGoodsID );
            if( pkItem != NULL )
                dwReceivedCount -= pkItem->m_nCount;
            kDiffInfo.m_nDuration = dwReceivedCount;
        }

        if( vecRecv[i].m_nPeriod == KItem::UNLIMITED_ITEM ) {
            kDiffInfo.m_nPeriod = KItem::UNLIMITED_ITEM;
        }
        else {
            DWORD dwReceivedPeriod = vecRecv[i].m_nPeriod;
            KItem* pkItem = g_pItemMgr->m_kInventory.FindItemByItemID( kItem->dwGoodsID );
            if( pkItem != NULL )
                dwReceivedPeriod -= pkItem->m_nPeriod;
            kDiffInfo.m_nPeriod = dwReceivedPeriod;
        }
        vecOut.push_back( kDiffInfo );
    }
}

void OnItemReceive( std::vector<KItem>& vecInv, bool bFirst = false, bool bForce = false, KGCUIScene::EGCMsgBoxType eMsgBoxType = KGCUIScene::GC_MBOX_ITEM_RECEIVE )
{
    int iIndex = 0;
    int iDuration = 0;
    int iItemID = 0;

    std::vector<std::pair<GCITEMUID,int>> vecItems;
    vecItems.reserve( vecInv.size() );

    for( int j=0 ; j<(int)vecInv.size() ; ++j )
    {
        iDuration = vecInv[j].m_nCount - g_pItemMgr->GetInventoryItemDuration( vecInv[j].m_ItemID/10 );
        vecItems.push_back( std::pair<GCITEMUID,int>(vecInv[j].m_ItemUID, iDuration ) );
        iItemID = vecInv[j].m_ItemID/10;
    }

    g_pItemMgr->m_kInventory.AddItemList( vecInv, true );


    if( eMsgBoxType == KGCUIScene::GC_MBOX_ITEM_RECEIVE )
    {
        for( int j=0 ; (j<(int)vecItems.size()) ; ++j, ++iIndex )
        {
            g_pkUIScene->m_pkItemReceiveBox->AddItem(vecItems[j].first, vecItems[j].second);
        }

        if( iIndex > 0 )
        {
            g_pkUIScene->MessageBox( eMsgBoxType, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, bFirst, bForce );
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
        }
    }
    else
    {
        g_pkUIScene->MessageBox( eMsgBoxType, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, iItemID, 0, bFirst, bForce );
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
    }
}

void OnItemReceiveSmallBox( std::vector<KItem>& vecInv, bool bFirst = false, bool bForce = false )
{
    
    g_MyD3D->m_kItemMgr.m_kInventory.AddItemList( vecInv );

    for(int i = 0; i < (int)vecInv.size(); i++ )
    {
#if defined(NATION_HONGKONG)
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"",KGCUIScene::GC_MBOX_USE_NORMAL, vecInv[i].m_ItemID / 10 );

        int iItemPeriod = vecInv[i].m_nPeriod;

        if(-1 == iItemPeriod)
        {
            g_pkUIScene->m_pkTreaureItemBox->ShowCount( false );
        }
        else
        {
            KItem* pInvenItem = NULL;

            if( g_pItemMgr->FindInventoryForItemID(vecInv[i].m_ItemID / 10, &pInvenItem ) )
            {
                iItemPeriod -= pInvenItem->m_nPeriod;
            }

            g_pkUIScene->m_pkTreaureItemBox->SetCount(g_pkStrLoader->GetReplacedString(STR_ID_DURATION_PERIOD, "i", iItemPeriod) );
        }						
#else
        GCItem* kItem = g_pItemMgr->GetItemData( vecInv[i].m_ItemID );
        CONTINUE_NIL( kItem );
        
        //	강화석이고 다른 아이템에 박힌것은 표현하지 않는다.
        if ( kItem->eItemKind == GIK_ENCHANT_ENABLE_ITEM && vecInv[i].m_EnchantEquipItemUID != 0 ) 
            continue;

        // 캐릭터 타입 표시되게 하자
        DWORD dwCommonCharType = 0;
        for( int iChar=0; iChar<GC_CHAR_NUM ; ++iChar ) { 
            dwCommonCharType = dwCommonCharType | ( 1 << iChar );
        }

        std::wstring strCharType( g_pkStrLoader->GetString( STR_ID_ITEM_CHAR_TYPE_COMMON ) );
        if( dwCommonCharType != kItem->dwCharType ) { 
            strCharType = GCFUNC::GetCharName( kItem->GetCharType() );
        }

        std::wstringstream stm;
        stm << g_pItemMgr->GetItemGradeColorKey( kItem->cItemGrade ) << kItem->strItemName << L"(" << strCharType << L")" << L"#cX";
        std::wstring strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE1, "l", stm.str() );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_REPETITION_EVENT_BOX, strMsg, L"", KGCUIScene::GC_MBOX_USE_NORMAL, kItem->dwGoodsID*10, vecInv[i].m_ItemUID, bFirst, bForce );
#endif
    }
 
    g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    g_pkUIScene->m_pkMyInfoScene->UpdateData();

    vecInv.clear();

}

#define MAX_SATIATION 6000

#define  SERVER_MSG(id)         case EVENT_TYPE::id: On_##id(wParam,lParam); break;
#define _SERVER_MSG(id,func)    case EVENT_TYPE::id: On_##func(lParam); break;
// --------------------------------------------------------------------------------
// 전역 변수
// --------------------------------------------------------------------------------
std::wstring    g_strLoginError;
int             Result_Connect_LoginServer      = 0;
int             Result_Register_User            = 0;
DWORD           Wait_Time_LoginServer           = 0;
int             Result_Connect_GameServer       = 0;
int             Result_UserList                 = 0;
int             Result_Create                   = 0;
int             Result_Join                     = 0;
int             Result_StartGame                = 0;
int             Result_EndGame                  = 0;
int             Result_LeaveGame                = 0;
int             Result_LeaveRoom                = 0;
int             Result_Drop                     = 0;
int             Result_Change_Room_UserInfo     = 0;
int             Result_Connect_Gild             = 0;
int             Result_Repair                   = 0;
int             Result_Buy                      = 0;
int             Result_Buy_CashItem             = 0;
int             Result_Buy_VirtualCashItem      = 0;
int             Result_SetCurrentChar           = INT_MAX;
int             Result_ReportNickName           = 0;
int             Result_ReportNickColor          = 0;
int             Result_ReportPetNickName        = 0;
int             Result_Kid_Gift                 = 0;
int             Result_DeletePet                = 0;
int             Result_FeedingPet               = 0;
int             Result_CreatePet                = 0;
int             Result_ExtendInventory          = 0;
int             Result_TransformationPet        = 0;
int             Result_SeallingCalendar         = 0;
int             Result_WeeklyAttend             = 0;
int             Result_ForceTransition          = 0;
int             Result_GetRewardItem            = 0;
int             Result_RemovePointItem          = 0;
int             Result_ResetWinLoseData         = 0;
int             Result_EnchantItem              = 0;
int             Result_Bonus_Charging           = INT_MAX;
int             Result_Enter_Square             = INT_MAX;
int             Result_New_Character            = INT_MAX;
int             Result_Join_From_Square         = INT_MAX;
int             Result_Join_Other_Channel       = INT_MAX;
int             Result_New_Emoticon             = INT_MAX;
std::wstring    Result_Connect_Msg              = L"";
KEVENT_BAD_USER_INFO_NOT Result_BadUser_Info;
KEVENT_BAD_USER_INFO_CHANGE_BROAD Result_BadUser_Info_Room;
int             Result_Case                     = INT_MAX;
KItem           g_kDurItemInfo;


bool            g_bAgreePrivateInfo = false;
int             g_TeamPoint         = 0;
UCHAR           g_ucGuildUserLevel  = 0;
int             MyGildTotalPoint    = 0;
int             MyGildTotalNum      = 0;
int             g_iResult_ShopAgreeMent = INT_MAX;
int             Result_SellItemInfo = INT_MAX;
int             Result_Sell_Count_Item = INT_MAX;
int             Result_Start_MiniGame   = INT_MAX;
int             Result_Exit_MIniGame    = INT_MAX;
int             Result_End_MIniGame     = INT_MAX;
KMiniGameRankInfo Result_MyMinigame_info;
int             Result_NateOn_Add_Group = INT_MAX;
int             Result_NateOn_Rename_Group = INT_MAX;
int             Result_NateOn_Delete_Group = INT_MAX;
int             Result_NateOn_Move_Group = INT_MAX;
int             Result_NateOn_Block_Buddy = INT_MAX;
int             Result_NateOn_UnBlock_Buddy = INT_MAX;
int             Result_NateOn_Delete_Buddy = INT_MAX;
int             Result_NateOn_Change_Emoticon = INT_MAX;
int             Result_Vip_Gacha_Item = INT_MAX;
int             Result_Char_Poll = INT_MAX;
int				Result_Loading_image = INT_MAX;
int             Result_CharOpen     = INT_MAX;
D3DXVECTOR2     Result_Pos_MagicMissile;
int             Result_SelectAttribute = INT_MAX;
int             Result_EhcnatSystem = -1;
int             Result_EnterAgitReq = INT_MAX;
int             Result_Damage_Life = 0;

std::vector<KUserInfo>              g_vecUserInfo;
bool                                g_bUserListUpdate       = false;

bool                                g_bRoomListUpdate       = false;
bool                                g_bUpdateTopRoom        = false;

KDetailUserInfo                     g_kDetailUserInfo;
bool                                g_bDetailUserInfoUpdate = false;

//std::vector<KGuildUserInfo2>        g_GuildUserList;
//bool                                g_bGuildUserListUpdate  = false;

KGuildInfo                          g_kGuildInfo;
bool                                g_bGuildInfoUpdate      = false;
HWND                                g_hIMEWnd               = NULL;

int									Result_Gacha_Reward_List = INT_MAX;

int                                 Result_RecomEnable = INT_MAX;
int                                 Result_RecommendNickName = INT_MAX;
int                                 Result_recommendFullINfo = INT_MAX;
int                                 Result_DonationPoint = INT_MAX;
int                                 Result_RegistMissionPackage = INT_MAX;
int                                 Result_Buy_CooperationItem = INT_MAX;
int                                 Result_CouponCode_Input = INT_MAX;
int									Result_HalloweenBoardGame = INT_MAX;
int									Result_BuyHalloweenDice	= INT_MAX;
int									Result_BingoBoardGame = INT_MAX;
int									Result_BingoChangeCoin = INT_MAX;
int									Result_BingoRequestQuestion = INT_MAX;
int									Result_BingoRequestAnswer = INT_MAX;
int                                 Result_SocketManagement_Action = INT_MAX;
int									 Result_CanBuyCashItem	= INT_MAX;

bool								g_bViewMsgBox						= false;

int									Result_SHAFileList		= INT_MAX; 
int                                 Result_HeroItemList     = INT_MAX;
int                                 Result_ReqGuildStoreCatalog = INT_MAX;
int                                 Result_BuyForGuildItem = INT_MAX;
int                                 Result_BuyForHero       = INT_MAX;
int                                 Result_BuyForLottery	= INT_MAX;

std::set<std::wstring>				g_setSHAFileList;	
DWORD								g_dwLoadingTimeCheck  =0;
int									Result_GawibawiboGameInfo = INT_MAX;
int									Result_GawibawiboGameGiveUp = INT_MAX;
int									Result_CheckEnoughSocksMaterial	=	INT_MAX;
int                                 Result_PlantTreeInfo = INT_MAX;
int									Result_Random_Init_attribute = INT_MAX;//457060
int									Result_GuildRankingInfo_Req	= INT_MAX;
int									Result_SphinxReq = INT_MAX;
int                                 Result_GwcRakinglistReq = INT_MAX;
int                                 Result_SockTreeReq = INT_MAX;
int                                 Result_GwcRakingRewardReq = INT_MAX;
int                                 Result_AgitShopCatalog = INT_MAX;
int                                 Result_BuyAgitShop = INT_MAX;
int                                 Result_AgitLoadComplete = INT_MAX;
int                                 Result_LeaveAgit = INT_MAX;
int                                 Result_AgitGuestbookPage = INT_MAX;
int                                 Result_UseTrainingObject = INT_MAX;
int                                 Result_ReceiveChristmasReward = INT_MAX;
int                                 Result_PostLetter = INT_MAX;
int                                 Result_ReceiveEclipsePlotReward = INT_MAX;
int									Result_DepotInfoByCharTabReq = INT_MAX;
int									Result_DepotItemReq = INT_MAX;
int									Result_DepotUpdateItemReq = INT_MAX;

int                                 Result_EclipseEvent = INT_MAX;
int                                 Result_GcAdventureEvent = INT_MAX;
int                                 Result_ContinentRewardReq = INT_MAX;
int                                 Result_WholeContinentFinalRewardReq = INT_MAX;

int                                 Result_OlympicEven_Data = INT_MAX;
bool                                m_bPosChanged = true;
int                                 Result_ItemEquip = INT_MAX;
int                                 Result_CoordiEquip = INT_MAX;
int									Result_InventoryRecvData = INT_MAX;
int									Result_SkillSet = INT_MAX;
int                                 Result_Item_Combination = INT_MAX;
int									Result_MatchPartyUserList = INT_MAX;
int									Result_MatchPartyReady = INT_MAX;
int									Result_AddMatchReq = INT_MAX;
int									Result_StartGamePossibleReq = INT_MAX;

int									Result_ReceiveChristmasUserInfo = INT_MAX;
int									Result_ReceiveChristmasPlayInfo = INT_MAX;
int									Result_ReceiveChristmasRankInfo = INT_MAX;
int									Result_ReceiveChristmasStageStart = INT_MAX;
int									Result_ReceiveChristmasBasketEmpty = INT_MAX;
int									Result_ReceiveChristmasStageClear = INT_MAX;
int									Result_ReceiveChristmasGetReward = INT_MAX;
int									Result_ReceiveChristmasExchangeContinueCoin = INT_MAX;
int									Result_ReceiveChristmasRewardItemList = INT_MAX;

int                                 Result_ReceiveAttendanceStampInfo = INT_MAX;
int                                 Result_ReceiveAttendanceStampReward = INT_MAX;
int                                 Result_ReceiveBuffDonatingReq = INT_MAX;
int                                 Result_ReceivePackageInfo = INT_MAX;
int                                 Result_ReceivePackageDetailInfo = INT_MAX;

int                                 Result_ItemTrade = INT_MAX;
int                                 Result_ReceiveErrandReward = INT_MAX;
int                                 Result_ReceiveErrandEnd = INT_MAX;

int                                 Result_ReceiveGuideCompleteReq = INT_MAX;

int                                 Result_AttributeMigration = INT_MAX;
int                                 Result_ChangeChar = INT_MAX;
int									Result_CYOU_WebCash = INT_MAX;
int                                 Result_Kairo_Oneshot = INT_MAX;

int                                 Result_ReceiveVitalitySystemRecharge = INT_MAX;
int                                 Result_ClientContentsAdditionInfo = INT_MAX;

int                                 Result_VirtualDepotItemListMoveInven = INT_MAX;
int                                 Result_CharNickChange = INT_MAX; 

int									Result_ReceiveSocialCommerceInfo = INT_MAX;
int                                 Result_ReceiveCoordiUpgradeInfo = INT_MAX;

int                                 Result_ReceiveSkillScroolITemReq       = INT_MAX;
int                                 Result_GachaPongReq = INT_MAX;

int                                 Result_ReceiveInRoomIndoorChangeReq = INT_MAX;

int                                 Result_ReceiveCoordiviewSlotGetReq = INT_MAX;
int                                 Result_ReceiveCoordiviewSlotSetReq = INT_MAX;
int                                 Result_ReceivePetMagicStoneChangeEquipReq = INT_MAX;

int                                 Result_ReceiveUseHeroTicketReq = INT_MAX;

// --------------------------------------------------------------------------------
// Functor class definition
// --------------------------------------------------------------------------------
class KNoticeInfoLess
{
public:
    bool operator()( const KGuildNoticeInfo& p, const KGuildNoticeInfo& q ) const
    { return p.m_strRegDate < q.m_strRegDate; }
};
class KGuildChannelUserInfoLess
{
public:
    bool operator()(const KUserInfo& p, const KUserInfo& q) const
    {
        return p.m_iGuildMark < q.m_iGuildMark;
    }
};
class KUserInfoLess
{
public:
    bool operator()( const KUserInfo& p, const KUserInfo& q ) const
    { return p.m_strNickName < q.m_strNickName; }
};

void ParseString( const std::wstring strOrg, std::wstring& str1, std::wstring& str2, char token )
{
    std::wstring::size_type idx = strOrg.find(token);

    // 분류문자를 포함하지 않는다.
    if( idx == std::wstring::npos )
    {
        str1 = strOrg;
        return;
    }
    else
    {
        str1 = strOrg.substr(0, idx);
        str2 = strOrg.substr(idx+1);
    }
}
void StartGame( KEVENT_START_GAME_BROAD& kRecv )
{
    // kom파일 변조가 있었다면 게임을 시작하지 않겠다.
    if( g_kGlobalValue.m_bCheckChangedKOM )
        return;    

#if defined( COLLECT_FRAME_DATA )
    g_kGlobalValue.StartCollectFrameData();
#endif
    g_kGlobalValue.m_prHybridSpecialUseCount = std::make_pair( 0, 0 );

    //게임 시작하라고 하면.. 해상도 부터 키운다.
    /*if ( g_MyD3D->m_KGCOption.GetBasicMode() != g_MyD3D->m_KGCOption.GetCurrentMode() )
    {
    g_MyD3D->SetResolution(TRUE);
    }*/

    //미안 합니다. ㅜㅜ
    // 바네사 울프는 하드 코딩 되어 있어서.. ㅜㅜ
    {
        std::vector< KGameDropElement >::iterator vit;
        for( vit = kRecv.m_dropData.m_vecMissionDrop.begin() ; vit != kRecv.m_dropData.m_vecMissionDrop.end() ; ++vit )
        {
            if( vit->m_nMonID == MON_VANESA ) vit->m_nMonID = MON_VANESA_WOLF;
            if( vit->m_nMonID == MON_VICTOR ) vit->m_nMonID = MON_VICTOR2;
        }
    }

    Result_StartGame = 1;

    SiKGCRoomManager()->UpdateRoomInfo( kRecv.m_kRoomInfo );
    SiKGCRoomManager()->GetPrevRoomInfo() = SiKGCRoomManager()->GetRoomInfo();

    SiKGCRoomManager()->GetRoomInfo().uiRandSeed = (UINT)kRecv.m_dwRamdomSeed;


    KSingleton<KncP2P>::GetInstance()->SetConnectionUID( kRecv.m_dwUniqueNumber );

    // 방원들 모두 랜덤시드를 맞추고..
    srand( SiKGCRoomManager()->GetRoomInfo().uiRandSeed );

    //이벤트를 클라이언트에 등록
    SiKGCEventManager()->ClearEvents();
    SiKGCEventManager()->SetEvents( kRecv.m_mapEvents );

    //미션 진행 표시를 위한 초기화 함수
    g_kGlobalValue.m_kUserMission.InitVirtualMission();

    //드랍되는 아이템들을 등록
    SiKGCDropItemManager()->Clear();
    SiKGCDropItemManager()->DropItemListPreSet( kRecv.m_dropData.m_vecMonsterDrop , kRecv.m_dwRamdomSeed);
    SiKGCDropItemManager()->MissionItemListPreSet( kRecv.m_dropData.m_vecMissionDrop, kRecv.m_dwRamdomSeed );
    SiKGCDropItemManager()->GPListPreSet( kRecv.m_dropData.m_vecGpDrop , kRecv.m_dwRamdomSeed);
    //SiKGCDropItemManager()->MissionItemListPreSet( kRecv.m_dropData.m_mapMonsterDrop , kRecv.m_dwRamdomSeed);

    // 던전 이벤트 몬스터들...
    if ( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_DUNGEON )
    {
//     enum {
//         OPT_NONE  = 0, // 스테이지 개수만큼 등장 가능
//         OPT_LUPIN = 1, // 스테이지 중 최대 1번만 등장 ( 루팡 보너스 스테이지로 가는 몹 )
//         OPT_GATE  = 2, // 스테이지 중 최대 1번만 등장 ( 대륙별 보스 오브젝트 )
//     };
// 
//     int     m_nTriggerID; // 트리거번호
//     int     m_nMonsterID; // 몬스터ID
//     int     m_nMonLv; // 몬스터 레벨
//     int     m_nStage; // 등장 스테이지 번호
//     int     m_nStageNum; // 실제 스테이지 번호
//     bool    m_bIsBoss; // 보스인지
//     int     m_nSpecial; // 옵션
     std::swap(g_kGlobalValue.m_vecEventMonster, kRecv.m_vecEventMonster);

        g_kGlobalValue.IsInEscortMonsterInfo( kRecv.m_dwEscortMonsterID );
        g_kGlobalValue.SetActivateEscortEvent( kRecv.m_bIsActiveEscort );
        g_kGlobalValue.m_kSpecialMonster.m_nMonsterID = -1;
        g_kGlobalValue.m_kSpecialMonster.m_nMonLv = 0;
        g_kGlobalValue.m_kSpecialMonster.m_dwProperty = 0;

        if(kRecv.m_kSpecialMonster.m_nMonsterID != 0){
            g_kGlobalValue.m_kSpecialMonster = kRecv.m_kSpecialMonster;
        }
    }

    int iMyPlayer = g_MyD3D->Get_MyPlayer();
    for ( int i = 0; i < MAX_PLAYER_NUM; i++ )
    {
        if ( g_MyD3D->MyPlayer[i]->m_kUserInfo.bLive == false )
            continue;

		std::map<DWORD, int>::iterator mitFatigue = kRecv.m_mapUserFatigueRatio.find(g_MyD3D->MyPlayer[i]->m_kUserInfo.dwUID);
		if ( mitFatigue != kRecv.m_mapUserFatigueRatio.end() ) {
			g_MyD3D->MyPlayer[i]->SetFatigueRatio(static_cast<float>(mitFatigue->second));
		} else {
			g_MyD3D->MyPlayer[i]->SetFatigueRatio(100.f);
		}
		
		if( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_INDIGO )
        {
            g_MyD3D->MyPlayer[i]->SetSlotAlign();
        }
        //else if( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_TAG_MATCH )
        //{
        //    g_MyD3D->MyPlayer[i]->SetTagSlotAlign();
        //}

        std::map< DWORD, std::pair<int, int> >::iterator mit = kRecv.m_mapUserInvenInfo.find(g_MyD3D->MyPlayer[i]->m_kUserInfo.dwUID);

        if( kRecv.m_mapUserInvenInfo.end() == mit )
        {
            g_MyD3D->MyPlayer[i]->m_kUserInfo.iInvenCapacity = 0;
            g_MyD3D->MyPlayer[i]->m_kUserInfo.iUserItemCount = 0;
        }
        else
        {
            g_MyD3D->MyPlayer[i]->m_kUserInfo.iInvenCapacity = mit->second.first;
            g_MyD3D->MyPlayer[i]->m_kUserInfo.iUserItemCount = mit->second.second;
        }

        if( i == iMyPlayer )
        {
            g_MyD3D->MyPlayer[i]->UpdateTempPlayerUserInfo();
            g_MyD3D->MyPlayer[i]->UpdateGlobalUserInfo();

            //미션조건체크용 데이터 초기화
            g_MyD3D->MyPlayer[i]->ClearControlInfo();
            g_MyD3D->MyPlayer[i]->SetControlInfo();
        }
    }

    g_pGameBoard->Init();

    g_kGlobalValue.m_vecChampionInfo.clear();
    g_kGlobalValue.m_vecChampionInfo = kRecv.m_vecChampions;

    KGCStateLoading* pState = (KGCStateLoading*)g_MyD3D->m_pStateMachine->GetStatePtr( GS_GAME_LOADING );
    pState->ClearLoadList();

    if( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_DUNGEON )
        g_pkUIScene->m_pkGameOverlayUI->SetDungeonLoadingMembers(kRecv.m_vecStartingUsers);
    
    bool bWrongStartingUserList = false;
    for ( int i = 0; i < (int)kRecv.m_vecStartingUsers.size() ; i++ )
    {
        pState->InsertLoadList( kRecv.m_vecStartingUsers[i] );        
        PLAYER* pPlayer = g_MyD3D->GetPlayerByUID( kRecv.m_vecStartingUsers[i] );
        if( pPlayer )
        {			
            AddConnectQ( pPlayer->m_kUserInfo );
        }
        else
        {
            bWrongStartingUserList = true;
        }
    }


    //


    std::vector<SUserInfo> &observer = SiKGCRoomManager()->GetRoomInfo().vecObserverUserInfo;

    for(std::vector<SUserInfo>::iterator vit = observer.begin();vit != observer.end();vit++)
    {
        if(SiKGCRoomManager()->IsObserverLive(vit->dwUID) )
            pState->InsertLoadList(vit->dwUID);
    }

    // 서버에서 보내준 점령전 정보 처리
    if( GC_GM_DOTA == kRecv.m_kDotaModeInfo.m_nModeID )
    {
        // 점령전 모드 정보 처리( < UserUID, <char, DPoint> >)
        std::map< int, std::map<int,int> >::iterator mapIter = kRecv.m_kDotaModeInfo.m_mapModeMapInfo.begin();
        for(; mapIter != kRecv.m_kDotaModeInfo.m_mapModeMapInfo.end(); ++mapIter)
        {
            if( g_kGlobalValue.IsDotaMapID( mapIter->first ) )
            {
                SDotaTemplate* psDotaTemplate = g_kGlobalValue.GetDotaTemplate( mapIter->first );
                psDotaTemplate->iCoreSerdin_MonSlotID = mapIter->second[TEAM_SERDIN];
                psDotaTemplate->iCoreCanaban_MonSlotID = mapIter->second[TEAM_CANABAN];
            }
        }

        // 현재 선택된 맵 정보얻기
        SDotaTemplate *pDotaTemplate = g_kGlobalValue.GetCurrentDotaTemplate();
        if( pDotaTemplate )
        {
            // DPoint아이템 처리
            pDotaTemplate->sDPointShopItemList.vecItemList.clear();

#if defined ( NATION_USA ) || defined ( NATION_PHILIPPINE ) || defined( NATION_THAILAND ) || defined (NATION_BRAZIL)
            // HP회복, 무적, 생명업, NPC생명업
            // MP회복, 투명, 공격업, NPC공격업
            // 귀환  , 반사, 크리업, NPC속도업 순서로 벡터에 담아 저장하도록 수정함
            // 깨끗하게 수정하려면 서버의 DotaManager의 멤버변수와 패킷에 m_mapDotaItemInfo를 벡터로 바꾸면 됩니다
            // (서버에서는 아이템 리스트를 특별히 사용하지 않아서)
            std::vector< GCITEMID > vecSortedDotaItems;
            vecSortedDotaItems.clear();
            vecSortedDotaItems.push_back( GC_GAME_ITEM_DOTA_HPUP );
            vecSortedDotaItems.push_back( GC_GAME_ITEM_SUPER );
            vecSortedDotaItems.push_back( GC_GAME_ITEM_DOTA_FULLHPUP );
            vecSortedDotaItems.push_back( GC_GAME_ITEM_DOTA_NPC_HPUP );
            vecSortedDotaItems.push_back( GC_GAME_ITEM_MPUP );
            vecSortedDotaItems.push_back( GC_GAME_ITEM_HALLOW );
            vecSortedDotaItems.push_back( GC_GAME_ITEM_DOTA_ATK );
            vecSortedDotaItems.push_back( GC_GAME_ITEM_DOTA_NPC_ATTACKUP );
            vecSortedDotaItems.push_back( GC_GAME_ITEM_DOTA_MOVE_ARENA );
            vecSortedDotaItems.push_back( GC_GAME_ITEM_REFLECTION );
            vecSortedDotaItems.push_back( GC_GAME_ITEM_DOTA_CRITICAL );
            vecSortedDotaItems.push_back( GC_GAME_ITEM_DOTA_NPC_SPEEDUP );

            std::vector< GCITEMID >::iterator vitSortedDotaItems = vecSortedDotaItems.begin();
            for ( ; vitSortedDotaItems != vecSortedDotaItems.end(); ++vitSortedDotaItems ) {
                std::map< KDropItemInfo, int >::iterator mapItemIter;
                mapItemIter = find_if( kRecv.m_mapDotaItemInfo.begin(), kRecv.m_mapDotaItemInfo.end(),
                    boost::bind( std::equal_to< GCITEMID >(),
                        boost::bind( &KDropItemInfo::m_ItemID,
                            boost::bind( &std::map< KDropItemInfo, int >::value_type::first, _1 ) ), *vitSortedDotaItems ) );
                if ( mapItemIter != kRecv.m_mapDotaItemInfo.end() ) {
                    pDotaTemplate->sDPointShopItemList.vecItemList.push_back( std::make_pair( mapItemIter->first.m_ItemID, mapItemIter->second ) );
                }
            }
#else
            std::map<KDropItemInfo, int>::iterator mapItemIter = kRecv.m_mapDotaItemInfo.begin();
            for(; mapItemIter != kRecv.m_mapDotaItemInfo.end(); ++mapItemIter)
            {
                pDotaTemplate->sDPointShopItemList.vecItemList.push_back( std::make_pair(mapItemIter->first.m_ItemID, mapItemIter->second) );
            }
#endif

            // 임시 아이템 처리
            
            //pDotaTemplate->sDPointShopItemList.vecItemList.push_back( std::make_pair(GC_GAME_ITEM_DOTA_HPUP, 1 ) );
            //pDotaTemplate->sDPointShopItemList.vecItemList.push_back( std::make_pair(GC_GAME_ITEM_MPUP, 10 ) );
            //pDotaTemplate->sDPointShopItemList.vecItemList.push_back( std::make_pair(GC_GAME_ITEM_DOTA_FULLHPUP, 20 ) );
            //pDotaTemplate->sDPointShopItemList.vecItemList.push_back( std::make_pair(GC_GAME_ITEM_DOTA_ATK, 1 ) );
            //pDotaTemplate->sDPointShopItemList.vecItemList.push_back( std::make_pair(GC_GAME_ITEM_SUPER, 30 ) );
            //pDotaTemplate->sDPointShopItemList.vecItemList.push_back( std::make_pair(GC_GAME_ITEM_HALLOW, 40 ) );
            //pDotaTemplate->sDPointShopItemList.vecItemList.push_back( std::make_pair(GC_GAME_ITEM_REFLECTION, 50 ) );
            //pDotaTemplate->sDPointShopItemList.vecItemList.push_back( std::make_pair(GC_GAME_ITEM_DOTA_CRITICAL, 60 ) );
            //pDotaTemplate->sDPointShopItemList.vecItemList.push_back( std::make_pair(GC_GAME_ITEM_DOTA_NPC_ATTACKUP, 70 ) );
            //pDotaTemplate->sDPointShopItemList.vecItemList.push_back( std::make_pair(GC_GAME_ITEM_DOTA_NPC_DEFANCEUP, 80 ) );
            //pDotaTemplate->sDPointShopItemList.vecItemList.push_back( std::make_pair(GC_GAME_ITEM_DOTA_NPC_HPUP, 90 ) );
            //pDotaTemplate->sDPointShopItemList.vecItemList.push_back( std::make_pair(GC_GAME_ITEM_DOTA_NPC_SPEEDUP, 100 ) );
            //pDotaTemplate->sDPointShopItemList.vecItemList.push_back( std::make_pair(GC_GAME_ITEM_DOTA_MOVE_ARENA, 110 ) );
        }

        // 플레이어 DPoint처리
        std::map< DWORD, std::pair<char,int > >::iterator mapDPointIter = kRecv.m_mapUserDPointInfo.begin();
        for(; mapDPointIter != kRecv.m_mapUserDPointInfo.end(); ++mapDPointIter)
        {
            PLAYER* pPlayer = g_MyD3D->GetPlayerByUID( mapDPointIter->first );
            if( pPlayer )
                pPlayer->Set_MAX_D_Point( mapDPointIter->second.second );
        }
    }

    g_MyD3D->m_pStateMachine->GoLoading();

    g_kGlobalValue.m_iSendTimeForPacket = -1;
    std::vector<KAddSendPacket>::iterator vecIter = g_kGlobalValue.m_vecSendPacket.begin();
    for(; vecIter != g_kGlobalValue.m_vecSendPacket.end(); )
        vecIter = g_kGlobalValue.m_vecSendPacket.erase( vecIter );
    g_kGlobalValue.m_vecSendPacket.clear();

#if defined( USE_QA_LOG_SYSTEM )
    SiKGCQALogManager()->StartGameLog( kRecv.m_kRoomInfo );
#endif
    //랭크 보정 수치 관련 파일 스크립트 로드
    g_pkQuestManager->LoadRankCorrectionScript();
    g_pkQuestManager->ClearDungeonDetailInfo();

    // 차원의 문 시작 맵 세팅 
    SiKGCInfinityDungeonManager()->SetStartStageIndex( kRecv.m_nStartStage );

    // 차원의 문 추가 랭크 초기화 
    if( SiKGCWorldMapManager()->IsInfinityDungeon( SiKGCRoomManager()->GetGameMode() ) ) { 
        g_pkQuestManager->SetInfinityDungeonPartyRank( g_pkQuestManager->GetPartyAvgRank() );
        g_pkQuestManager->SetInfinityDungeonMonsterLevel( SiKGCInfinityDungeonManager()->GetStartMonsterLevel( SiKGCRoomManager()->GetGameMode() ) );
    }
}

void SetSkillInPVPServer( KInDoorUserInfo& kPacket_ )
{
    if( g_kGlobalValue.ServerInfo.CheckServerType( ST_LOCK_SKILL_TREE ) ){
        std::vector< KInDoorCharInfo >::iterator itrCharInfo = kPacket_.m_vecCharInfo.begin();
        for( ; itrCharInfo!=kPacket_.m_vecCharInfo.end(); ++itrCharInfo ){
            std::map<char, std::vector<KSkillSlot> >::iterator itrSkillSet = (*itrCharInfo).m_mapEquipSkillSet.begin();
            for( ; itrSkillSet!=(*itrCharInfo).m_mapEquipSkillSet.end(); ++itrSkillSet ){
                itrSkillSet->second.clear();
            }
        }
    }
}

void EnterRoom(KJoinRoomAckInfo& kRecv)
{
    if (SiKGCMatchManager()->GetCurrentState() == KGCMatchManager::MSTATE_COMPLETE_STATE) {
        SiKGCMatchManager()->SetCurrentState(KGCMatchManager::MSTATE_ROOM_STATE);
    }
    //====================================================================================
    // 2006.07.14 : Asirion
    // RelayServer°ü·Ã ¼¼ÆÃ    
    //g_MyD3D->m_GildChannel = ( kRecv.m_kRoomInfo.m_bGuild && g_kGlobalValue.ServerInfo.bIsGuildServer );
    KSingleton<KncP2P>::GetInstance()->ResetConnectQ();


    // 060301. kkurrung. TCP Relay ¸¦ À§ÇØ¼­ p2p ¾È¿¡ ÀÖ´Â  TRUserProxy¸¦ ¿¬°áÇØÁØ´Ù.
    in_addr in;
    in.S_un.S_addr = kRecv.m_kRoomInfo.m_dwTRelayServerIP;

    KSingleton<KncP2P>::GetInstance()->SetupRelayServer(kRecv.m_kRoomInfo.m_dwRelayServerIP, kRecv.m_kRoomInfo.m_usRelayServerPort);
    SiKP2P()->DisConnectTCPRelay();

    if (!SiKP2P()->m_spTRUserProxy->Connect(inet_ntoa(in), kRecv.m_kRoomInfo.m_usTRelayServerPort, g_kGlobalValue.ServerInfo.dwUserUID))
    {
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_TCP_CONNECT_FAIL), L"");
        SiGCClientErrorManager()->ErrorCollect(KEventErr::ERR_NETWORK, KNetWorkErr::CE_TCP_CONNECT_ERROR);
    }

    SiKP2P()->m_spTRUserProxy->SetPingTimeoutLimit(GetRelayPingLimit());
    SiKP2P()->m_spTRUserProxy->SetPingSendGap(GetRelayPingInterval());


    //====================================================================================
    ((KGCStateLoading*)g_MyD3D->m_pStateMachine->GetStatePtr(GS_GAME_LOADING))->ClearUserConnectState();

#if defined(USE_PING_STATE_UI) && !defined(USE_ONLY_TCP_RELAY) && !defined(USE_P2P_OR_TCP_RELAY)
    KP2P::GetInstance()->Send_PingInfoNot(g_kGlobalValue.GetTRAvgPing());
    KP2P::GetInstance()->Send_RoomMemberPingInfoReq();
#endif

    g_MyD3D->Clear_PlayerData();

    for (int i = 0; i < (int)kRecv.m_veckInDoorUserInfo.size(); ++i)
    {
        if (kRecv.m_veckInDoorUserInfo[i].m_dwUserUID == g_kGlobalValue.m_kUserInfo.dwUID)
        {
            g_kGlobalValue.m_kUserInfo = kRecv.m_veckInDoorUserInfo[i];
        }

        SetSkillInPVPServer(kRecv.m_veckInDoorUserInfo[i]);
        On_INSERT_USER(kRecv.m_veckInDoorUserInfo[i]);
    }

    // ¼­¹ö¿¡¼­ ¹ÞÀº ¾ÆÀÌÅÛ Á¤º¸¿¡´Â ±âº»º¹ÀåÀÌ Á¦°Å µÇ¾î ÀÖ´Ù. ±âº»º¹ÀåÀ» ÀÔÈ÷ÀÚ.
    for (int i = 0; i < (int)g_kGlobalValue.m_kUserInfo.vecCharInfo.size(); ++i)
    {
        g_pItemMgr->EquipBaseItem(&g_kGlobalValue.m_kUserInfo.vecCharInfo[i]);
    }

    // ¿ùµå¸Ê ¸Å´ÏÀú¿¡ ÇöÀç ¿ùµå¸Ê Á¤º¸µµ °»½ÅÇØÁÖÀÚ 
    SiKGCRoomManager()->UpdateRoomInfo(&kRecv.m_kRoomInfo);
    int iCurWorldMap = -1;
    if (SiKGCWorldMapManager()->GetWorldMapOfGameMode(static_cast<EGCGameMode>(kRecv.m_kRoomInfo.m_iGameMode), iCurWorldMap)) {
        SiKGCWorldMapManager()->SetCurrentWorldMap(iCurWorldMap);
    }

    g_MyD3D->m_pStateMachine->GoRoom((int)kRecv.m_kRoomInfo.m_usRoomID, kRecv.m_kRoomInfo.m_strRoomName, kRecv.m_kRoomInfo.m_strRoomPasswd);
    SiKGCInviteManager()->m_bInviteAccept = false;


    g_pkUIScene->RoomSceneUpdateData();
    if (g_pkUIScene->m_pkGuildLobbyDlg->IsRenderOn())
    {
        g_pkUIScene->DeleteWaitMsgBox(KGCUIScene::GC_MBOX_GUILD_LOBBY_DLG);
        g_pkUIScene->m_pkGuildLobbyDlg->SpeakToActionListener(KActionEvent(g_pkUIScene->m_pkGuildLobbyDlg, KD3DWnd::EWNDMESSAGE_CLOSE));
    }

    g_pkUIScene->RoomButtonSetStartDelay();
    g_MyD3D->MyCtrl->NoSleep();

#if defined(USE_PLAY_COUNTRY_GROUP)
    if (g_kGlobalValue.m_kUserInfo.strNation == kRecv.m_kRoomInfo.m_wstrCCode)
        g_pkChatManager->AddChatMsg(g_pkStrLoader->GetString(STR_ID_PLAY_SAME_COUNTRY_MESSAGE1), KGCChatManager::CHAT_TYPE_ADMIN);
    else
        g_pkChatManager->AddChatMsg(g_pkStrLoader->GetString(STR_ID_PLAY_SAME_COUNTRY_MESSAGE2), KGCChatManager::CHAT_TYPE_ADMIN);
#endif



}

void On_EVENT_VERIFY_ACCOUNT_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_VERIFY_ACCOUNT_ACK);

    Result_Connect_GameServer = kRecv.m_ucOK;

    if (KP2P::GetInstance()->IsConnectedToGameServer() == false)
        return;
    g_kGlobalValue.m_tFirstLoginTime = kRecv.m_tFirstLoginTime;


#if defined(RETRY_LOGIN_ON_CLOSE_CONNECTION)
    if (g_kGlobalValue.m_bServerReconnection)
        g_kGlobalValue.m_bServerReconnection = false;
#endif

    if (g_kGlobalValue.m_bCheckChangedKOM)
        kRecv.m_ucOK = 4;

    if (kRecv.m_ucOK == 0)
    {
        g_kGlobalValue.m_bSendServerInfoNot = false;
        g_kGlobalValue.m_bIsGetWebCashOnStateMyInfoFirstInit = false;
#if defined (USE_MAGIC_BOX)
        KP2P::GetInstance()->Send_MagicBoxListReq();
#endif

        if (g_kGlobalValue.m_kUserInfo.vecCharInfo.empty() == false
            && g_kGlobalValue.m_kUserInfo.dwUID == kRecv.m_dwUserUID)
        {
            KCharInfoVector::iterator vecCharInfoItr = g_kGlobalValue.m_kUserInfo.vecCharInfo.begin();
            for (; vecCharInfoItr != g_kGlobalValue.m_kUserInfo.vecCharInfo.end(); ++vecCharInfoItr) {
                std::map< char, KCharacterInfo >::iterator mit = kRecv.m_mapCharacterInfo.find(static_cast<char>(vecCharInfoItr->iCharType));
                if (mit != kRecv.m_mapCharacterInfo.end()) {
                    if (vecCharInfoItr->biExp < mit->second.m_biExp) {
                        SiGCClientErrorManager()->ErrorCollect(KEventErr::ERR_CLIENTRPT, KClientErr::CE_EXP_DOWN);
                        continue;
                    }
                    else if (vecCharInfoItr->biExp > mit->second.m_biExp)
                    {
                        SiGCClientErrorManager()->ErrorCollect(KEventErr::ERR_CLIENTRPT, KClientErr::CE_EXP_UP);
                        continue;
                    }
                }
            }

        }

        g_kGlobalValue.m_kUserInfo.Init();
        g_kGlobalValue.m_kLoginInfo.iSessionInfo = kRecv.m_iSessionInfo;
        g_kGlobalValue.m_kLoginInfo.bNewUser = (kRecv.m_iSessionInfo == 0) || g_kGlobalValue.m_kLoginInfo.bNewUser;

        g_kGlobalValue.m_kUserInfo.strGuildName = L"";

        if (g_kGlobalValue.m_kUserInfo.iGuildID <= -1)
        {
            g_kGlobalValue.m_kUserInfo.iGuildScore = 0;
            g_kGlobalValue.m_kUserInfo.strMarkName = L"";
        }

        g_kGlobalValue.ServerInfo.dwServerType = kRecv.m_dwServerType;
        g_kGlobalValue.m_kGuildUserInfo.m_ChannelGrade = kRecv.m_kGuildUserInfo.m_ChannelGrade;
        g_kGlobalValue.ServerInfo.strServerName = kRecv.m_strServerName;

        g_kGlobalValue.m_kUserInfo.strLogin = kRecv.m_strLogin;
        g_kGlobalValue.m_kUserInfo.strNickName = L"";
        g_kGlobalValue.m_kUserInfo.m_nSlotCount = kRecv.m_dwUserRemainIndexCnt;
        g_kGlobalValue.SetSavedCharType(kRecv.m_cLastPlayCharacter);

        int nMaxCharSize = g_kGlobalValue.m_kUserInfo.m_nSlotCount + g_kGlobalValue.m_kUserInfo.vecCharInfo.size();
        if (nMaxCharSize > GC_CHAR_NUM)
        {
            g_kGlobalValue.m_kUserInfo.m_nSlotCount = GC_CHAR_NUM - g_kGlobalValue.m_kUserInfo.vecCharInfo.size();
        }

        if (false == kRecv.m_strNickName.empty())
        {
            g_pkUIScene->m_pkNickNameBox->SetNickNameRegisterComplete(true);
            g_kGlobalValue.m_kUserInfo.strNickName = kRecv.m_strNickName;
            g_kGlobalValue.m_kUserInfo.strNickColor = kRecv.m_strNickColor;

#ifdef NICKNAME_CAMPAIGN

            if (g_pkUIScene->m_pkNicknameCampaignBox->IsValidNickname() == false) {
                g_pkUIScene->m_pkNicknameCampaignBox->SetValidNickname(false);
            }
            else {
                g_pkUIScene->m_pkNicknameCampaignBox->SetValidNickname(true);
            }
#endif
        }
        else
            g_pkUIScene->m_pkNickNameBox->SetNickNameRegisterComplete(false);

        g_bAgreePrivateInfo = kRecv.m_bAgreePrivateInfo;

        g_pkUIScene->RoomButtonSetAutoStart(g_kGlobalValue.ServerInfo.CheckServerType(ST_INDIGO));

        if (g_kGlobalValue.ServerInfo.CheckServerType(ST_INDIGO))
        {
            g_kGlobalValue.m_kUserInfo.iIndigoWin = kRecv.m_iIndigoWin;
            g_kGlobalValue.m_kUserInfo.iIndigoLose = kRecv.m_iIndigoLose;
        }

        g_kGlobalValue.m_kUserInfo.clsUserBenefitType = kRecv.m_cUserBenfitType;
        g_kGlobalValue.m_kUserInfo.cIsNetmarblePCRoom = kRecv.m_cPCBangType;

        for (UINT i = 0; i < (int)kRecv.m_vecMsg.size(); ++i)
        {
            std::wstring strMsg = kRecv.m_vecMsg[i];

            if (!strMsg.empty())
            {
                g_kGlobalValue.m_vecDelayMsg.push_back(strMsg);
            }
        }

        g_kGlobalValue.ServerInfo.dwPublicIP = kRecv.m_dwIP;
        g_kGlobalValue.ServerInfo.usUdpPort = kRecv.m_usUdpPort;
        g_kGlobalValue.ServerInfo.dwUserUID = kRecv.m_dwUserUID;
        g_kGlobalValue.m_kUserInfo.dwUID = kRecv.m_dwUserUID;
        g_kGlobalValue.m_kUserInfo.bMan = kRecv.m_bMale;
        g_kGlobalValue.m_kUserInfo.iRP = kRecv.m_iRP;
        g_kGlobalValue.m_kUserInfo.iGetRP = 0;
        g_kGlobalValue.m_kUserInfo.iRPRank = kRecv.m_iRPRank;
        g_kGlobalValue.m_kUserInfo.iAge = kRecv.m_iAge;

        SiKGCEventManager()->ClearEvents();

        GCFUNC::ConvertPetInfo(g_MyD3D->m_mapPetInfo, kRecv.m_mapPetInfo);

        SCharInfo Info;
        std::map<char, KCharacterInfo>::const_iterator mit;
        g_kGlobalValue.m_kUserInfo.ClearChar();
        for (mit = kRecv.m_mapCharacterInfo.begin(); mit != kRecv.m_mapCharacterInfo.end(); ++mit)
        {
            GCFUNC::ConvertCharInfo(Info, mit->second);
            g_kGlobalValue.m_kUserInfo.AddChar(Info);
        }

        g_kGlobalValue.m_kUserInfo.cCharIndex = g_kGlobalValue.GetSavedCharTypeToIndex();
        if (g_kGlobalValue.ServerInfo.CheckServerType(ST_NO_AP_CHAR))
        {
            g_kGlobalValue.m_kUserInfo.cCharIndex = 0;
        }

        g_kGlobalValue.m_mapSealedCharInfo = kRecv.m_kSealedCharInfoNot.m_mapSealedCharInfo;

        if (g_kGlobalValue.m_kUserInfo.vecCharInfo.empty())
        {
            g_kGlobalValue.m_kUserInfo.cCharIndex = -1;
        }
        else
        {
            int nCharIndexInMap = g_kGlobalValue.m_kUserInfo.vecCharInfo[g_kGlobalValue.m_kUserInfo.cCharIndex].iCharType;
            std::map< int, KSealedCharInfo >::iterator mitSealedChar;
            mitSealedChar = g_kGlobalValue.m_mapSealedCharInfo.find(nCharIndexInMap);
            if (mitSealedChar != g_kGlobalValue.m_mapSealedCharInfo.end()) {
                if (true == mitSealedChar->second.m_bIsSealed && false == mitSealedChar->second.m_bIsEventTerm) {
                    g_kGlobalValue.m_kUserInfo.cCharIndex = 0;
                }
            }
        }

        for (int i = 0; i < (int)g_kGlobalValue.m_kUserInfo.GetCharSize(); ++i)
        {
            if (g_kGlobalValue.m_kUserInfo.vecCharInfo[i].biExp < 100)
                g_kGlobalValue.m_kUserInfo.vecCharInfo[i].biExp = 100;
        }

        g_kGlobalValue.m_kUserInfo.m_vecFontVector = kRecv.m_vecFontVector;
        g_kGlobalValue.m_kUserInfo.m_iPvExp = kRecv.m_iPvExp;

        g_MyD3D->m_TempPlayer.m_kUserInfo = g_kGlobalValue.m_kUserInfo;

        g_pkUIScene->m_pkTitleCollection->RefreshTitleList();

        g_kGlobalValue.m_kUserInfo.eGCUserLevel = (EGCUserLevel)kRecv.m_cAuthLevel;

        if (g_kGlobalValue.ServerInfo.CheckServerType(ST_INDIGO))
        {
            g_kGlobalValue.ServerInfo.SetServerType(ST_BROADCASTING);
        }

        KEquipUser kEquip;
        kEquip.m_strLogin = g_kGlobalValue.m_kUserInfo.strLogin;
        kEquip.m_cCharType = g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar().iCharType;

        int iCount = 0;
        bool bEquipChanged = false;
        for (mit = kRecv.m_mapCharacterInfo.begin(); mit != kRecv.m_mapCharacterInfo.end(); ++mit)
        {
            std::vector<KEquipItemInfo>::const_iterator vit;
            SCharInfo& kCharInfo = g_kGlobalValue.m_kUserInfo.vecCharInfo[iCount];
            KChangeEquipment kChangeEquipment;
            kChangeEquipment.m_equipPetInfo = kCharInfo.kPetInfo;
            kChangeEquipment.m_equipPetInfo.m_dwID = kCharInfo.kPetInfo.m_dwID * 10;
            kChangeEquipment.m_equipPetInfo.m_dwUID = kCharInfo.kPetInfo.m_dwUID;
            std::vector<KSimpleItem> KSimplePetItem;
            KSimplePetItem = kCharInfo.kPetInfo.m_vecEquipItem;
            std::vector<KSimpleItem>::iterator vitTmp = KSimplePetItem.begin();
            for (; vitTmp != KSimplePetItem.end(); ++vitTmp)
            {
                vitTmp->m_dwID *= 10;
                vitTmp->m_dwUID = vitTmp->m_dwUID;
            }

            kChangeEquipment.m_equipPetInfo.m_vecEquipItem = KSimplePetItem;
            g_pItemMgr->EquipBaseItem(&kCharInfo);

            kEquip.m_mapEquipInfo.insert(std::make_pair((char)kCharInfo.iCharType, kChangeEquipment));

            for (vit = mit->second.m_vecEquipItems.begin(); vit != mit->second.m_vecEquipItems.end(); ++vit)
            {
                if (vit->m_dwUID < 0)
                    break;

                GCItem* kItem = g_pItemMgr->GetItemData(vit->m_dwID / 10);
                if (mit->first == g_kGlobalValue.m_kUserInfo.GetCurrentChar().iCharType) {
                    g_pItemMgr->EquipInventoryItem(&kCharInfo, vit->m_dwUID);
                }
                else {
                    g_pItemMgr->EquipItem(&kCharInfo, kItem, false, 0, false);
                }
            }

            for (vit = mit->second.m_vecLookEquips.begin(); vit != mit->second.m_vecLookEquips.end(); ++vit)
            {
                if (vit->m_dwUID < 0)
                    break;

                if (mit->first == g_kGlobalValue.m_kUserInfo.GetCurrentChar().iCharType) {
                    g_pItemMgr->EquipInventoryItem(&kCharInfo, vit->m_dwUID, true);
                }
                else
                {
                    int dwItemID = vit->m_dwID / 10;
                    if (vit->m_DesignCoordiID != 0)
                    {
                        dwItemID = vit->m_DesignCoordiID / 10;
                    }

                    GCItem* kItem = g_pItemMgr->GetItemData(dwItemID);
                    if (kItem != NULL)
                    {
                        g_pItemMgr->EquipItem(&kCharInfo, kItem, false, 0, true);
                    }
                }
            }

            ++iCount;
        }

        g_kGlobalValue.m_kUserInfo.mapStagePlayable = kRecv.m_mapDifficulty;

        g_kGlobalValue.m_kUserMission.ClearUserMission();

        SiKGCPrivateDungeonManager()->CheckFirstDungeon(GC_CHAR_INVALID);
#ifndef DISABLE_DIMENSIONAL_PORTAL_SPLASH
        SiKGCInfinityDungeonManager()->CheckShowGuide();
#endif

        g_kGlobalValue.m_kUserMission.SetUserMissionList(kRecv.m_vecMissionSlot, false);
        g_kGlobalValue.m_kUserMission.RefreshUserMission();

        std::map<char, KCharacterInfo>::iterator mitCharInfo = kRecv.m_mapCharacterInfo.find(g_kGlobalValue.m_kUserInfo.GetCurrentChar().iCharType);
        if (mitCharInfo != kRecv.m_mapCharacterInfo.end())
        {
            g_kGlobalValue.m_iInvenCapacity = mitCharInfo->second.m_nInvenCapacity;
            g_kGlobalValue.m_iCoordiCapacity = mitCharInfo->second.m_nLookInvenCapacity;
        }
        else
        {
            g_kGlobalValue.m_iInvenCapacity = DEFAULT_INVENTORY_NUM;
            g_kGlobalValue.m_iCoordiCapacity = GC_COORDI_INVEN_SIZE;
        }

        if (!kRecv.m_kMsgServerInfo.m_strIP.empty())
        {
            g_kGlobalValue.m_kMsgServerInfo = kRecv.m_kMsgServerInfo;
            g_kGlobalValue.m_kVerifyInfo.m_dwUserUID = kRecv.m_dwUserUID;
            g_kGlobalValue.m_kVerifyInfo.m_strLogin = kRecv.m_strLogin;
            g_kGlobalValue.m_kVerifyInfo.m_strNickName = kRecv.m_strNickName;
            g_kGlobalValue.m_kVerifyInfo.m_strServerName = kRecv.m_strServerName;
            g_kGlobalValue.m_kVerifyInfo.m_strLocation = g_MyD3D->m_pStateMachine->GetCurrentLocation();
            g_kGlobalValue.m_kVerifyInfo.m_iLocationNum = -1;
            g_kGlobalValue.m_kVerifyInfo.m_bGamming = false;
            g_kGlobalValue.m_kVerifyInfo.m_nLanguageCode = SiKGCMultipleLanguages()->GetLanguageTypeNumber();
    }

        if (KP2P::GetInstance()->m_kMsgServer != NULL)
            KP2P::GetInstance()->m_kMsgServer->SetMsgServerInfo(kRecv);

#ifndef __PATH__
        {
            bool bHb = false;
            if (KP2P::GetInstance()->m_pkUserProxy)
                KP2P::GetInstance()->m_pkUserProxy->SendPacket(KUserEvent::EVENT_SET_HBCHECK_FLAG, bHb);
        }
#endif
        g_kGlobalValue.m_bExistCalendar = false;
        g_kGlobalValue.m_iGCPoint = 0;

        g_kGlobalValue.m_kUserInfo.dwPremium = kRecv.m_kPremiumInfo.m_dwPremiumType;

        SiKGCWorldMapManager()->SetCurrentSelectDungeon(-1);

        if ((g_kGlobalValue.m_bIsRecommendEvent = kRecv.m_bIsRecommendEvent) == true)
        {
            KP2P::GetInstance()->Send_CheckRecomEnableReq();
            Result_RecomEnable = INT_MAX;
            g_MyD3D->WaitForServerAck(Result_RecomEnable, INT_MAX, 5000, TIME_OUT_VALUE);
        }

        SiGCSKT()->SetOrigSkillTree();
        KP2P::GetInstance()->Send_GetFullSkillInfo();
        KP2P::GetInstance()->Send_PetCostumeListReq();
        KP2P::GetInstance()->Send_InvenBuffItemListReq();

#if defined( USE_PACKAGE_PREVIEW )
        Result_AgitShopCatalog = INT_MAX;

        if (g_pItemMgr)
        {
            g_pItemMgr->ClearPackageInfo();
        }


#endif

        if (g_kGlobalValue.ServerInfo.CheckServerType(ST_PVP_BALANCE))
        {
            g_MyD3D->UnEquipMyPvPNotUseItems();
#if defined (USE_JOYSTICK)
            IsUseJoystic = false;
#endif
            if (g_kGlobalValue.ServerInfo.CheckServerType(ST_ENTER_LIMIT))
            {
#if !defined( NATION_USA ) && !defined( NATION_KOREA ) && !defined( NATION_TAIWAN )&& !defined( NATION_EU ) && !defined(NATION_CHINA)
                g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_TOURNAMENT_STR01));
                g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_AGREEMENT, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, STR_ID_TOURNAMENT_STR02);
#endif
            }
        }

}
    if (g_kGlobalValue.ServerInfo.CheckServerType(ST_LOCK_SKILL_TREE))
    {
        for (int i = 0; i < GC_CHAR_NUM; i++)
        {
            for (int j = 0; j < NUM_JOB_LEVEL; j++)
            {
                SiGCSKT()->UnequipAllSkill(i, j, 0);
                SiGCSKT()->UnequipAllSkill(i, j, 1);
            }
        }
        SiGCSKT()->ApplySettingToServer();
        g_MyD3D->UnequipCashSkill();

        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            }

#if !defined( SERVER_ONLY_NON_COUNT_ITEM )
    g_pkUIScene->m_pkInventoryFullMsg->UpdateMsg();
#endif

    Result_Connect_GameServer = kRecv.m_ucOK;

    g_kGlobalValue.m_bIncompletePatch = false;

#if defined( USE_ONLY_TCP_RELAY ) || defined( USE_P2P_OR_TCP_RELAY )
    KP2P::GetInstance()->Send_TRInfoReq();
#endif



#if defined( USE_SURVEY_SYSTEM )

    g_pkUIScene->m_pkSurveyDlg->OnEventSurveyListNot(kRecv.m_kSurveyList);

#endif

#ifdef GAME_CASH
    KP2P::GetInstance()->Send_CurrentCashPoint();
#endif

    SiKGCDepotManager()->Send_DepotInfo();

    if (kRecv.m_nGetNewCharID != -1) {
        g_kGlobalValue.m_iGetCharType = kRecv.m_nGetNewCharID;
    }

    if (!kRecv.m_vecGachaUseVersions.empty()) {
        g_kGlobalValue.m_vecGachaUseVersion.clear();
        g_kGlobalValue.m_vecGachaUseVersion = kRecv.m_vecGachaUseVersions;
    }

    SiKGCFatigueManager()->GetCurrentInfo();

    if (kRecv.m_bTutorialEnable)
        g_pkGameOverlayUI->m_pkAddtionGuide->SetGuideUserState(STATE_FIRST_LOGIN);
    else
        g_pkGameOverlayUI->m_pkAddtionGuide->SetGuideUserState(STATE_TUTORIAL_END);

    SAFE_DELETE(pkBuff);
}

void JoinRoomBroadUserProcess(KInDoorUserInfo& kInDoorUserInfo)
{
    SetSkillInPVPServer(kInDoorUserInfo);
    On_INSERT_USER(kInDoorUserInfo);
    g_pkUIScene->RoomSceneUpdateData();
}

void On_EVENT_USE_DURATION_ITEM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<KItem> );
    // TODO : 수량아이템 사용후의 남은 수 등의 정보를 받는다.
    // (kRecv의 타입은 std::vector<KDurationItemInfo> 자체.)
    g_pItemMgr->m_kInventory.AddItemList(kRecv, true);
    SAFE_DELETE( pkBuff );
}

void On_EVENT_DETAIL_USER_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DETAIL_USER_INFO_ACK );

    // TODO : 요청한 유저의 상세 정보를 받는다.
    // m_nOK    : 성공 0. 실패값은 UserPacket.h 참조.
    // m_kData  : 유저 정보.
    if( kRecv.m_nOK == 0 )
    {
        g_kDetailUserInfo = kRecv.m_kData;
        g_bDetailUserInfoUpdate = true;
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_ITEM_EXPIRED_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ITEM_EXPIRED_NOT );
    // TODO : 기간이 만료된 아이템 정보를 받아 이를 인벤토리에서 삭제한다.
    // (kRecv의 타입은 std::vector<KItemInfo> 자체.)

    if ( g_kGlobalValue.m_kUserInfo.strLogin == kRecv.m_strLogin )
    {
        g_pItemMgr->m_kInventory.RemoveItemList( kRecv.m_vecItem );
        g_pItemMgr->UpdateUserItem( &g_kGlobalValue.m_kUserInfo );
    }

    //////////////////////////////////////////////////////////////////////////
    // 이거 -_-;; 체인지 룸 유저 인포도 사실상 보낼 필요가 없는 듯하고,, expire된 아이템도.. 서버에서 바로 처리하면 안될까;;;
    //게임 중이라면 MyPlayer정보를 다시 전달한다
    if( g_MyD3D->m_pStateMachine->IsStateRoom() || 
        g_MyD3D->m_pStateMachine->GetState() == GS_GAME_END )
    {
        int iIndex = g_MyD3D->Get_MyPlayer();
        if( iIndex < MAX_PLAYER_NUM )
        {
            KP2P::GetInstance()->Send_ChangeRoomUserInfoReq( g_kGlobalValue.m_kUserInfo,
                KChangeRoomUserInfo::RUI_CHAR, g_MyD3D->Get_MyPlayer() );
        }
    }
    SAFE_DELETE( pkBuff );
}

void On_EVENT_GIFT_ITEM_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GIFT_ITEM_NOT );
    SAFE_DELETE( pkBuff );

    //std::vector< std::pair< std::wstring, DWORD> >  --> Comment, 대표 ItemID
    //kRecv.m_vecGiftItemList;
    // 이미 인벤토리에 들어 있는 상태이므로 인벤토리에 아이템 넣을 필요 없음.
    // 단순 디스플레이용..

    //if( kRecv.m_vecGiftItemList.empty() ) // 비어 있으면 리턴.
    //    return;

    //for( UINT i = 0; i < (int)kRecv.m_vecGiftItemList.size(); ++i )
    //{
    //    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_REPETITION_EVENT_BOX,
    //        kRecv.m_vecGiftItemList[i].m_wstrComment,
    //        g_pkStrLoader->GetString( STR_ID_REPETITION_MESSAGE1 ),
    //        KGCUIScene::GC_MBOX_USE_NORMAL, kRecv.m_vecGiftItemList[i].m_ItemID, 0 );
    //}
}

//void On_EVENT_INDICATE_CONNECT_NOT( WPARAM wParam, LPARAM lParam )
//{
//  KSerializer ks;
//  ACK_DESERIALIZE( KEVENT_INDICATE_CONNECT_NOT );
//  if ( g_MyD3D->m_pStateMachine->GetState() == GS_ROOM ||
//      g_MyD3D->m_pStateMachine->GetState() == GS_GAME ||
//      g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO_FROM_ROOM )
//  {
//      KSingleton<KncP2P>::GetInstance()->ConnectionSupport( kRecv.m_vecIP, kRecv.m_vecPort, kRecv.m_dwUserUID );
//  }
//  SAFE_DELETE( pkBuff );
//}

void On_EVENT_UDP_PORT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( USHORT );
    SAFE_DELETE( pkBuff );
    // m_usData : 서버에서 확인한 클라이언트의 UDP port.
    KSingleton<KncP2P>::GetInstance()->SetEchoPort( g_kGlobalValue.ServerInfo.dwPublicIP, kRecv );

}

void On_EVENT_REGISTER_NICKNAME_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPacketNameOK );
    SAFE_DELETE( pkBuff );
    //m_nOK
    // 0 : 성공O
    //-1 : 해당 유저가 존재하지 않음. -_-
    //-2 : 해당 유저는 이미 닉네임이 등록되어 있음.
    //-3 : 이미 존재하고 있는 닉네임이 있음.(다른 유저가 이미 등록했음)
    //-4 : 부적절한 닉네임(빈칸, 탭, \', 욕설, 크기가0, 제한크기초과..등)
    //-5 : DB에서 아무런 응답이 없음. 쿼리문에서 아무것도 얻지 못했음.

    Result_ReportNickName = kRecv.m_nOK;

    if ( Result_ReportNickName == 0)
    {
        g_pkUIScene->m_pkCharSelectScene->GetCharInfoFrame()->m_pkBackGroundWhite->ToggleRender( false );
        g_pkUIScene->m_pkCharSelectScene->GetCharInfoFrame()->LockEmptySlot( false );
    }

}

void On_EVENT_HOST_MIGRATED_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_HOST_MIGRATED_NOT );
    SAFE_DELETE( pkBuff );

    On_HOSTMIGRATE( kRecv );
}

void On_EVENT_INFORM_USER_LEAVE_ROOM_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_INFORM_USER_LEAVE_ROOM_NOT );
    SAFE_DELETE( pkBuff );
    //====================================================================================
    // 2006.07.14 : Asirion
    // 1. 내가 강퇴.
    // 2. 다른사람의 퇴장
    // 7. 로딩시간초과
    switch( kRecv.m_nReasonWhy )
    {
    case 3:
        {
            if ( kRecv.m_dwUserUID == g_kGlobalValue.m_kUserInfo.dwUID )
                On_TERMINATE_USER( kRecv );
            else
                On_DESTROY_USER( kRecv );
            break;
        }
    case 6:
        {
            g_MyD3D->m_pStateMachine->ExitRoom( false );
            break;
        }
    case 7:
        {
            if ( kRecv.m_dwUserUID == g_kGlobalValue.m_kUserInfo.dwUID )
            {
                int iCurPlayerNum = 0;
                for( int i = 0; i < MAX_PLAYER_NUM; i++ )
                {
                    if( g_MyD3D->MyPlayer[i]->m_kUserInfo.bLive )
                        iCurPlayerNum++;
                }
                DWORD dwTime = timeGetTime() - g_dwLoadingTimeCheck;
                g_dwLoadingTimeCheck =0;
                KP2P::GetInstance()->Send_ClientFailedGameStartNot(2, dwTime, iCurPlayerNum, g_pkQuestManager->m_iCurStage);

                On_LOAD_TIMEOUT( kRecv );
            }
            else
                On_DESTROY_USER( kRecv );
            break;
        }
    default:
        {
            On_DESTROY_USER( kRecv );
            break;
        }
    }



    if( g_kGlobalValue.m_kChattingEvent.GetSuccessEvent() &&  g_MyD3D->m_pStateMachine->GetState() == GS_ROOM )
    {
        g_kGlobalValue.m_kChattingEvent.SetSuccessEvent(false);
        g_pkChatManager->AddSystemMsg( -1, g_pkStrLoader->GetString( STR_ID_CHAT_EVENT_DISABLED1 ) );
    }

    if( g_kGlobalValue.m_kUserInfo.bHost )
        SiKGCRoomManager()->GetRoomInfo().iRestBanCount = kRecv.m_dwBanishCount;
}

void On_EVENT_CONSIDER_INVALID_MAJOR_DATA_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ExitWithHackAlert( L"Error : 0x00what" );
}


void On_EVENT_QUERY_INVENTORY_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    // 인벤토리 정보를 한번 더 리프레쉬한다.
    ACK_DESERIALIZE( KEVENT_QUERY_INVENTORY_INFO_ACK );
    SAFE_DELETE( pkBuff );

    // [1/20/2008] breadceo. 퀵슬롯 초기화
    g_MyD3D->GetMyShortCutSlot()->Clear();

    g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecInv, true );

    g_MyD3D->GetMyShortCutSlot()->initQuickSlot( g_kGlobalValue.m_kUserInfo.kQuickSlot );

    g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    g_pkUIScene->m_pkMyInfoScene->UpdateData();
    g_pkUIScene->ShowItemEffectGameInven( true );
    Result_Buy = 1;

}

void On_EVENT_SELL_ITEM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SELL_ITEM_ACK );
    SAFE_DELETE( pkBuff );

    switch ( kRecv.m_nOK )
    {
    case 0: // 성공
        {
            if ( !kRecv.m_vecItem.empty() ) {
                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem, true );
            }
            g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGP );
            g_MyD3D->MyPlayer[ g_MyD3D->Get_MyPlayer() ]->m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGP );
            g_kGlobalValue.m_kUserMission.RefreshUserMission();
            g_kGlobalValue.m_kUserCollectionMission.RefreshUserCollectionMission();
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();

            //  룸안이면
            if ( g_MyD3D->m_pStateMachine->IsStateRoom() ) 
            {
                g_pkUIScene->m_pkRoomSceneS6->UpdateMissionData();
            }

            Result_Drop = 1;
            break;
        }
    case -1: // Ownerlogin이 존재 하지 않음.
        {
            Result_Drop = 3;
            break;
        }
    case -2: // Owner가 해당 상품을 가지고 있지 않음.
        {
            Result_Drop = 4;
            break;
        }
    case -3: // 상품 정보가 없음
        {
            Result_Drop = 5;
            break;
        }
    case -4: // 제거할 수 없는 상품(event 상품)
        {
            Result_Drop = 6;
            break;
        }
    case -5: // 알 수 없는 에러
        {
            Result_Drop = 7;
            break;
        }
    case -98: //    작업중인 패킷
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PACKET_DELAY ));
            break;
        }
    default: // 발생 불가능한 경우
        {
            Result_Drop = 8;
            break;
        }
    }

}

void On_EVENT_START_GAME_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_START_GAME_BROAD );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK
    //  0   성공
    // -1   해당 유저의 상태가 올바르지 않음.
    // -2   길드존에서 게임을 시작하려고 했음.
    // -3   룸 포인터가 NULL이다
    // -4   현재 방의 상태가 WAITING이나 FULL이 아님
    // -5   요청자가 방장 또는 운영자가 아님 
    // -6   요청자가 필요한 아이템을 가지고 있지 않음
    // -7   혼자서 게임을 시작하려고 시도함.
    // -8   현재 게임모드 클리어 조건 단계가 유저의 클리어 단계보다 높다.
    // -9   지원 되지 않는 Mode Level 입니다.
    // -10  게임을 시작할 수 없음. 모든 유저가 Ready상태가 아님.
    // -11  영웅던전 모드가 비활성화 상태.
    // -12  영웅던전 정보가 없음.
    // -13  영웅던전 최소 레벨조건을 만족하는 캐릭터가 없음.
    // -14  영웅던전 입장 시간이 아닙니다.
    // -15  해당 시간대 영웅던전을 이미 플레이했음.
    // -16  영웅던전 일일 클리어할 수 있는 최대 회수를 플레이했음.    
    // -17  게임을 진행할 수 있는 시간이 아닙니다.

    std::wstringstream stm;
    std::wstringstream strm;
    std::wstring strColorKey    = L"#cff0000";
    std::wstring strColorKeyEnd = L"#cX";     
    stm << strColorKey << g_pkStrLoader->GetString( STR_ID_HERO_DUNGEON_START_GAME_ERROR ) << strColorKeyEnd;

    switch(kRecv.m_nOK)
    {
    case 0:
        if( SiKGCWorldMapManager()->IsHeroDungeonMode(SiKGCRoomManager()->GetGameMode()) )
            SiKGCRoomManager()->SetPlayedHeroDungeon(true);
        break;
    case -11:
    case -12:
        Result_StartGame = 11;
        break;
    case -13:
        Result_StartGame = 13;
        break;
    case -14:   
        Result_StartGame = 14;
        break;
    case -15:
        Result_StartGame = 15;
        break;
    case -16:
        Result_StartGame = 16;
        break;
    case -17:
        Result_StartGame = 17;
        break;        
    default:
        Result_StartGame = -99;
        break;
    }
}

void On_EVENT_START_GAME_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_START_GAME_BROAD );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK
    //  0   성공
    // -1   해당 유저의 상태가 올바르지 않음.
    // -2   길드존에서 게임을 시작하려고 했음.
    // -3   룸 포인터가 NULL이다
    // -4   현재 방의 상태가 WAITING이나 FULL이 아님
    // -5   요청자가 방장 또는 운영자가 아님 
    // -6   요청자가 필요한 아이템을 가지고 있지 않음
    // -7   혼자서 게임을 시작하려고 시도함.
    // -8   현재 게임모드 클리어 조건 단계가 유저의 클리어 단계보다 높다.
    // -9   지원 되지 않는 Mode Level 입니다.
    // -10  게임을 시작할 수 없음. 모든 유저가 Ready상태가 아님.
    // -11  영웅던전 모드가 비활성화 상태.
    // -12  영웅던전 정보가 없음.
    // -13  영웅던전 최소 레벨조건을 만족하는 캐릭터가 없음.
    // -14  영웅던전 입장 시간이 아닙니다.
    // -15  해당 시간대 영웅던전을 이미 플레이했음.
    // -16  영웅던전 일일 클리어할 수 있는 최대 회수를 플레이했음.

    if( kRecv.m_nOK == 0 )
    {              
        START_LOG( clog, kRecv.m_vecStartingUsers.size() );
        bool bHostMigration = true;

        //test 코드        
        std::vector<int> vecPing;

        for ( int i = 0; i < (int)kRecv.m_vecStartingUsers.size() ; ++i )
        {
            PLAYER* pPlayer = g_MyD3D->GetPlayerByUID( kRecv.m_vecStartingUsers[i] );

            if ( g_kGlobalValue.m_kUserInfo.dwUID != kRecv.m_vecStartingUsers[i] )
                vecPing.push_back(static_cast<int>(KSingleton<KncP2P>::GetInstance()->GetAvgPingTime(kRecv.m_vecStartingUsers[i])));

            if ( pPlayer )
            {
                pPlayer->m_kUserInfo.nUserState = GC_RUS_PLAYING;

                // 원래 호스트였던 유저가 새로전달받은 호스트uid와 같다면 호스트마이그레이션은 하지 않도록 하겠다.
                if( pPlayer->m_kUserInfo.bHost == true && pPlayer->m_kUserInfo.dwUID == kRecv.m_dwHostUID )                
                    bHostMigration = false;
            }
        }

#if defined(USE_P2P_OR_TCP_RELAY)
        g_kGlobalValue.CheckUseTcpRelay(vecPing);
        g_pStateGame->CountStatPing();
#elif defined( USE_ONLY_TCP_RELAY )
		g_kGlobalValue.UseTCPRelay(true);
#else
            g_kGlobalValue.UseTCPRelay(false);
#endif

#if defined(USE_HOST_MIGRATION)
        if( bHostMigration )
            if (GC_GMC_DUNGEON == SiKGCRoomManager()->GetGameModeCategory())
                On_HOSTMIGRATE_WithoutLeave( kRecv.m_dwHostUID );
#endif
		if ( SiKGCFatigueManager()->IsFatigueSystemApplyUser() ) {
			std::map<DWORD, int>::iterator mit = kRecv.m_mapUserFatigueRatio.find( g_kGlobalValue.m_kUserInfo.dwUID );
			if ( mit != kRecv.m_mapUserFatigueRatio.end() ) {
				SiKGCFatigueManager()->SetGameRatio(mit->second);
				if ( mit->second == 50 )
					SiKGCFatigueManager()->SetCurrentGameFatigueType( KGCFatigueManager::YELLOW_TIME );
				else
					SiKGCFatigueManager()->SetCurrentGameFatigueType( KGCFatigueManager::RED_TIME );
			} 
			else {
				SiKGCFatigueManager()->SetGameRatio(100);
				SiKGCFatigueManager()->SetCurrentGameFatigueType(KGCFatigueManager::GREEN_TIME);
			}

		}
		else {
			SiKGCFatigueManager()->SetGameRatio(100);
			SiKGCFatigueManager()->SetCurrentGameFatigueType(-1);
		}

        for ( int i = 0; i < (int)kRecv.m_vecStartingUsers.size() ; ++i )
        {
            if ( g_kGlobalValue.m_kUserInfo.dwUID == kRecv.m_vecStartingUsers[i] )
            {
                StartGame( kRecv );
                //if( SiKGCWorldMapManager()->IsHeroDungeonMode(SiKGCRoomManager()->GetGameMode()) )
                //    SiKGCRoomManager()->SetPlayedHeroDungeon(true);

                g_kGlobalValue.m_iPrevRemainVitality = g_kGlobalValue.GetVitality((int)g_MyD3D->MyPlayer[g_MyD3D->Get_MyPlayer()]->GetCurrentChar().iCharType);
                return;
            }
        }      
        
        g_pkUIScene->RoomSceneUpdateData();
        
    }
    else if( kRecv.m_nOK == -6 )
    {
        Result_StartGame = 2;
    }
    else if( kRecv.m_nOK == -11 || kRecv.m_nOK == -12 )
    {
        Result_StartGame = 11;
    }
    else if( kRecv.m_nOK == -13 )
    {
        Result_StartGame = 13;
    }
    else if( kRecv.m_nOK == -14 )
    {
        Result_StartGame = 14;
    }
    else if( kRecv.m_nOK == -15 )
    {
        Result_StartGame = 15;
    }
    else if( kRecv.m_nOK == -16 )
    {
        Result_StartGame = 16;
    }
    else
    {
        Result_StartGame = 3;
    }
}

void On_EVENT_END_GAME_BROAD( WPARAM wParam, LPARAM lParam )
{
#if !defined( NO_USE_ADDITION_GUIDE )
    if (g_pkGameOverlayUI->m_pkAddtionGuide)
    {
        if ( g_pkGameOverlayUI->m_pkAddtionGuide->GetState() != KGCAddtionGuide::STATE_GAME_OFF)
            g_pkGameOverlayUI->m_pkAddtionGuide->SetAniState(KGCAddtionGuide::ENDING);
        g_pkGameOverlayUI->m_pkAddtionGuide->SetLockKey(true);
    }
#endif

    if (g_pkGameOverlayUI->m_pkAlerInDungeon)
        g_pkGameOverlayUI->m_pkAlerInDungeon->ToggleRender(false);

    SiKGCMatchManager()->InitMatchInfo();
    SiKGCPartyManager()->EndParty();

    g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );


    KSerializer ks;
    ACK_DESERIALIZE( KEndGameAck );
    SAFE_DELETE( pkBuff );

#if defined( COLLECT_FRAME_DATA )
    g_kGlobalValue.WriteCollectedFrameData();
#endif

#if !defined(__PATH__)    
//////////////////////////////////////////////////////////
//로그 남기는 테스트 코드
    CreateDirectoryA( "./NetworkTest", NULL );

    time_t curTime = GCUTIL_TIME::GetCurTime();

    char szFileName[1024];
    sprintf(szFileName, "NetworkTest\\NetworkTest_%04d%02d%02d_%02d%02d%02d.txt"
        , GCUTIL_TIME::GetYear(curTime), GCUTIL_TIME::GetMonth(curTime), GCUTIL_TIME::GetDay(curTime)
        , GCUTIL_TIME::GetHour(curTime), GCUTIL_TIME::GetMinute(curTime)
        , GCUTIL_TIME::GetSecond(curTime) );


    FILE *fo = NULL;
    std::wstringstream strText;
    std::wstring wstrGameMode; 
    int iMaxPlayer = 0;
    if( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_DUNGEON )
    {
        wstrGameMode = L"Dungeon";
        iMaxPlayer = MAX_DUNGEON_PLAYER_NUM;
    }
    else
    {
        wstrGameMode = L"Match";
        iMaxPlayer = MAX_PLAYER_NUM;
    }

    std::wstring strSendType;
    if( g_eP2PConMode == P2P_TCP_RELAY_ONLY )
        strSendType = L"TR";
    else
        strSendType = L"P2P";

    std::vector<std::wstring> vecPlayers;
    for( int i = 0 ; i < iMaxPlayer; i++ )
    {
        if( g_MyD3D->MyPlayer[i]->m_kUserInfo.bLive )
        {
            if( g_MyD3D->MyPlayer[i]->m_kUserInfo.bHost )
            {
                std::wstring strNickName = g_MyD3D->MyPlayer[i]->m_kUserInfo.strNickName + L"(Host)";
                vecPlayers.push_back(strNickName);
            }
            else if( g_MyD3D->MyPlayer[i]->m_kUserInfo.strNickName == g_kGlobalValue.m_kUserInfo.strNickName )
            {
                std::wstring strNickName = g_MyD3D->MyPlayer[i]->m_kUserInfo.strNickName + L"(Me)";
                vecPlayers.push_back(strNickName);
            }
            else
                vecPlayers.push_back(g_MyD3D->MyPlayer[i]->m_kUserInfo.strNickName);
        }        
    }
    strText << "[   Nation   ] : " << g_kGlobalValue.m_kUserInfo.strNation << "\n"
            << "[    Date    ] : " << GCUTIL_TIME::GetYear(curTime) << "_" << GCUTIL_TIME::GetMonth(curTime) << "_" << GCUTIL_TIME::GetDay(curTime) << "\n"
            << "[    Time    ] : " << GCUTIL_TIME::GetHour(curTime) << ":" << GCUTIL_TIME::GetMinute(curTime) << ":" << GCUTIL_TIME::GetSecond(curTime) << "\n"
            << "[ Game  Mode ] : " << wstrGameMode << "\n"            
            << "[P2P Avg Ping] : " << KSingleton<KncP2P>::GetInstance()->GetAvgPingTime(false) << "\n"
            << "[UR  Avg Ping] : " << KSingleton<KncP2P>::GetInstance()->GetAvgPingTime(true) << "\n"
            << "[TR  Avg Ping] : " << g_kGlobalValue.GetTRAvgPing() << "\n"
            << "[ Send  Type ] : " << strSendType << "\n"
            << "[   Player   ] : ";

    for( int i = 0; i < static_cast<int>(vecPlayers.size()); i++ )
    {
        strText << vecPlayers[i] << "  ";
    }

    fo = fopen(szFileName,"a");
    fwprintf(fo,L"%s",strText.str().c_str());
    fclose(fo);

    // 한데 모은 로그파일
    std::wstringstream strTextAll;
    strTextAll << g_kGlobalValue.m_kUserInfo.strNation << " | "
               << GCUTIL_TIME::GetYear(curTime) << "_" << GCUTIL_TIME::GetMonth(curTime) << "_" << GCUTIL_TIME::GetDay(curTime) << " | "
               << GCUTIL_TIME::GetHour(curTime) << ":" << GCUTIL_TIME::GetMinute(curTime) << ":" << GCUTIL_TIME::GetSecond(curTime) << " | "
               << wstrGameMode << " | "
               << "P2P Avg Ping: " << KSingleton<KncP2P>::GetInstance()->GetAvgPingTime(false) << " | "
               << "UR Avg Ping: " << KSingleton<KncP2P>::GetInstance()->GetAvgPingTime(true) << " | "
               << "TR Avg Ping: " << g_kGlobalValue.GetTRAvgPing() << " | "
               << "Send Type: " << strSendType << " | ";

    for( int i = 0; i < static_cast<int>(vecPlayers.size()); i++ )
    {
        if( i == vecPlayers.size() - 1 )
            strTextAll << vecPlayers[i] << " |\n";
        else
            strTextAll << vecPlayers[i] << ", ";
    }

    FILE *fo2 = NULL;
    fo2 = fopen("NetworkTest\\NewworkTestAll.text","a");
    fwprintf(fo2,L"%s",strTextAll.str().c_str());
    fclose(fo2);

//////////////////////////////////////////////////////////
#endif

    Result_EndGame = 1;

    if( SiKGCWorldMapManager()->IsHeroDungeonMode() && g_pkQuestManager->m_bWin )
    {
        g_kGlobalValue.m_kHeroDungeonInfo.AddHeroDungeonPlayCount( static_cast<int>(SiKGCRoomManager()->GetGameMode()) );
    }

    if ( SiKGCWorldMapManager()->IsHeroDungeonMode() && g_pkQuestManager->m_bWin && !kRecv.m_setHackingUserList.empty() ) {
        if( kRecv.m_setHackingUserList.find( g_kGlobalValue.m_kUserInfo.dwUID ) == kRecv.m_setHackingUserList.end() ) { // 해킹유저가 있는데 그게 내가 아니면 메시지 출력
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK2, g_pkStrLoader->GetString(STR_ID_DUGEON_HACKING_CHECK_PARTNER), L"",
                KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        }
    }

    for ( int i = 0; i < MAX_PLAYER_NUM; ++i )
    {
        if( i < static_cast<int>(kRecv.m_vecIsPlayerWin.size()) )
            g_pGameBoard->m_pStartingMember[i].IsWin        = kRecv.m_vecIsPlayerWin[i];        
    }
    g_MyD3D->MVP                                    = kRecv.m_uiMVP;
    IsBlueWin                                       = kRecv.m_bIsBlueWin;

    // 채팅 이벤트가 작동했는가?
    g_kGlobalValue.m_kChattingEvent.SetSuccessEvent ( kRecv.m_bRewardChatEvent );

    KGCQuestResult_S3 *pQuestRankResult = g_pkGameOverlayUI->GetQuestResultS3();

    g_pkGameOverlayUI->GetQuestResultS3()->SetRewardType(kRecv.m_nRewardType);
	if ( KEndGameAck::SELECT_REWARD == kRecv.m_nRewardType ) {
		g_pkGameOverlayUI->GetQuestResultS3()->GetBonusBoxSelect()->TitleSetting( kRecv.m_bIsSpecialDropCharBox );
	}
     
    if ( g_kGlobalValue.ServerInfo.CheckServerType( ST_GUILD ) ) 
    {
        std::vector< std::pair< DWORD, int > >::iterator vit = kRecv.m_vecGuildBPoint.begin();
        for ( ; vit != kRecv.m_vecGuildBPoint.end() ; vit++ )
        {
            g_pGameBoard->m_vecPlayerDiffGuildPoint.push_back( vit->second ); 
        }
    }

    std::vector<KGameResultOut>::iterator vit;
    for ( vit = kRecv.m_vecGameResult.begin(); vit != kRecv.m_vecGameResult.end(); ++vit )
    {
        for ( int i = 0; i < MAX_PLAYER_NUM; i++ )
        {
            PLAYER* pPlayer = g_MyD3D->MyPlayer[i];
            if(!wcscmp( vit->m_strLogin.c_str(), pPlayer->GetPlayerLoginID()) && pPlayer->m_kUserInfo.bLive)
            {
                if( pPlayer->m_kUserInfo.cCharIndex == -1 )	// 걸리는 일이 있을까??
                    continue;

                if (SiKGCWorldMapManager()->IsHeroDungeonMode() && g_pkQuestManager->m_bWin)
                {
                    pPlayer->m_kUserInfo.m_iPvExp += 1;
                }

                bool bMaxLevelUp = false;

                // 서버에서 주는걸 케릭터 별로 줌
                std::vector< std::pair<char,KCharacterExpInfoOut> >& vecExps = vit->m_vecExps;
                std::vector< std::pair<char,KCharacterExpInfoOut> >::iterator vitExps;
                g_pGameBoard->m_pStartingMember[i].IsLevelUp = false;
                g_pGameBoard->m_pStartingMember[i].IsSPLevelUp = 0;
                
                g_pGameBoard->m_dwContributionPoint = vit->m_dwContPoint;

                for( vitExps = vecExps.begin(); vitExps != vecExps.end(); ++vitExps )
                {
                    std::pair<char,KCharacterExpInfoOut>& pairCharExp = (*vitExps);
                    SCharInfo* pCharInfo = &pPlayer->m_kUserInfo.GetCurrentChar( pairCharExp.first );
                    if( pCharInfo == NULL )
                    {
                        g_kGlobalValue.m_strNullFunc =__FUNCTION__;
                        continue;
                    }

                    // 경험치 
                    g_pGameBoard->Change_How_Exp[i][pairCharExp.first] = pairCharExp.second.m_nBaseExp + pairCharExp.second.m_nTotalRecvExp;
                    if ( g_pGameBoard->m_pStartingMember[i].m_mapStartExp[pairCharExp.first] != pCharInfo->biExp )
                    {
                        START_LOG( cerr, "Exp Err_something wrong!!" );
                        SiGCClientErrorManager()->ErrorCollect( KEventErr::ERR_CLIENTRPT, KClientErr::CE_START_EXP_DIFF_CHAR_EXP );
                    }

                    // 인자 스킬 경험치를 좀 알아볼까? 
                    g_pGameBoard->Change_How_SPExp[i][pairCharExp.first] = pairCharExp.second.m_dwGetSPExp;


                    unsigned char cStartLevel  = Exp_2_Level( pCharInfo->biExp );
                    pCharInfo->biExp = pairCharExp.second.m_biExp;
                    pCharInfo->iLevel = Exp_2_Level(pairCharExp.second.m_biExp);
                    unsigned char cResultLevel = Exp_2_Level( pCharInfo->biExp );

                    // 현재 케릭터만 업했는지 검사
                    if( pPlayer->GetCurrentChar().iCharType == pairCharExp.first )
                    {
                        bool bIsLevelUp = cStartLevel < cResultLevel;
                        int  nLvInc = pairCharExp.second.m_kSkillInfo.m_nLvSPPoint - pairCharExp.second.m_kOldSkillInfo.m_nLvSPPoint;
                        bool bIsSkillUp = ( nLvInc > 0 );

                        g_pGameBoard->m_pStartingMember[i].IsLevelUp = bIsLevelUp;
                        g_pGameBoard->m_pStartingMember[i].IsSPLevelUp = bIsSkillUp;

                        if( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_DUNGEON )
                        {
                            if ( bIsLevelUp ) 
                            {
                                g_pkUIScene->m_pkRoomSceneS6->SetLevelUpPlayer( i );
                            }
                        }
                        else if( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_MATCH )
                        {
                            if( bIsLevelUp ) 
                            {
                                g_pkUIScene->m_pkRoomSceneS6->SetLevelUpPlayer( i );
                            }
                            
                        }

#if defined( NEW_LEVELUP_EFFECT )
                        if( g_pkRoomChatBox ){
                            if( bIsLevelUp ){
                                std::wstring& strLevelUpMessage = g_pkStrLoader->GetReplacedString( STR_ID_LEVELUP_MESSAGE, "l", pPlayer->m_kUserInfo.strNickName );
                                g_pkRoomChatBox->AddChat( strLevelUpMessage, KGCChatManager::CHAT_TYPE_NORMAL );
                            }
#if defined(SKILL_TREE) && !defined(NATION_CHINA)
                            if( bIsSkillUp ){
                                std::wstring& strSkillUpMessage = g_pkStrLoader->GetReplacedString( STR_ID_SKILLUP_MESSAGE, "l", pPlayer->m_kUserInfo.strNickName );
                                g_pkRoomChatBox->AddChat( strSkillUpMessage, KGCChatManager::CHAT_TYPE_NORMAL );
                            }
#endif
                        }
#endif

#if defined( USE_QA_LOG_SYSTEM ) 
                        SiKGCQALogManager()->EndGameLevelUpLog( pPlayer->m_kUserInfo.strNickName, bIsLevelUp, static_cast< int >( cStartLevel ), static_cast< int >( cResultLevel ), 
                                                                bIsSkillUp, pairCharExp.second.m_kOldSkillInfo.m_nLvSPPoint, pairCharExp.second.m_kOldSkillInfo.m_nLvSPPoint );
#endif

                        pPlayer->m_kUserInfo.GetCurrentChar().kSkillInfo = pairCharExp.second.m_kSkillInfo;

                        if( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_DUNGEON && pPlayer->IsLocalPlayer() )
                        {
                            ASSERT( (g_pGameBoard->Change_How_Exp[i][pairCharExp.first] >= 0) && "This Exp is Minus!!!" );

                            //pQuestRankResult->SetExp(pPlayer->m_kUserInfo.dwUID, g_pGameBoard->Change_How_Exp[i][pairCharExp.first] - pairCharExp.second.m_nAdditionnalExp );                            
                            int iClearBonusExp = 0;
                            std::map<int, float>::iterator mit = pairCharExp.second.m_mapExpBoost.find(KCharacterExpInfoOut::BT_CLEAR);
                            if( mit != pairCharExp.second.m_mapExpBoost.end() )
                                iClearBonusExp = static_cast<int>(pairCharExp.second.m_nBaseExp * mit->second);

                            pQuestRankResult->SetExp(pPlayer->m_kUserInfo.dwUID, pairCharExp.second.m_nBaseExp);

                            pQuestRankResult->SetLocalUserStageBonusExp( iClearBonusExp );
                            pQuestRankResult->SetLocalUserBonusExpInfo( pairCharExp.second.m_mapExpBoost );

                            mit = pairCharExp.second.m_mapExpBoost.find(KCharacterExpInfoOut::BT_RANK);
                            if( mit != pairCharExp.second.m_mapExpBoost.end() )
                                pQuestRankResult->SetLocalUserRankBonusExp( (GCEXPTYPE)((pairCharExp.second.m_nBaseExp + pairCharExp.second.m_nAdditionnalExp) * mit->second) );

                            pQuestRankResult->SetTotalExp( (GCEXPTYPE)(pairCharExp.second.m_nBaseExp + pairCharExp.second.m_nTotalRecvExp));

                            TRACE(L"SPEXP = %d  SPLEVEL = %d  SPPRELEVEL = %d \n",pairCharExp.second.m_dwGetSPExp,pairCharExp.second.m_kSkillInfo.m_nLvSPPoint, pairCharExp.second.m_kOldSkillInfo.m_nLvSPPoint);
                            pPlayer->GetCurrentChar().iLevel = cResultLevel;

#if defined( USE_QA_LOG_SYSTEM ) 
                            SiKGCQALogManager()->EndGameExpLog( pPlayer->m_kUserInfo.strNickName, pairCharExp.second.m_nBaseExp, pairCharExp.second.m_nTotalRecvExp, pairCharExp.second.m_nBaseExp + pairCharExp.second.m_nTotalRecvExp, pairCharExp.second.m_dwGetSPExp );
#endif
                        }
                    }

                    bMaxLevelUp = ( (int)cResultLevel > g_kGlobalValue.GetMaxCharLevel() );

                    pPlayer->m_kUserInfo.GetCurrentChar().kELOUserData.m_nELOWin = pairCharExp.second.m_nELOWin;
                    pPlayer->m_kUserInfo.GetCurrentChar().kELOUserData.m_nELOLose = pairCharExp.second.m_nELOLose;
                    pPlayer->m_kUserInfo.GetCurrentChar().kELOUserData.m_nRatingPoint = pairCharExp.second.m_nELORatingPoint;
                    pPlayer->m_kUserInfo.GetCurrentChar().kELOUserData.m_ucGrade = pairCharExp.second.m_ucGrade;
                    pPlayer->m_kUserInfo.GetCurrentChar().kELOUserData.m_nMatchTotalCount = pairCharExp.second.m_nMatchTotalCount;
                    pPlayer->m_kUserInfo.GetCurrentChar().kELOUserData.m_nELOType = pairCharExp.second.m_nELOType;


                    //pairCharExp.second.m_cChatType;
                    //pairCharExp.second.m_nOldSPLv;
                    //pairCharExp.second.m_dwOldSPExp;
                    //pairCharExp.second.m_dwSPExp;
                }

                std::vector< std::pair<char,KPetInfo> >& vecPets = vit->m_vecPetInfo;
                std::vector< std::pair<char,KPetInfo> >::iterator vitPets;
                g_pGameBoard->m_bIsPetLevelUp[i] = false;
                for( vitPets = vecPets.begin(); vitPets != vecPets.end(); ++vitPets )
                {
                    std::pair<char,KPetInfo>& pairCharPet = (*vitPets);
                    SCharInfo* pCharInfo = &pPlayer->m_kUserInfo.GetCurrentChar( pairCharPet.first );
                    if( pCharInfo == NULL )
                    {
                        g_kGlobalValue.m_strNullFunc =__FUNCTION__;
                        continue;
                    }

                    g_pGameBoard->Change_How_Pet_Exp[i][pCharInfo->kPetInfo.m_dwUID] = pairCharPet.second.m_dwEXP - pCharInfo->kPetInfo.m_dwEXP;
                    // 현재 케릭터의 펫만 업했는지 검사
                    if( pairCharPet.first == pPlayer->GetCurrentChar().iCharType )
                        g_pGameBoard->m_bIsPetLevelUp[i] = ( GetPetLevel(pairCharPet.second.m_dwEXP) > GetPetLevel(pCharInfo->kPetInfo.m_dwEXP) );

                    GCITEMUID dwPetUID =  pairCharPet.second.m_dwUID;
                    DWORD dwPetID = pairCharPet.second.m_dwID / 10;
                    GCITEMUID dwPetCostumeUID =  pairCharPet.second.m_kCostume.m_dwUID;
                    GCITEMID dwPetCostumeID = pairCharPet.second.m_kCostume.m_dwID / 10;

                    if( g_MyD3D->IsExistPetInfo( dwPetUID ) && pPlayer->IsLocalPlayer() )
                    {
                        KPetInfo kPet = pairCharPet.second;
                        g_MyD3D->m_mapPetInfo[ dwPetUID ] = kPet;
                        g_MyD3D->m_mapPetInfo[ dwPetUID ].m_dwUID = dwPetUID;
                        g_MyD3D->m_mapPetInfo[ dwPetUID ].m_dwID = dwPetID;
                        g_MyD3D->m_mapPetInfo[ dwPetUID ].m_kCostume.m_dwUID = dwPetCostumeUID;
                        g_MyD3D->m_mapPetInfo[ dwPetUID ].m_kCostume.m_dwID = dwPetCostumeID;

                        pCharInfo->kPetInfo = kPet;
                        pCharInfo->kPetInfo.m_dwUID = dwPetUID;
                        pCharInfo->kPetInfo.m_dwID = dwPetID;
                        pCharInfo->kPetInfo.m_kCostume.m_dwUID = dwPetCostumeUID;
                        pCharInfo->kPetInfo.m_kCostume.m_dwID = dwPetCostumeID;

                        for( int j = 0; j < (int)pCharInfo->kPetInfo.m_vecEquipItem.size(); j++ )
                        {
                            // m_nItemType        0 영구/기간
                            //                    1 수량
                            GCITEMUID dwPetEquipItemUID = pCharInfo->kPetInfo.m_vecEquipItem[j].m_dwUID;
                            DWORD dwPetEquipItemID = pCharInfo->kPetInfo.m_vecEquipItem[j].m_dwID / 10;

                            pCharInfo->kPetInfo.m_vecEquipItem[j].m_dwUID = dwPetEquipItemUID;
                            pCharInfo->kPetInfo.m_vecEquipItem[j].m_dwID = dwPetEquipItemID;
                        }

                        g_MyD3D->m_mapPetInfo[ dwPetUID ].m_vecEquipItem = pCharInfo->kPetInfo.m_vecEquipItem;

                    }
                } // 펫 끝

                if (g_pGameBoard->m_pStartingMember[i].Start_Score != pPlayer->m_kUserInfo.GetCurrentChar().GetCurrentGP() )
                {
                    START_LOG( cerr, "GP Err_something wrong!!" );
                    SiGCClientErrorManager()->ErrorCollect( KEventErr::ERR_CLIENTRPT, KClientErr::CE_START_GP_DIFF_CHAR_GP );
                }
                g_pGameBoard->Change_How_Score[i] = vit->m_nGamePoint - pPlayer->m_kUserInfo.GetCurrentChar().GetCurrentGP();
                ASSERT( (g_pGameBoard->Change_How_Score[i] >= 0) && "This Gp is Minus!!!" );

                if( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_DUNGEON )
                {
                    //pQuestRankResult->SetGp( pPlayer->m_kUserInfo.dwUID, g_pGameBoard->Change_How_Score[i] - vit->m_nStageBonusGP );
                    pQuestRankResult->SetGp( pPlayer->m_kUserInfo.dwUID, vit->m_nBaseGP );
                    int iClearBonusGp = 0;
                    std::map<int, float>::iterator mit = vit->m_mapGpBoost.find(KCharacterExpInfoOut::BT_CLEAR);
                    if( mit != vit->m_mapGpBoost.end() )
                        iClearBonusGp = static_cast<int>( vit->m_nBaseGP * mit->second);
                    pQuestRankResult->SetLocalUserStageBonusGp( iClearBonusGp );

                    mit = vit->m_mapGpBoost.find(KCharacterExpInfoOut::BT_RANK);
                    if( mit != vit->m_mapGpBoost.end() )
                        pQuestRankResult->SetLocalUserRankBonusGp( (GCEXPTYPE)((vit->m_nBaseGP) * mit->second) );

                    pQuestRankResult->SetLocalUserBonusGpInfo(vit->m_mapGpBoost);
                    pQuestRankResult->SetTotalGp( vit->m_nBaseGP + vit->m_nTotalRecvGP );
                }

                pPlayer->m_kUserInfo.GetCurrentChar().SetCurrentGP( vit->m_nGamePoint );

                // 용사의 섬에서 승패
                if( g_kGlobalValue.ServerInfo.CheckServerType( ST_INDIGO ) )
                {
                    pPlayer->m_kUserInfo.iIndigoLose = vit->m_iIndigoLose;
                    pPlayer->m_kUserInfo.iIndigoWin = vit->m_iIndigoWin;
                }
                else
                {
                    WinLoseProcess( &pPlayer->m_kUserInfo, vit->m_vecWin, vit->m_vecLose );
                }

#if defined ( GUILD_RENEW_S4 )
                    pPlayer->m_kUserInfo.iGuildScore = vit->m_dwContPoint;
#endif
                // 랭킹포인트 획득량 계산
                pPlayer->m_kUserInfo.iGetRP = vit->m_iRankingPoint - pPlayer->m_kUserInfo.iRP;
                // 랭킹포인트 업데이트
                pPlayer->m_kUserInfo.iRP = vit->m_iRankingPoint;

                // 몬스터 대전레벨 갱신
                pPlayer->m_kUserInfo.mapStagePlayable = vit->m_mapDifficulty;


                std::map<DWORD,int>::iterator itOBtainCnt = vit->m_mapObtainCount.begin();

                if( i != g_MyD3D->Get_MyPlayer() )
                    continue;

                //*****************************************************=장착정보를 보고 장착시킴=======================*******************
                // 여기서 부터는 내 정보만 계산한다.
                //************************************************************************

                // 보너스 정보 갱신 하고 
                KBonusPointInfo kBonusInfo;
                kBonusInfo.m_nBaseBonus = SiKGCElvis()->GetBaseBonusPoint();
                kBonusInfo.m_nSpecialBonus = SiKGCElvis()->GetSpBonusPoint();
                pPlayer->m_kUserInfo.GetCurrentChar().SetBonusPoint( kBonusInfo );

                pPlayer->UpdateGlobalUserInfo();

                if ( KEndGameAck::RESULT_REWARD == kRecv.m_nRewardType ) {
                    std::wstring tempMsgResultReward = L"#c" + g_kGlobalValue.m_kUserInfo.strNickColor + g_kGlobalValue.m_kUserInfo.strNickName;
                    g_pkGameOverlayUI->GetQuestResultS3()->SetRewardItem(vit->m_mapResultReward, g_kGlobalValue.m_kUserInfo.GetCurrentChar().iCharType, tempMsgResultReward);
                }
                else {
                    g_pkGameOverlayUI->GetQuestResultS3()->GetBonusBoxSelect()->SetKeyNum( vit->m_usSpecialRewardKey );
                }

                g_kGlobalValue.m_kGuildUserInfo.m_ChannelGrade = vit->m_ChannelGrade;

                // 수량 아이템 획득
                std::vector< std::pair< GCITEMUID, int> > vecItemNum;   // 얻은 모든 아이템 저장 <ID, Num>
                std::vector<DWORD> vecReciveRareItem;            // 얻은 레어 아이템 저장 <ID>
                std::map<GCITEMUID,int> mapExist;     // 이미 수량을 계산한 아이템인가 확인용. 
                // - 수량성 아이템리스트에서 중복된 아이템은 배열에서 나중에 등장한놈만 계산하면된다.
                for( int j = (int)vit->m_vecInv.size() -1 ; j >= 0; --j )
                {
                    const GCITEMUID ItemUID = vit->m_vecInv[j].m_ItemUID;

                    if( mapExist.find( ItemUID ) != mapExist.end() )
                        continue;

                    mapExist[ItemUID] = 1;

                    // 수량계산
                    int nDuration = vit->m_vecInv[j].m_nCount;
                    if( nDuration == KItem::UNLIMITED_ITEM ) {
                        vecItemNum.push_back( std::make_pair(ItemUID, 1) );
                    }
                    else {
                        KItem* bufItem = g_pItemMgr->GetInventoryItem( vit->m_vecInv[j].m_ItemUID );
                        int iInvenItemDuration = 0;
                        if(bufItem != NULL)
                        {
                            iInvenItemDuration = bufItem->m_nCount;
                        }


                        GCITEMUID shortcutItemUID;
                        int iShortcutItemDuration = 0;
                        for (int slotIndex = 0; slotIndex < ITEM_SLOT_SIZE; ++slotIndex ){
                            shortcutItemUID = g_MyD3D->GetMyShortCutSlot()->GetItemUID( slotIndex );

                            if ( shortcutItemUID == ItemUID ){
                                iShortcutItemDuration = g_MyD3D->GetMyShortCutSlot()->GetItemQuantity( slotIndex );
                                break;
                            }
                            else
                                iShortcutItemDuration = 0;

                        }

                        vecItemNum.push_back( std::make_pair(ItemUID, nDuration - iInvenItemDuration - iShortcutItemDuration) );
                    }
                }

                itOBtainCnt = vit->m_mapObtainCount.begin();
                for(;itOBtainCnt != vit->m_mapObtainCount.end();itOBtainCnt++)
                {
                    if( g_pItemMgr->CheckRare( itOBtainCnt->first / 10) )
                    {
                        for(int j=0;j<itOBtainCnt->second;++j)
                            vecReciveRareItem.push_back( itOBtainCnt->first / 10 );
                    }
                }

                g_pItemMgr->m_kInventory.AddItemList( vit->m_vecInv );
                if( vecItemNum.empty() != true )
                {
                    //g_pkUIScene->m_pkItemReceiveBox->SetItemVectorReserve( (int)vecItemNum.size() );
                    std::vector< std::pair< GCITEMUID, int > >::iterator vpit;
                    for( vpit = vecItemNum.begin(); vpit != vecItemNum.end(); vpit++ )
                        g_pkUIScene->m_pkItemReceiveBox->AddItem(vpit->first, vpit->second);
                }

                if ( pPlayer->IsLocalPlayer() )
                {
                    // 미션 진행상황 갱신
                    g_kGlobalValue.m_kUserMission.SetUserMissionList( vit->m_vecMissionSlot );
                }

                g_kGlobalValue.m_kUserCollectionMission.SetUserCollectionMissionList( vit->m_vecCollectionSlot );

                g_pStateGame->RemoveEmptyItem();

            }
        }
    }

    // UI갱신
    // WONYWONY
    //g_pkUIScene->m_pkChannelScene->UpdateContestUserInfo();
    //g_pkUIScene->RoomSceneUpdateData();

    IsResultComplete = true;

    if ( g_MyD3D->m_pStateMachine->GetState() == GS_GAME )
    {
        g_pStateGame->GetCurGameModePtr()->OnRecvGameEndPacket();
    }

#if defined(USE_HOST_MIGRATION)
    //게임이 끝날 때 호스트 마이그레이션이 일어난다.
    bool bHostMigration = true;
    for ( int i = 0; i < MAX_DUNGEON_PLAYER_NUM; ++i )
    {
        PLAYER* pPlayer = g_MyD3D->MyPlayer[i];
        if ( pPlayer )
        {
            // 원래 호스트였던 유저가 새로전달받은 호스트uid와 같다면 호스트마이그레이션은 하지 않도록 하겠다.
            if( pPlayer->m_kUserInfo.bHost == true && pPlayer->m_kUserInfo.dwUID == kRecv.m_dwHostUID )                
                bHostMigration = false;
        }
    }

    if( bHostMigration )
    {
        On_HOSTMIGRATE_WithoutLeave(kRecv.m_dwHostUID);

        if ( g_kGlobalValue.m_kUserInfo.bHost )
        {
            //바뀐 방정보를 보낸다.
            KP2P::GetInstance()->Send_ChangeRoomInfoReq( &SiKGCRoomManager()->GetRoomInfo() );
        }
    }    
#endif

    //  상하이 드랍 아이템이 있다.
    if ( kRecv.m_bShDrop )
    {
        g_pkChatManager->AddChatMsg( g_pkStrLoader->GetString( STR_ID_SHANGHAI_INVEN_NOTY ), KGCChatManager::CHAT_TYPE_ALERT );
    }


    // 캐릭터 전용던전이면
    if ( SiKGCWorldMapManager()->IsPrivateDungeon( SiKGCRoomManager()->GetGameMode() ) )
    {
        //  방장이고, 클리어 했으면 자동으로 다음던전 선택하게 해주자.
        if ( g_kGlobalValue.m_kUserInfo.bHost && g_pkQuestManager->m_bWin )
        {
            SiKGCPrivateDungeonManager()->SetNextLevel( true );
        }
    }

	if ( SiKGCFatigueManager()->GetCurrentGameFatigueType() == KGCFatigueManager::YELLOW_TIME )
		g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_FATIGUE_SYSTEM_MESSAGE_7), L"" );
    // 패킷 통계 시스템
    {
        int nTRCount = SiKGCNetworkStatManager()->GetStatModeCount( KGCNetworkStatManager::EM_MODE_TR_PACKET_COUNT );
        int nURCount = SiKGCNetworkStatManager()->GetStatModeCount( KGCNetworkStatManager::EM_MODE_UR_PACKET_COUNT );

        SiKP2P()->Send_UserRelaySendCountReq( SiKGCRoomManager()->GetGameMode(), 
            g_kGlobalValue.m_kUserInfo.GetCurrentCharType(), nTRCount, nURCount );
    }

    g_bCheckTuxedoWeapon = false;
    g_bCheckGuardianWeapon = true;
}

void On_EVENT_CHANNEL_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHANNEL_LIST_ACK );
    SAFE_DELETE( pkBuff );

    if( kRecv.m_nOK == 0 )
    {
        std::vector<KChannelInfo> kChannelList;
        kRecv.m_buffCompChannelList.UnCompress();
        ks.BeginReading( &kRecv.m_buffCompChannelList );
        ks.Get( kChannelList );
        ks.EndReading();

        // 채널리스트 업데이트
        SiKGCChannelManager()->UpdateChannelList( kChannelList );

        // UI 업데이트
        if( g_pkUIScene->m_pkChannelListBox->IsRenderOn() )
            g_pkUIScene->m_pkChannelListBox->SetChannelListBox();
    }

    Result_UserList = kRecv.m_nOK;
}

void On_EVENT_ENTER_CHANNEL_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ENTER_CHANNEL_ACK );
    // kRecv.m_cType        : 채널종류(enum EChannelType)
    // kRecv.m_tOpenTime    : 채널 개장시간
    // kRecv.m_tCloseTime   : 채널 폐장시간
    // kRecv.m_nOK          : 결과값
    //  0// 성공
    // -2// 현재 채널의 정원이 모두 찼습니다.
    // -3// 가입된 길드가 있어야만 길드채널에 입장할 수 있습니다.
    // -4// Indigo입장 불가. 레벨이 낮음
    // -5// Indigo입장 불가. RP가 0임.
    // -6// Indigo입장 불가. 입장권이 없음
    // -7// Indigo입장 불가능. 입장 가능한 시간이 아님
    // -8// 입장 가능한 레벨이 아님
    // -9// 캐릭터가 존재하지 않음.
    //-10// 동일한 유저가 채널안에 있음.
    //-11// 체험 계정으로 용사의 섬 입장 불가.
    //-12// 체험 계정으로 선택 채널 입장 불가.(대전 자유채널)
    //-13// IP 대역이 옳지 않음.
    //-14// 채널 객체를 얻어올 수 없음.

    Result_Connect_GameServer = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0:     // 입장성공
        {
            break;
        }
    case -2:    // 일반채널 정원오버
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
                g_pkStrLoader->GetString(STR_ID_APPMSG_ERR_ENTER_CHANNEL2), L"" );
            break;
        }
    case -3:    // 길드채널 입장불가
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
                g_pkStrLoader->GetString(STR_ID_ENTER_CHANNEL_ERROR2), L"" );
            break;
        }
    case -4:    // 용사채널 입장불가 (입장권)
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
                g_pkStrLoader->GetString(STR_ID_ENTER_CHANNEL_ERROR3), L"" );
            break;
        }
    case -5:    // 용사채널 입장불가 (RP 0)
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
                g_pkStrLoader->GetString(STR_ID_ENTER_CHANNEL_ERROR4), L"" );
            break;
        }
    case -6:    // 용사채널 입장불가 (레벨제한)
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
                g_pkStrLoader->GetString(STR_ID_ENTER_CHANNEL_ERROR5), L"" );
            break;
        }
    case -7:    // 용사채널 입장불가 (입장 시간이 아님)
        {
            // 입장시간이 아니면 금일 입장가능 시간을 보여줘야한다.
            CTime cOpenTime(kRecv.m_tOpenTime + g_kGlobalValue.m_tmServerSyncTime);     // 개장시간
            CTime cCloseTime(kRecv.m_tCloseTime + g_kGlobalValue.m_tmServerSyncTime);   // 폐장시간

            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
                g_pkStrLoader->GetReplacedString( STR_ID_ENTER_CHANNEL_ERROR8, "iiii", cOpenTime.GetHour(),cOpenTime.GetMinute(),cCloseTime.GetHour(),cCloseTime.GetMinute()),
                L"" );
            break;
        }
        //TODO : kkurrung. 아래 오류에 대한 메세지 처리해주삼.
    case -8:    // 입장 가능한 레벨이 아님
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
                g_pkStrLoader->GetString(STR_ID_ENTER_CHANNEL_ERROR9),
                g_pkStrLoader->GetString(STR_ID_INVALID_GRADE_CHANNEL2) );
            break;
        }
    case -9:    // 캐릭터가 존재하지 않음
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
                g_pkStrLoader->GetString(STR_ID_ENTER_CHANNEL_ERROR10), L"" );
            break;
        }
    case -10: // 동일한 유저가 채널안에 있음.
        {
            break;
        }
    case -11: // 체험 계정은 용사의섬 입장 불가
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
                g_pkStrLoader->GetString(STR_ID_EXPID_NOT_ENTER_BRAVE_ISLAND),
                g_pkStrLoader->GetString(STR_ID_EXPID_IMPOSSIBLE) );
            break;
        }
    case -12: // 체험 계정은 자유채널 이동 불가
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
                g_pkStrLoader->GetString(STR_ID_EXPID_NOT_ENTER_FREE_CHANNEL),
                g_pkStrLoader->GetString(STR_ID_EXPID_IMPOSSIBLE) );
            break;
        }
    case -13: // 옳지 않은 IP 대역 입니다._다른 체널로 입장해 주십시오.
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
                g_pkStrLoader->GetString(STR_ID_ENTER_CHANNEL_ERROR11 ), L"" );
            break;
        }
    default:    // DB오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );

            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, 
                g_pkStrLoader->GetString(STR_ID_ENTER_CHANNEL_ERROR6),
                g_pkStrLoader->GetString(STR_ID_ENTER_CHANNEL_ERROR7) + strTemp );
            break;
        }
    }

    SAFE_DELETE( pkBuff );
}

//void On_EVENT_ENTER_GUILD_ZONE_ACK( WPARAM wParam, LPARAM lParam )
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( KEVENT_ENTER_GUILD_ZONE_ACK );
//    if(kRecv.m_bOK)
//    {
//        Result_Connect_Gild = 1;
//
//        g_kGlobalValue.m_kUserInfo.strGuildName = kRecv.m_kGuildInfo.m_strName;
//        MyGildTotalPoint = kRecv.m_kGuildInfo.m_dwPoint;
//        MyGildTotalNum = kRecv.m_kGuildInfo.m_nNumMembers;
//
//        // todo:woosh 일단 주석
//        //g_pkGuildMemo->MemoGuildNotice( kRecv.m_kGuildInfo.m_mapNotice );
//        g_pkGuildMemo->ResetScrollBar();
//
//        g_vecUserInfo.clear();
//        g_vecUserInfo = kRecv.m_vecUserInfo;
//        //g_kGuildInfo = kRecv.m_kGuildInfo;
//
//        g_bGuildInfoUpdate = true;
//    }
//    else
//    {
//        Result_Connect_Gild = 3;
//    }
//    SAFE_DELETE( pkBuff );
//}

//void On_EVENT_GUILD_ZONE_USER_LIST_NOT( WPARAM wParam, LPARAM lParam )
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( std::vector<KUserInfo> );
//    SAFE_DELETE( pkBuff );
//
//    g_vecUserInfo.clear();
//    g_vecUserInfo = kRecv;
//
//    g_bUserListUpdate = true;
//
//    Result_UserList = 1;
//}

//void On_EVENT_GUILD_CHAT_NOT( WPARAM wParam, LPARAM lParam )
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( KPacketNameMsg );
//
//	//WCHAR strTemp[MAX_PATH] = { 0, };
//	//std::wstring wstrName = kRecv.m_strName;
//	//std::wstring wstrMsg = kRecv.m_strMsg;
//
//	//swprintf( strTemp, MAX_PATH, L"%s:%s", wstrName.c_str(), wstrMsg.c_str() );
//	//
//
//	//if ( g_pkChatManager != NULL )
//	//{
//	//	g_pkChatManager->AddChatMsg( strTemp ,wstrName );
//	//}
//
//	if ( g_pkChatManager != NULL )
//	{
//		g_pkChatManager->ChatMsgProc(kRecv.m_strName, kRecv.m_strMsg);
//	}
//    SAFE_DELETE( pkBuff );
//}

//void On_EVENT_GUILD_NOTIFY_MSG_NOT( WPARAM wParam, LPARAM lParam )
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( KPacketNameMsg );
//
//    WCHAR strTemp[MAX_PATH] = { 0, };
//    std::wstring wstrName = kRecv.m_strName;
//    std::wstring wstrMsg = kRecv.m_strMsg;
//    swprintf( strTemp, MAX_PATH, L"%s -> %s", wstrName.c_str(), wstrMsg.c_str() );
//
//    if ( g_pkChatManager != NULL )
//    {
//        g_pkChatManager->AddChatMsg( strTemp, KGCChatManager::CHAT_TYPE_ADMIN, 0xffffffff,false ,wstrName);
//    }
//    SAFE_DELETE( pkBuff );
//}

void On_EVENT_GUILD_EDIT_NOTICE_ACK( WPARAM wParam, LPARAM lParam )
{
    //KSerializer ks;
    //ACK_DESERIALIZE( KEVENT_GUILD_EDIT_NOTICE_ACK );
    //if ( 0 == kRecv.m_cOK )
    //{
    //    g_pkGuildMemo->MemoGuildNotice( kRecv.m_mapNotice );
    //}
    //SAFE_DELETE( pkBuff );
}

void On_EVENT_CHANGE_ROOM_INFO_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KChangeRoomInfo );

    // kRecv.m_nOK
    //  0   성공
    // -1   방정보 변경 실패. 방장 부재
    // -2   방정보 변경 실패. 방장 또는 운영자가 아님
    // -3   방정보 변경 실패. 방 최대 유저 변경이 올바르지 않음.
    // -4   방정보 변경 실패. 닫으려는 슬롯에 유저가 존재함.
    // -5   방정보 변경 실패. 슬롯 변경 정보가 올바르지 않음
    // -6   방정보 변경 실패. 존재하지 않는 변경 정보를 보내옴.
    // -7   방정보 변경 실패. 선택할수 있는 게임 모드가 아님
    // -8   아직 선행 던전을 클리어 하지 못했음.
    // -9   헬모드에서. 헬모드로 방정보 변경 불가
    // -10  영웅던전 방정보 변경불가

    if ( g_MyD3D->m_pStateMachine->IsStateRoom() ||
         g_MyD3D->m_pStateMachine->GetState() == GS_GAME_END )
    {
        if( kRecv.m_nOK == 0 )
        {
            //====================================================================================
            // 2009.03.31 : DD
            // Comment : 모드를 변환하면서 슬롯이 모드닫혀버리는 현상이 있어서 그 상황이 발생하면
            //			 최소 하나의 슬롯은 열어두도록 설정
            //if( SiKGCRoomManager()->GetGameModeCategory() != GC_GMC_DUNGEON )
            //{
            //	bool bAllClose = false;
            //	for( int i = 0 ; i < MAX_NUM_USER_SLOT; i++ )
            //	{
            //		if( kRecv.m_abSlotOpen[i] == false )
            //			bAllClose = true;
            //		else
            //		{
            //			bAllClose = false;
            //			break;
            //		}
            //	}

            //	if( bAllClose )
            //	{
            //		for( int i = 0 ; i < MAX_NUM_USER_SLOT; i++ )
            //		{
            //			if( SiKGCRoomManager()->GetRoomInfo().bOpenSlot[i])
            //			{
            //				kRecv.m_abSlotOpen[i] = true;
            //				break;
            //			}
            //		}
            //	}
            //
            //}

            On_CHANGE_ROOM_INFO( kRecv );

            // 획득가능한 에픽미션이 있는지 확인
            if ( false == SiKGCMissionManager()->CheckEpicMission( SiKGCRoomManager()->GetGameMode() ) )
            {
                // 획득가능한 일반미션 확인
                DWORD dwNormalMissionID = SiKGCMissionManager()->CheckNormalMission( SiKGCRoomManager()->GetGameMode() );
                g_pkUIScene->m_pkRoomSceneS6->m_pkRoomDungeonPanel->SetNormalMission(dwNormalMissionID);
            }
            else
                g_pkUIScene->m_pkRoomSceneS6->m_pkRoomDungeonPanel->SetNormalMission(0);

            SiKGCRoomManager()->GetPrevRoomInfo() = SiKGCRoomManager()->GetRoomInfo();
            SiKGCRoomManager()->GetRoomInfo().m_pairBattlePoint = kRecv.m_pairBattlePoint;
            SiKGCRoomManager()->UpdateRoomUI();
        }
    }

//     if( kRecv.m_nOK != 0 )
//     {
//         g_pkStrLoader->GetReplacedString( STR_ID_CHANGE_ROOM_INFO_ERROR, "i" , kRecv.m_nOK );
//     }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_INVITE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KInviteInfo );
    SAFE_DELETE( pkBuff );

    SiKGCInviteManager()->AddInviteRequest( kRecv );

    //if ( g_pkChatManager != NULL )
    //{
    //    std::wstring wstrPasswd = kRecv.m_strRoomPasswd;
    //    std::wstring wstrHost = kRecv.m_strLogin;
    //    g_pkChatManager->AddInviteMsg( wstrPasswd, kRecv.m_usRoomID, wstrHost );
    //}
}

void On_EVENT_JOIN_ROOM_ACK(KJoinRoomAckInfo& kRecv)
{
#if defined(USE_ONLY_TCP_RELAY_IN_DUNGEON)
    if (SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_DUNGEON)
        KSingleton<KncP2P>::GetInstance()->SetRelayOnly(true);
    else
        KSingleton<KncP2P>::GetInstance()->SetRelayOnly(false);
#endif

    std::wstringstream stm;
    std::wstringstream strm;
    std::wstring strColorKey = L"#cff0000";
    std::wstring strColorKeyEnd = L"#cX";
    stm << strColorKey << g_pkStrLoader->GetString(STR_ID_HERO_DUNGEON_ENTERANCE_ERROR0) << strColorKeyEnd;

    if (kRecv.m_nOK == 0)
    {
        Result_Join = 0;
        SiKGCRoomManager()->SetPlayedHeroDungeon(false);
        EnterRoom(kRecv);
        if (SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_AUTOMATCH)
            KP2P::GetInstance()->Send_Into_Myinfo(g_kGlobalValue.m_kUserInfo.dwUID, g_kGlobalValue.m_kUserInfo.strLogin, GC_RUS_READY);
    }
    else
    {
        SiKGCMatchManager()->InitMatchInfo();
        SiKGCPartyManager()->EndParty();

        g_pkUIMgr->SendEvent(KActionEvent(NULL, KGCUIScene::D3DWE_UPDATE_MATCH));
        g_pkUIMgr->SendEvent(KActionEvent(NULL, KGCUIScene::D3DWE_PRE_ENTER_SCENE));

        switch (kRecv.m_nOK)
        {
            case 1:
            case 5:
            case 6:
            {
                Result_Join = 2;
                break;
            }
            case 12:
            {
                Result_Join = 3;
                break;
            }
            case 13:
            {
                Result_Join = 7;
                break;
            }
            case 15:
            {
                Result_Join = 4;
                break;
            }
            case 10:
            {
                Result_Join = 5;
                break;
            }
            case 18:
            case 19:
            {
                g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, stm.str(),
                    g_pkStrLoader->GetString(STR_ID_HERO_DUNGEON_ENTERANCE_ERROR5), KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
                Result_Join = 100;
                break;
            }
            case 20:
            {
                g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, stm.str(),
                    g_pkStrLoader->GetString(STR_ID_HERO_DUNGEON_ENTERANCE_ERROR1), KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
                Result_Join = 100;
                break;
            }
            case 21:
            {
                strColorKey = L"#cffff00";
                strm << strColorKey << L"\n"
                    << g_pkStrLoader->GetString(STR_ID_HERO_DUNGEON_ENTERANCE_ERROR3)
                    << g_kGlobalValue.m_kHeroDungeonInfo.GetNextEntranceTime(SiKGCRoomManager()->GetGameMode())
                    << strColorKeyEnd;
                g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, stm.str(),
                    g_pkStrLoader->GetString(STR_ID_HERO_DUNGEON_ENTERANCE_ERROR2) + strm.str(), KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
                Result_Join = 100;
                break;
            }
            case 22:
            {
                strColorKey = L"#cffff00";
                strm << strColorKey << L"\n"
                    << g_pkStrLoader->GetString(STR_ID_HERO_DUNGEON_ENTERANCE_ERROR3)
                    << g_kGlobalValue.m_kHeroDungeonInfo.GetNextEntranceTime(SiKGCRoomManager()->GetGameMode())
                    << strColorKeyEnd;
                g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, stm.str(),
                    g_pkStrLoader->GetString(STR_ID_HERO_DUNGEON_ENTERANCE_ERROR6) + strm.str(), KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
                Result_Join = 100;
                break;
            }
            case 23:
            {
                strColorKey = L"#cffff00";
                strm << strColorKey << L"\n"
                    << g_kGlobalValue.m_kHeroDungeonInfo.GetInitTime()
                    << strColorKeyEnd;
                g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, stm.str(),
                    g_pkStrLoader->GetString(STR_ID_HERO_DUNGEON_ENTERANCE_ERROR4) + strm.str(), KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
                Result_Join = 100;
                break;
            }
            case 25:
            {
                g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_HERO_DUNGEON_DIFF_LEVEL),
                    L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
                Result_Join = 100;
                break;
            }

            case 17:
            default:
            {
                Result_Join = 1;
                break;
            }
        }
    }

}

void On_EVENT_JOIN_ROOM_INFO_DIVIDE_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_JOIN_ROOM_INFO_DIVIDE_ACK);
    SAFE_DELETE(pkBuff);

    if (kRecv.m_nCurrentIndex == 0) {
        g_kGlobalValue.ClearJoinRoomUserInfo();
    }

    if (kRecv.m_MaxIndex != 0)
        g_kGlobalValue.AddJoinRoomUserInfo(kRecv.m_nCurrentIndex, kRecv.m_kInDoorUserInfo);

    if (kRecv.m_nCurrentIndex == (kRecv.m_MaxIndex - 1) || kRecv.m_MaxIndex == 0) {
        KJoinRoomAckInfo kInfo;
        kInfo.m_nOK = kRecv.m_nOK;

        if (SiKGCRoomManager()->GetRecvRoomInfo(kInfo.m_kRoomInfo) == false && kRecv.m_nOK == 0) {
            g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_ROOM_INFO_REV_ERROR));
        }
        else {
            SiKGCRoomManager()->SetRecvRoomInfo(false, KRoomInfo());
        }

        std::map<int, KInDoorUserInfo> temp = g_kGlobalValue.GetJoinRoomUserInfo();
        for (std::map<int, KInDoorUserInfo>::iterator mit = temp.begin(); mit != temp.end(); ++mit)
            kInfo.m_veckInDoorUserInfo.push_back(mit->second);

        On_EVENT_JOIN_ROOM_ACK(kInfo);


        std::vector<KInDoorUserInfo> tempBroad = g_kGlobalValue.GetJoinRoomBroadUserInfo();
        if (!tempBroad.empty()) {
            for (std::vector<KInDoorUserInfo>::iterator vit = tempBroad.begin(); vit != tempBroad.end(); ++vit)
                JoinRoomBroadUserProcess(*vit);
        }

    }
    else {
        KP2P::GetInstance()->Send_JoinRoomDivideReq(kRecv.m_MaxIndex, ++kRecv.m_nCurrentIndex);
    }

    SAFE_DELETE(pkBuff);

}

void On_EVENT_JOIN_ROOM_BROAD(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KInDoorUserInfo);
    SAFE_DELETE(pkBuff);

    if (g_MyD3D->m_pStateMachine->GetState() == GS_ROOM || g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO_FROM_ROOM || g_MyD3D->m_pStateMachine->GetState() == GS_CHAR_SELECT_FROM_ROOM) {
        JoinRoomBroadUserProcess(kRecv);
    }
    else {
        g_kGlobalValue.AddJoinRoomBroadUserInfo(kRecv);
    }

    if (g_MyD3D->m_pStateMachine->GetState() == GS_ROOM)
    {
        if (kRecv.m_dwUserUID != g_kGlobalValue.m_kUserInfo.dwUID && g_pkChatManager != NULL && kRecv.m_bIsObserver == false)
        {
            g_pkChatManager->AddSystemMsg(kRecv.m_iPlayerIndex, g_pkStrLoader->GetString(STR_ID_GAMEMSG_REPORT_JOIN));
        }
        g_pkUIScene->RoomSceneUpdateData();
    }

    if (g_MyD3D->m_pStateMachine->GetState() == GS_ROOM || g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO_FROM_ROOM || g_MyD3D->m_pStateMachine->GetState() == GS_CHAR_SELECT_FROM_ROOM) {
        JoinRoomBroadUserProcess(kRecv);
    }
    else {
        g_kGlobalValue.AddJoinRoomBroadUserInfo(kRecv);
    }
}

void On_EVENT_LEAVE_ROOM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    Result_LeaveRoom = kRecv;
    SAFE_DELETE( pkBuff );

    // 오후 10:19 2008-02-28 jemitgge - 차단기능을 위해 방에 들락날락하는 놈들 다 저장 -_-;
    g_kGlobalValue.ReleaseCurrentStateUser();

    // 방에서 만났던 유저들의 랭킹 정보를 날리자
    g_kGlobalValue.m_kRanking.ClearOtherUserRank();

    g_pkUIScene->m_pkRoomSceneS6->InitLevelupEffect();

    for ( int i = 0 ; i < MAX_PLAYER_NUM; i++ )
    {
        g_MyD3D->MyPlayer[i]->m_LoadingState.Init();
    }
    SiKGCCoupleSystem()->ClearCoupleUserInfo();    


    std::vector<DWORD> vecPeer = KSingleton<KncP2P>::GetInstance()->GetPeerUID();
    for( int i = 0; i < (int) vecPeer.size(); ++i ) 
    {
        if( vecPeer[i] == g_kGlobalValue.m_kUserInfo.dwUID ) 
            continue;

        DWORD dwPing = KSingleton<KncP2P>::GetInstance()->GetAvgPingTime( g_MyD3D->MyPlayer[i]->m_kUserInfo.dwUID );
        bool bRelay = KSingleton<KncP2P>::GetInstance()->IsRelay( g_MyD3D->MyPlayer[i]->m_kUserInfo.dwUID );
        SiGCClientErrorManager()->Send_PingTimeReport( bRelay, dwPing ); 
    }

    // P2P 커넥션의 날리자.
    ShutDown( false );

#if defined (PARTY_SYSTEM)
    if ( SiKGCPartyManager()->IsParty() ) {
        SiKGCPartyManager()->LeaveParty();
    }
#endif

    SiKGCMatchManager()->InitMatchInfo();
    SiKGCPartyManager()->EndParty();

    g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );


}

void On_EVENT_CREATE_ROOM_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_CREATE_ROOM_ACK);
    SAFE_DELETE(pkBuff);

    if (SiKGCMatchManager()->GetCurrentState() == KGCMatchManager::MSTATE_COMPLETE_STATE) {
        SiKGCMatchManager()->SetCurrentState(KGCMatchManager::MSTATE_ROOM_STATE);
    }

#if defined(USE_ONLY_TCP_RELAY_IN_DUNGEON)
    if (SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_DUNGEON)
        KSingleton<KncP2P>::GetInstance()->SetRelayOnly(true);
    else
        KSingleton<KncP2P>::GetInstance()->SetRelayOnly(false);
#endif

    Result_Create = kRecv.m_nOK;

    if (kRecv.m_nOK != 0) {
        if (g_MyD3D->m_pStateMachine->GetState() == CT_AUTOMATCH) {
            SiKGCMatchManager()->InitMatchInfo();
            SiKGCPartyManager()->EndParty();

            g_pkUIMgr->SendEvent(KActionEvent(NULL, KGCUIScene::D3DWE_UPDATE_MATCH));
            g_pkUIMgr->SendEvent(KActionEvent(NULL, KGCUIScene::D3DWE_PRE_ENTER_SCENE));

            g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_ERR7));
        }

        return;
    }

    KSingleton<KncP2P>::GetInstance()->ResetConnectQ();

    in_addr in;
    in.S_un.S_addr = kRecv.m_kRoomInfo.m_dwTRelayServerIP;

    KSingleton<KncP2P>::GetInstance()->SetupRelayServer(kRecv.m_kRoomInfo.m_dwRelayServerIP, kRecv.m_kRoomInfo.m_usRelayServerPort);

    SiKP2P()->DisConnectTCPRelay();

    if (!SiKP2P()->m_spTRUserProxy->Connect(inet_ntoa(in), kRecv.m_kRoomInfo.m_usTRelayServerPort, g_kGlobalValue.ServerInfo.dwUserUID))
    {
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_TCP_CONNECT_FAIL), L"");
        SiGCClientErrorManager()->ErrorCollect(KEventErr::ERR_NETWORK, KNetWorkErr::CE_TCP_CONNECT_ERROR);
    }

    SiKP2P()->m_spTRUserProxy->SetPingTimeoutLimit(GetRelayPingLimit());
    SiKP2P()->m_spTRUserProxy->SetPingSendGap(GetRelayPingInterval());

    ((KGCStateLoading*)g_MyD3D->m_pStateMachine->GetStatePtr(GS_GAME_LOADING))->ClearUserConnectState();

#if defined(USE_PING_STATE_UI) && !defined(USE_ONLY_TCP_RELAY) && !defined(USE_P2P_OR_TCP_RELAY)
    KP2P::GetInstance()->Send_PingInfoNot(g_kGlobalValue.GetTRAvgPing());
    KP2P::GetInstance()->Send_RoomMemberPingInfoReq();
#endif

    g_MyD3D->Clear_PlayerData();
    SetSkillInPVPServer(kRecv.m_kInDoorUserInfo);

    On_INSERT_USER(kRecv.m_kInDoorUserInfo);
    g_kGlobalValue.m_kUserInfo = kRecv.m_kInDoorUserInfo;

    for (int i = 0; i < (int)g_kGlobalValue.m_kUserInfo.vecCharInfo.size(); ++i)
    {
        g_pItemMgr->EquipBaseItem(&g_kGlobalValue.m_kUserInfo.vecCharInfo[i]);
    }

    if (g_pkUIScene->m_pkGuildLobbyDlg->IsRenderOn())
        g_pkUIScene->m_pkGuildLobbyDlg->SpeakToActionListener(KActionEvent(g_pkUIScene->m_pkGuildLobbyDlg, KD3DWnd::EWNDMESSAGE_CLOSE));

    SiKGCRoomManager()->UpdateRoomInfo(&kRecv.m_kRoomInfo);
    g_MyD3D->m_pStateMachine->GoRoom((int)kRecv.m_kRoomInfo.m_usRoomID, kRecv.m_kRoomInfo.m_strRoomName, kRecv.m_kRoomInfo.m_strRoomPasswd);
    SiKGCRoomManager()->GetPrevRoomInfo() = SiKGCRoomManager()->GetRoomInfo();

    g_kGlobalValue.m_kUserInfo.bHost = true;

    g_pkUIScene->RoomSceneUpdateData();

    g_pkUIScene->RoomButtonSetStartDelay();

#if defined(USE_PLAY_COUNTRY_GROUP)
    if (g_kGlobalValue.m_kUserInfo.strNation == kRecv.m_kRoomInfo.m_wstrCCode)
        g_pkChatManager->AddChatMsg(g_pkStrLoader->GetString(STR_ID_PLAY_SAME_COUNTRY_MESSAGE1), KGCChatManager::CHAT_TYPE_ADMIN);
    else
        g_pkChatManager->AddChatMsg(g_pkStrLoader->GetString(STR_ID_PLAY_SAME_COUNTRY_MESSAGE2), KGCChatManager::CHAT_TYPE_ADMIN);
#endif

#if defined (PARTY_SYSTEM)
    if (SiKGCPartyManager()->IsParty())
    {
        KP2P::GetInstance()->Send_InvitePartyRoomReq();
        g_pkUIScene->m_pkPartyWnd->OffPartyDlg();
        g_pkUIMgr->SendEvent(KActionEvent(NULL, KGCUIScene::D3DWE_UPDATE_MATCH));
    }
#endif
    SiKGCRoomManager()->SetPlayedHeroDungeon(false);
}

void On_EVENT_USER_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPageInfo );
    SAFE_DELETE( pkBuff );

    if( kRecv.m_nOK == 0 )
    {
        kRecv.m_buffCompList.UnCompress();
        std::vector<KInviteUserInfo> kPacket;
        ks.BeginReading( &kRecv.m_buffCompList );
        ks.Get( kPacket );
        ks.EndReading();
        //길드는 EVENT_GUILD_ZONE_USER_LIST_NOT 이걸로 온다..

        //g_vecUserInfo.clear();
        //g_vecUserInfo = kPacket;
        //if ( SiKGCChannelManager()->CheckChannel( CT_GUILD ) )
        //{
        //    std::sort( g_vecUserInfo.begin(), g_vecUserInfo.end(), KGuildChannelUserInfoLess() );
        //}
        //else
        //{
        //    std::sort( g_vecUserInfo.begin(), g_vecUserInfo.end(), KUserInfoLess() );
        //}

        //Result_UserList=1;

        //g_bUserListUpdate = true;

        SiKGCInviteManager()->SetInviteUserList( kPacket );
        SiKGCInviteManager()->SetMaxPage( kRecv.m_nMaxPage );
        SiKGCInviteManager()->SetCurrentPage( kRecv.m_nCurrentPage );
        if (g_pkUIScene->m_pkInviteRequestBox)
            g_pkUIScene->m_pkInviteRequestBox->UpdateUserList();
    }
    // [2/24/2008] breadceo. ok 가 아닌경우는 비어있는 경우임.
    if (g_pkUIScene->m_pkInviteRequestBox)
        g_pkUIScene->m_pkInviteRequestBox->SetUserListTitle( g_pkStrLoader->GetString( STR_ID_INVITING ) );
}

void On_EVENT_ROOM_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPageInfo );
    SAFE_DELETE( pkBuff );


    // 0 - 정상
    // 1 - 목록이 비어 있습니다.
    // 2 - 해당 카테고리 모드 목록이 없습니다.
    // 3 - 해당 페이지가 존재하지 않습니다. (사용안함)
    // 4 - 목록 전송 주기가 짧습니다.
    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        {
            std::vector<KSimpleRoomInfo> kPacket;
            kRecv.m_buffCompList.UnCompress();
            ks.BeginReading( &kRecv.m_buffCompList );
            ks.Get( kPacket );
            ks.EndReading();

            // 룸 리스트 업데이트..
            SiKGCRoomListManager()->UpdateRoomList( kPacket, kRecv.m_nCurrentPage, kRecv.m_nMaxPage );

            break;
        }
    case 1: // 목록이 비어 있습니다.
    case 2: // 해당 카테고리 모드 목록이 없습니다.
        {
            // 룸 리스트를 지워준다
            SiKGCRoomListManager()->ClearRoomList();
            break;
        }
    }

    g_pkUIMgr->SendEvent( KActionEvent( NULL, KGCUIScene::D3DWE_UPDATE_ROOM_LIST ) );


    // UI 업데이트..
    if( g_MyD3D->m_pStateMachine != NULL )
    {
        SiKGCRoomListManager()->ClearRoomFilter();
        for( int i = 0 ; i < GC_GMC_COUNT ; ++i )
        {
            EChannelType eChannel = (EChannelType)SiKGCChannelManager()->GetCurrentChannelType();
            if( SiKGCRoomManager()->IsAvailableCategory( eChannel, static_cast<EGCGameModeCategory>(i) ) == false )
                continue;

            KGCRoomListManager::EFILTER_CATEGORY eCategory;
            eCategory = SiKGCRoomListManager()->GetFilterEnumFromCategory( (EGCGameModeCategory)i );
            SiKGCRoomListManager()->SetFilterEnable( eCategory );
        }
    }
}


void On_EVENT_CHAT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KChatData );

    //오후 4:44 2008-02-28 jemitgge - 차단당한 아뒤는 띄워주지 않습니다!
    if ( true == g_kGlobalValue.IsBlockUser( kRecv.m_strSenderNick ) ||
         true == SiKFriendShip()->IsBlockFriend( kRecv.m_strSenderNick) )
        return;

    //EVENT_BAD_USER_INFO_NOT의 ENUM 값 UT_CHAT_BLOCK -> -4
    //채팅 금지 유저 일때는 return 하자.
//     if ( g_pkChatManager->GetCharUserGrade() == -4 ) {
//         std::pair< int , time_t> pairTemp = g_pkChatManager->GetRestrictData();
//         //영구 채팅 블럭 유저면
//         if (pairTemp.first == 1)
//         {
//             //영구 블럭 유저 입니다.
//             g_pkChatManager->AddChatMsg( g_pkStrLoader->GetString( STR_CHATTING_RESTRICT_MSG1 ), KGCChatManager::CHAT_TYPE_ALERT );
//             return;
//         }
//         else
//         {
//             std::wstring strMsg;
// 
//             strMsg = g_pkStrLoader->GetReplacedString( STR_CHATTING_RESTRICT_MSG2, "iii", 
//                 GCUTIL_TIME::GetYear(pairTemp.second), GCUTIL_TIME::GetMonth(pairTemp.second), GCUTIL_TIME::GetDay(pairTemp.second) );
//             //채팅블럭 기간이 몇일까지 입니다. 
//             g_pkChatManager->AddChatMsg( strMsg, KGCChatManager::CHAT_TYPE_ALERT );				
//         }
//         return;
//     }

    g_pkChatManager->ChatMsgProc(kRecv.m_strSenderNickColor, kRecv.m_strSenderNick, kRecv.m_strChatMsg, kRecv.m_cChatType, kRecv.m_dwChatColor );

    SAFE_DELETE( pkBuff );
}


void On_EVENT_WHISPER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_WHISPER_ACK );
    /*
    kRecv.m_nOK
    0 : 성공
    1 : 귓속말 전송주기가 짧다.
    2 : 귓속말 대상 유저 이름이 비었거나 메세지가 없음.
    3 : 방송용 서버에서 운영자에게 귓속말을 할 수 없음.
    4 : 대상 유저를 찾을 수 없음.
    5 : 채팅 블럭 유저임.
    */
    std::wstring input;
    if ( kRecv.m_nOK == 0 )
    {
        input = g_pkStrLoader->GetReplacedString( STR_ID_WHISPER_SEND_OK, "l", kRecv.m_kChatData.m_strReceiverNick );

        if ( g_pkChatManager != NULL )
        {
            WCHAR strTemp[MAX_PATH] = { 0, };
            //g_pkChatManager->AddChatMsg( input, KGCChatManager::CHAT_TYPE_RESULT );
            //결과 메시지 보낼 필요 있음?
            swprintf( strTemp, MAX_PATH, L"<<[#c%s%s#cx]:%s", g_kGlobalValue.m_kUserInfo.strNickColor.c_str(), g_kGlobalValue.m_kUserInfo.strNickName.c_str(), kRecv.m_kChatData.m_strChatMsg.c_str() );
            g_pkChatManager->AddChatMsg( strTemp, KGCChatManager::CHAT_TYPE_WHISPER, 0xffffffff, false);

        }
    }
    else if(kRecv.m_nOK == 1)
    {
        input = g_pkStrLoader->GetString( STR_ID_TOO_MANY_CHAT );

        if ( g_pkChatManager != NULL )
        {
            g_pkChatManager->AddChatMsg( input, KGCChatManager::CHAT_TYPE_RESULT );
        }

    }
    else if(kRecv.m_nOK == 2)
    {
        input = g_pkStrLoader->GetString( STR_ID_CHAT_WHISPER_ERR_01 );

        if ( g_pkChatManager != NULL )
        {
            g_pkChatManager->AddChatMsg( input, KGCChatManager::CHAT_TYPE_RESULT );
        }

    }
    else if(kRecv.m_nOK == 3)
    {
        input = g_pkStrLoader->GetString( STR_ID_CHAT_WHISPER_ERR_02 );

        if ( g_pkChatManager != NULL )
        {
            g_pkChatManager->AddChatMsg( input, KGCChatManager::CHAT_TYPE_RESULT );
        }
    }
    else if ( kRecv.m_nOK == 5) {
        std::pair< int , time_t> pairTemp = g_pkChatManager->GetRestrictData();
        //영구 채팅 블럭 유저면
        if (pairTemp.first == 1)
        {
            //영구 블럭 유저 입니다.
            g_pkChatManager->AddChatMsg( g_pkStrLoader->GetString( STR_CHATTING_RESTRICT_MSG1 ), KGCChatManager::CHAT_TYPE_ALERT );
            return;
        }
        else
        {
            std::wstring strMsg;

            strMsg = g_pkStrLoader->GetReplacedString( STR_CHATTING_RESTRICT_MSG2, "iii", 
                GCUTIL_TIME::GetYear(pairTemp.second), GCUTIL_TIME::GetMonth(pairTemp.second), GCUTIL_TIME::GetDay(pairTemp.second) );
            //채팅블럭 기간이 몇일까지 입니다. 
            g_pkChatManager->AddChatMsg( strMsg, KGCChatManager::CHAT_TYPE_ALERT );
            return;
        }
    }
    else
    {
        input = kRecv.m_kChatData.m_strReceiverNick;
        input += g_pkStrLoader->GetString( STR_ID_WHISPER_NOT_EXIST );

        if ( g_pkChatManager != NULL )
        {
            g_pkChatManager->AddChatMsg( input, KGCChatManager::CHAT_TYPE_RESULT );
        }
    }
    SAFE_DELETE( pkBuff );
}

void On_EVENT_BUY_FOR_GP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BUY_FOR_GP_ACK );
    //KPacketBuyItemForGPAck* pkNot;
    //pkNot=(KPacketBuyItemForGPAck*)lParam;
    switch(kRecv.m_nOK)
    {
    case 0:
        {
            g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nUseGP );
            g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nUseGP );
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItems, true );
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();


            if ( g_pkUIScene->m_pkCoordiComposeDlg && g_pkUIScene->m_pkCoordiComposeDlg->IsWndState( KD3DWnd::D3DWS_ENABLED ) )
                g_pkUIScene->m_pkCoordiComposeDlg->UpdateItemCount();

			 if ( g_pkUIScene->m_pkCoordiUpgradeDlg && g_pkUIScene->m_pkCoordiUpgradeDlg->IsWndState( KD3DWnd::D3DWS_ENABLED ) )
                g_pkUIScene->m_pkCoordiUpgradeDlg->UpdateItemCount();	

            //  GP로 슬롯구입은 사내에서만 동작한다.
            if( g_MyD3D->m_pStateMachine->GetState() == GS_CHAR_SELECT )
            {
                g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_BUT_ADD_SLOT_ITEM ) );
            }

#if !defined (__PATH__)
            g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_BUY_CASH_ITEM ) );
#endif
            Result_Buy=1;
            break;
        }
    case 4:
        {
            Result_Buy = 4;
            break;
        }
    case -98: // 작업중인 패킷
        {
            Result_Buy=-98;
            break;
        }
    default:
        START_LOG( cout, (int)kRecv.m_nOK );
        //  [12/3/2003]
        //m_cOK: 0(성공)
        // 일반상품 구입 경우:
        //      -1(Buyerlogin이 존재 하지 않음)
        //      -2(해당 상품이 존재 하지 않음)
        //      -3(cash 상품은 GP로 구입할 수 없음)
        //      -4(inventory가 full임)
        //      -5(gp가 부족함)
        //      -6(pattern 상품인 경우 구입 할 수 없음, up_buy_pattern sp 참조)
        //      -7(Ownerlogin이 존재 하지 않음)
        //      -8(현재 판매 되고 있는 상품이 아님)
        //      -9(알수 없는 error)
        //      -10(상품의 정보가 이상함(IsSubSetGoods = 0 and SetGoodsNum = -1)
        // 패턴 구입 경우:
        //       -1(Buyerlogin이 존재 하지 않음)
        //       -2(해당 상품이 존재 하지 않음)
        //       -3(cash 상품은 GP로 구입할 수 없음)
        //       -4(inventory가 full임)
        //       -5(gp가 부족함)
        //       -6(iGoodsUID의 상품을 가지고 있지 않음)
        //       -7(Ownerlogin이 존재 하지 않음)
        //       -8(현재 판매 되고 있는 상품이 아님)
        //       -9(pattern 상품이 아님)
        //       -10(알수 없는 error)
        //       -11(iGoodsUID의 상품과 구입하고자 하는 pattern 상품의 Base 상품이 다름)

        Result_Buy=3;
        break;
    }
    SAFE_DELETE( pkBuff );
}

void On_EVENT_BUY_FOR_GEM_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_BUY_FOR_GEM_ACK);

    if (0 == kRecv.m_nOK)
    {
        g_pItemMgr->m_kInventory.AddItem(kRecv.m_moneyItem, true);
        g_pItemMgr->m_kInventory.AddItemList(kRecv.m_vecItem, true);
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();

        Result_Buy = 1;
    }
    else if (kRecv.m_nOK == -98)
    {
        Result_Buy = -98;
    }
    else
    {
        Result_Buy = 3;
    }
    SAFE_DELETE(pkBuff);
}

void On_EVENT_BUY_FOR_CRYSTAL_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_BUY_FOR_CRYSTAL_ACK);
    if (0 == kRecv.m_nOK)
    {
        g_pItemMgr->m_kInventory.AddItem(kRecv.m_moneyItem, true);
        g_pItemMgr->m_kInventory.AddItemList(kRecv.m_vecItem, true);
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();

        Result_Buy = 1;
    }
    else if (kRecv.m_nOK == -98)
    {
        Result_Buy = -98;
    }
    else
    {
        Result_Buy = 3;
    }
    SAFE_DELETE(pkBuff);
}

void On_EVENT_STRONG_LEVELUP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_STRONG_LEVELUP_ACK );
    SAFE_DELETE( pkBuff );

    //3    제자리
    //2    깨짐,
    //1    하락,
    //0    성공,
    //-1   강화 할수 없음_NextLevel또는NextGoodsID 오류
    //-2   ItemKind값이 잘못 되었음
    //-3   해당 캐릭터 정보가 존재하지 않음
    //-4   사용 되는 젬 개수 정보가 없음
    //-5   젬이 부족합니다
    //-6   강화 쿼리 실패
    //-7   강화 요청시 어시스트 ItemID틀림.
    //-8   강화 어시스트 아이템이 없음
    //-99  알수 없는 오류
    //-98    작업중인 패킷

    if( kRecv.m_nOK >= 0 ) {
        g_pItemMgr->m_kInventory.RemoveItemList( kRecv.m_vecDelItem );
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecUpdateItem, true );

        Result_Buy = 0;
    }

    //인벤토리 정보가 바꼈으면 인벤토리를 업데이트 해 주어야죠~
    // 신UI에서는 요기서 갱신 해주고
    // 구UI에서는 따로 갱신해 주는 부분이 있다
    g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    g_pkUIScene->m_pkMyInfoScene->UpdateData();

    g_pkUIScene->m_pkNewNecklaceEnchantDlg->SetResult( kRecv.m_nOK );
}
void On_EVENT_KICK_USER_BY_ADMIN_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPacketAck );
    //KPacketKickUserAck* pkNot;
    //pkNot=(KPacketKickUserAck*)lParam;
    SAFE_DELETE( pkBuff );
}

void On_EVENT_CHANGE_USER_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPacketAck );
    //KPacketChangeUserDBInfoAck* pkNot;
    //pkNot=(KPacketChangeUserDBInfoAck*)lParam;
    SAFE_DELETE( pkBuff );
}

void On_EVENT_CLOSE_CONNECTION_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CLOSE_CONNECTION_NOT );

    if( (kRecv.m_nCloseType == KEVENT_CLOSE_CONNECTION_NOT::CCT_NORMAL) && SiKP2P()->IsConnectedToGameServer() )
    {
        return;
    }


    //        CCT_NORMAL        0,         // 정상 종료
    //        CCT_NPGG          1,           // NProtect
    //        CCT_AHNHS         2,          // Hack Shield
    //        CCT_DUPLICATION   3,    // 인증시 이중 접속
    //        CCT_PT_CHECKSUM   4,    // 프로텍티드 테이블 체크섬
    //        5,    // 해킹 감지
    //        6,          // X-Trap

    if( g_MyD3D->m_bActive )
    {
        switch( kRecv.m_nCloseType )
        {
        case KEVENT_CLOSE_CONNECTION_NOT::CCT_PT_CHECKSUM:
            {
				ShutDown( false );

				KSingleton<KncP2P>::GetInstance()->SetServerDown( true );
                std::wstringstream stm;
                stm << L"On_EVENT_CLOSE_CONNECTION_NOT::kRecv.m_nCloseType = " << kRecv.m_nCloseType;
                ExitWithHackAlert( stm.str() );
            }
            break;
        case KEVENT_CLOSE_CONNECTION_NOT::CCT_DUPLICATION:
        case KEVENT_CLOSE_CONNECTION_NOT::CCT_DUPLICATION_CYOU:
#if defined(NATION_CHINA)
			::MessageBoxW( g_MyD3D->Get_hWnd(), g_pkStrLoader->GetString(STR_ID_CLOSE_CLIENT_DOUBLE_CONNECT).c_str(), L"", MB_OK );
			ShutDown( false );

			KSingleton<KncP2P>::GetInstance()->SetServerDown( true );

#else
			ShutDown( false );

			KSingleton<KncP2P>::GetInstance()->SetServerDown( true );
			g_MyD3D->ExitWithMsgDlg( kRecv.m_strMessage.c_str(), g_pkStrLoader->GetString( STR_ID_CLOSE_CLIENT_DOUBLE_CONNECT ).c_str() );
#endif
            break;
        case KEVENT_CLOSE_CONNECTION_NOT::CCT_DETECT_HACK:
			ShutDown( false );

			KSingleton<KncP2P>::GetInstance()->SetServerDown( true );
           g_MyD3D->ExitWithMsgDlg( kRecv.m_strMessage.c_str(), g_pkStrLoader->GetString( STR_ID_NPGG_CALLBACK_ERROR04 ).c_str() );
            break;
        case KEVENT_CLOSE_CONNECTION_NOT::CCT_NORMAL:
			::MessageBoxW( g_MyD3D->Get_hWnd(), g_pkStrLoader->GetString(STR_CN_DISCONNECTED_SERVER).c_str(), L"", MB_OK );

			ShutDown( false );

			KSingleton<KncP2P>::GetInstance()->SetServerDown( true );
            g_MyD3D->m_pStateMachine->GoExitGame(KGCGlobal::EXIT_GAME_STATE_DISCONNECT, kRecv.m_nSocketErr );

            break;
        }
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_RP_CHANGED_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;

    ACK_DESERIALIZE( int );

    // 방에서 나갈때 깎인 RP를 전송받습니다.
    g_kGlobalValue.m_kUserInfo.iGetRP = kRecv - g_kGlobalValue.m_kUserInfo.iRP;
    g_kGlobalValue.m_kUserInfo.iRP = kRecv;

    // 방에 접속되어 있을 경우 갱신
    int iIndex = g_MyD3D->Get_MyPlayer();
    if( iIndex != 7 )
    {
        g_MyD3D->MyPlayer[iIndex]->m_kUserInfo.iGetRP = g_kGlobalValue.m_kUserInfo.iGetRP;
        g_MyD3D->MyPlayer[iIndex]->m_kUserInfo.iRP = kRecv;
    }

    // UI갱신
    // WONYWONY
    //g_pkUIScene->m_pkChannelScene->UpdateContestUserInfo();

    SAFE_DELETE( pkBuff );
}

void On_EVENT_P2P_RELAY_ACK( LPARAM lParam )
{
    static BYTE pUnCompressBuffer[ MAX_COMPRESS_BUFFER * 32 ] = {0,};
    static ULONG ulUnCompressLength = 0;

    KSerBuffer* kPacket = (KSerBuffer*)lParam;

    memset( pUnCompressBuffer, 0, sizeof(BYTE)*MAX_COMPRESS_BUFFER*32 );
    ulUnCompressLength = MAX_COMPRESS_BUFFER * 32;

    DWORD dwUID = 0;

    memcpy( &dwUID, (BYTE*)kPacket->GetData() + sizeof(DWORD), sizeof(dwUID) );

    if ( Z_OK != uncompress( pUnCompressBuffer, &ulUnCompressLength, (BYTE*)kPacket->GetData() + sizeof(DWORD)*2, (ULONG)kPacket->GetLength() - sizeof(DWORD) ) )
        return;

    KGC_PACKET_HEADER* pPacketHeader = (KGC_PACKET_HEADER*)pUnCompressBuffer;

    KGCPC_VALUE( "TCP Rcv", ulUnCompressLength );
    if( g_MyD3D->m_pStateMachine->GetState() == GS_SQUARE )
    {
        SquarePacketProc( pPacketHeader->Type, (BYTE*)pPacketHeader, dwUID, (DWORD)ulUnCompressLength );
    }
    else
    {
        if ( KSingleton<KncP2P>::GetInstance()->IsIn( dwUID ) == true )
        {
            P2PPacketProc( pPacketHeader->Type, (BYTE*)pPacketHeader, dwUID, (DWORD)ulUnCompressLength );
        }
    }
    SAFE_DELETE( kPacket );
}

void On_ENU_SERVER_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<KServerInfo> );
    SAFE_DELETE( pkBuff );

    g_kGlobalValue.ServerList.clear();

    for( int i = 0; i < (int)kRecv.size(); ++i )
    {
        g_kGlobalValue.ServerList.push_back( kRecv[i] );
    }

    if( g_MyD3D->m_pStateMachine != NULL )
        if( g_MyD3D->m_pStateMachine->GetState() == GS_SERVER )
            g_pkUIScene->m_pkServerScene->UpdateServerList();

    g_MyD3D->AutoConnectToGameServer();

    // KServerInfo::m_prLvRange 여기에 레벨 범위가 들어 있습니다.
}

void On_ENU_VERIFY_ACCOUNT_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KENU_VERIFY_ACCOUNT_ACK);

    g_kGlobalValue.m_kUserInfo.Init();

    Result_Connect_LoginServer = kRecv.m_nOK;
    g_kGlobalValue.m_kUserInfo.Init();

    if (kRecv.m_nOK == 0 || kRecv.m_nOK == NetError::ERR_NUSER_VERIFY_37)
    {
        g_kGlobalValue.m_dwAuthTick = kRecv.m_dwAuthTick;
        g_kGlobalValue.m_kLoginInfo.bNewUser = kRecv.m_bNewUser;
        g_kGlobalValue.m_kUserInfo.strLogin = kRecv.m_strLogin;
        g_kGlobalValue.m_kLoginInfo.strID = GCUTIL_STR::GCStrWideToChar(kRecv.m_strLogin.c_str());
        g_kGlobalValue.m_bExpAccount = kRecv.m_bExpAccount;
        g_kGlobalValue.m_strGuildMarkURL = kRecv.m_strMarkServerURL;
        g_kGlobalValue.m_kLoginInfo.nFunBoxBonus = kRecv.m_nFunBoxBonus;
        g_kGlobalValue.m_kLoginInfo.nLinBonus = kRecv.m_nLinBonus;
        g_kGlobalValue.m_dwChannelType = kRecv.m_dwChannellingType;
    }
    else if (kRecv.m_nOK == 15)
    {

        for (int i = 0; i < (int)kRecv.m_vecScriptCheckResult.size(); i++)
        {
            if (kRecv.m_vecScriptCheckResult[i].second)
            {
                std::map< std::wstring, std::string>::iterator mit = g_kGlobalValue.m_mapModifiedFile.find(kRecv.m_vecScriptCheckResult[i].first);
                g_kGlobalValue.m_vecDeleteFileLIst.push_back(mit->second);
            }
        }
    }
    else if (kRecv.m_nOK == NetError::ERR_NUSER_VERIFY_31) {
        SiKGCFatigueManager()->SetConnectType(KGCFatigueManager::FUT_MULTI_CONNECT);
    }

#if defined(NATION_KOREA)
    else if (kRecv.m_nOK == 10)
    {
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_CERTIFICATION_ERROR07),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
    }
    else if (kRecv.m_nOK == 16)
    {
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_CERTIFICATION_ERROR01),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
    }
    else if (kRecv.m_nOK == 24)
    {
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_CERTIFICATION_ERROR02),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
    }
    else if (kRecv.m_nOK == 25)
    {
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_CERTIFICATION_ERROR03),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
    }
    else if (kRecv.m_nOK == 26)
    {
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_CERTIFICATION_ERROR04),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
    }
    else if (kRecv.m_nOK == 27)
    {
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_CERTIFICATION_ERROR05),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
    }
    else if (kRecv.m_nOK == 28)
    {
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_CERTIFICATION_ERROR06),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
    }
    else if (kRecv.m_nOK == 29)
    {
        std::wstring strMsg = g_pkStrLoader->GetString(STR_ID_SHUTDOWN_MSG_3);
        strMsg += g_pkStrLoader->GetString(STR_ID_SHUTDOWN_MSG_4);

        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, strMsg,
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
    }
#endif
    else if (kRecv.m_nOK == 30)
    {
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_WRONG_PASSWORD_LIMIT_EXCEED));
    }
#if defined(NATION_USA) || defined(NATION_EU)
    else {
        g_kGlobalValue.m_wstrFailString = kRecv.m_wstrFailString;

        if (!g_kGlobalValue.m_wstrFailString.empty())
            g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_kGlobalValue.m_wstrFailString,
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
    }
#endif
#if defined(PING_STATISTICS)
    g_kGlobalValue.m_kUserInfo.strNation = GCUTIL_STR::GCStrCharToWide(kRecv.m_strNationCode.c_str());
#endif


    g_kGlobalValue.m_kGuildUserInfo = kRecv.m_kGuildUserInfo;
    g_kGlobalValue.m_kGuildInfo = kRecv.m_kGuildInfo;

    g_kGlobalValue.m_mapNGuildUserInfo.clear();

    g_MyD3D->m_fileDownloadManager.SetDownLoadURL(FileDownloadManager::EDOWN_GUILD_MARK, kRecv.m_strMarkServerURL);

    std::vector< KGuildUserInfo >::iterator vit = g_kGlobalValue.m_vecGuildUserList.begin();
    while ((vit = std::find_if(vit, g_kGlobalValue.m_vecGuildUserList.end(), boost::bind(&KGuildUserInfo::m_ucUserLevel, _1) == 5))
        != g_kGlobalValue.m_vecGuildUserList.end())
    {
        g_kGlobalValue.m_vecOnlineGuildUserList.push_back((*vit));
        ++vit;
    }

    std::map<char, __int64>::iterator mit = kRecv.m_mapCharExp.begin();
    while (mit != kRecv.m_mapCharExp.end())
    {
        SCharInfo info;
        info.iCharType = mit->first;
        info.biExp = mit->second;
        info.iLevel = Exp_2_Level(mit->second);
        g_kGlobalValue.m_kUserInfo.AddChar(info);
        mit++;
    }
    kRecv.m_mapCharExp;

    KP2P::GetInstance()->Send_GuildeBookListReq();
    KP2P::GetInstance()->Send_PingConfigReq();

    g_kGlobalValue.m_bUseLoadCheckInServer = kRecv.m_bUseLoadCheckInServer;
    g_kGlobalValue.m_fFakeCCU = kRecv.m_fFakeCCU;

#ifdef __ORIGIN_DEV__
    g_kGlobalValue.LoadMantisProjectList();
#else
    if (g_kGlobalValue.m_kUserInfo.eGCUserLevel == USERLEVEL_ADMIN) {
        g_kGlobalValue.LoadMantisProjectList();
    }
#endif
    g_kGlobalValue.LoadNecklaceScript();

    SiKGCVirtualDepotManager()->SetFirstLogOn(true);

    SAFE_DELETE(pkBuff);
}

void On_ENU_CHANNEL_NEWS_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KENU_CHANNEL_NEWS_NOT );
    //typedef std::vector< std::pair< int, std::wstring > > KENU_CHANNEL_NEWS_NOT; // 채널 뉴스

    KENU_CHANNEL_NEWS_NOT::iterator vit;

    g_kGlobalValue.ServerbarEventStringClear();
    for( vit = kRecv.begin() ; vit != kRecv.end() ; ++vit )
    {
        switch( (*vit).first )
        {
        case -1:
            g_kGlobalValue.SetServerbarEventTitle( (*vit).second );
            break;
        case -2:
            g_kGlobalValue.SetServerbarEventSubtitle(  (*vit).second );
            break;
        case -3:
            g_kGlobalValue.SetServerbarEventDesc(  (*vit).second );
            break;
        }
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_NPGG_AUTH_REQ( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSerBuffer );
    SAFE_DELETE( pkBuff );
    //#ifdef NO_GAMEGUARD
    //    return;
    //#else
    //    GG_AUTH_DATA sData;
    //    if( kRecv.Read( ( void* )&sData, sizeof( GG_AUTH_DATA ) ) )
    //    {
    //        g_CNPGameLib.Auth2( &sData );
    //    }
    //#endif // NO_GAMEGUARD
}


void On_EVENT_USE_CHANGE_NICKNAME_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_USE_CHANGE_NICKNAME_ACK );
    Result_ReportNickName = kRecv.m_nOK;

    SAFE_DELETE( pkBuff );
}

void On_EVENT_USE_CHANGE_NICKCOLOR_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_USE_CHANGE_NICKCOLOR_ACK);
    Result_ReportNickColor = kRecv.m_nOK;

    SAFE_DELETE(pkBuff);
}

void On_ENU_WAIT_TIME_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    KSerBuffer* pkBuff = (KSerBuffer*)lParam;
    DWORD kRecv;
    ks.BeginReading( pkBuff );
    ks.Get( kRecv );
    ks.EndReading();

    //이녀석이 서버에서 보내준 로긴서버 대기시간입니다. millisecond
    Wait_Time_LoginServer = kRecv;
    START_LOG( cout, L"Wait Time AT ENU~NOT") << BUILD_LOG( Wait_Time_LoginServer );


    SAFE_DELETE( pkBuff );
    START_LOG( clog, L"On_ENU_WAIT_TIME_NOT - End");
}

//void On_EVENT_AHNHS_GUID_REQ( WPARAM wParam, LPARAM lParam )
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( KSerBuffer );
//
//    KSafeArray<BYTE,SIZEOF_GUIDREQMSG> abyteGUIDReq;
//    KSafeArray<BYTE,SIZEOF_GUIDACKMSG> abyteGUIDAck;
//
//    if( kRecv.Read( abyteGUIDReq.as_array() , SIZEOF_GUIDREQMSG ) )
//    {
//        if( HS_MakeGuidAckMsg( abyteGUIDReq.as_array(), abyteGUIDAck.as_array() ) )
//        {
//            KSerBuffer buff;
//            buff.Write( abyteGUIDAck.as_array(), SIZEOF_GUIDACKMSG );
//            SiKP2P()->m_pkUserProxy->SendPacket( KUserEvent::EVENT_AHNHS_GUID_ACK, buff );
//        }
//        else
//        {
//            ::PostMessage( g_MyD3D->Get_hWnd(), WM_CLOSE, 0, 0 );
//        }
//    }
//
//    SAFE_DELETE( pkBuff );
//}

void On_EVENT_AHNHS_AUTH_REQ( WPARAM wParam, LPARAM lParam )
{
#ifndef NO_HACKSHIELD
    KSerializer ks;
    ACK_DESERIALIZE( KSerBuffer );
    SAFE_DELETE( pkBuff );

    AHNHS_TRANS_BUFFER stRequestBuf;
    kRecv.Reset(); // offset 초기화.
    if( kRecv.Read( &stRequestBuf, sizeof( stRequestBuf ) ) )
    {
        //위 데이터를 기반으로 응답 패킷을 만들면 됨..
        AHNHS_TRANS_BUFFER stResponseBuf;
        int ulRet = _AhnHS_MakeResponse(stRequestBuf.byBuffer,stRequestBuf.nLength,&stResponseBuf);

        if (ulRet!=ERROR_SUCCESS)
        {
            ExitWithNPHSErrorMsg( g_pkStrLoader->GetString( STR_ID_ERROR_MESSAGE_TITLE ).c_str(), 
                ulRet,
                g_pkStrLoader->GetString( STR_ID_AHNHS_FUNCTION_ERROR35 ).c_str(), 
                g_pkStrLoader->GetString( STR_ID_AHNHS_TERMINATE_PROGRAM ).c_str());
            ::PostMessage( g_MyD3D->Get_hWnd(), WM_CLOSE, 0, 0 );
        }

        KSerBuffer buff;
        buff.Write( &stResponseBuf, sizeof(stResponseBuf) );
        if( SiKP2P()->m_pkUserProxy != NULL && SiKP2P()->m_pkUserProxy->IsConnected() )
        {
            SiKP2P()->m_pkUserProxy->SendPacket( KUserEvent::EVENT_AHNHS_AUTH_ACK, buff, true, true );
        }
        else
        {
            // 서버와 연결이 않되어 있음..
            ExitWithNPHSErrorMsg( g_pkStrLoader->GetString( STR_ID_ERROR_MESSAGE_TITLE ).c_str(), 
                NULL,
                g_pkStrLoader->GetString( STR_ID_AHNHS_FUNCTION_ERROR03 ).c_str(), 
                g_pkStrLoader->GetString( STR_ID_AHNHS_TERMINATE_PROGRAM ).c_str());
            ::PostMessage( g_MyD3D->Get_hWnd(), WM_CLOSE, 0, 0 );
        }

    }
    else
    {
        // 서버로 부터 받아온 정보가 잘못되었음..
        // 아마도 곧 튕기게 되겠죠..
        ExitWithNPHSErrorMsg( g_pkStrLoader->GetString( STR_ID_ERROR_MESSAGE_TITLE ).c_str(), 
            NULL,
            g_pkStrLoader->GetString( STR_ID_AHNHS_FUNCTION_ERROR36 ).c_str(), 
            g_pkStrLoader->GetString( STR_ID_AHNHS_TERMINATE_PROGRAM ).c_str());
        ::PostMessage( g_MyD3D->Get_hWnd(), WM_CLOSE, 0, 0 );
    }
#endif
}



void On_EVENT_REGIST_MISSION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_REGIST_MISSION_ACK );

    Result_Kid_Gift = kRecv.m_nOK;
    //0;  // 성공
    //1;  // 유저가 존재하지 않음
    //2;  // 현재 등록된 미션임
    //3;  // 이미 완료한 미션임
    //4;  // 미션 슬롯이 꽉찼음
    //5;  // 등록된 미션과 연관된 미션이므로 등록불가.
    //6;  // 미션 아이템이 아닌데 미션으로 등록하려고 했음
    //7;  // 미션 정보 가져오기 실패.
    //8;  // 캐릭터가 존재하지 않음
    //9;  // 전직 상태가 맞지 않음.
    //10; // 캐릭터 레벨 제한을 만족하지 못함
    //11; // 존재하는 미션이 아님.
    //12; // Count SubMission 목록을 가져 오는중 실패.
    //13; // 등록시 DB 오류.
    //14; // 아이템을 보유하고 있지 않음.
    //-99; // 알수없는 오류


    //kRecv.m_dwGoodsID ; //미션 카드 아이템 ID
    //kRecv.m_dwGoodsUID; //미션 카드 아이템 UID
    //kRecv.m_kMissionInfo; //미션 정보 구조체
    //kRecv.m_nOK;

    if( kRecv.m_nOK == 0 )
    {
        //g_pMissionManager->AddUserMission( kRecv.m_dwGoodsID );
        //미션 카드 아이템 UID를 찾아서 삭제해줌
        g_kGlobalValue.m_kUserMission.AddMission( kRecv.m_kMissiondata.m_dwMissionID );
        g_kGlobalValue.m_kUserCollectionMission.AddCollectionMission( kRecv.m_kMissiondata.m_dwMissionID );
        std::vector<GCITEMUID> vecDecItemUID;
        g_pItemMgr->DecDurationItem(  kRecv.m_ItemUID, &vecDecItemUID );
        g_kGlobalValue.m_kUserMission.RefreshUserMission();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->m_pkMissionUI_S4->RefreshUI();

        //  룸안이면
        if ( g_MyD3D->m_pStateMachine->IsStateRoom() ) 
        {
            g_pkUIScene->m_pkRoomSceneS6->UpdateMissionData();
        }
    }
    else if( kRecv.m_nOK == -98 )
    {
        Result_Buy = -98;
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_COMPLETE_MISSION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_COMPLETE_MISSION_ACK );

    //kRecv.m_dwMissionID;
    //kRecv.m_iBlessing;
    //kRecv.m_iExp;
    //kRecv.m_iGP;
    //kRecv.m_nOK;
    //kRecv.m_vecDurationItemInv; //수량 아이템 보상(덮어쓰면 됨)
    //kRecv.m_vecInv;//일반 아이템 보상(추가)

    //0; // 성공
    //1; // 유저가 존재하지 않음
    //2; // 미션 정보 가져오기 실패.
    //3; // 존재하는 미션이 아님.
    //4; // 해당 미션이 슬롯에 존재하지 않음.
    //5; // 미션 완료 조건을 만족하지 못함.
    //6; // 미션 처리시 DB 오류.
    //7; // 미션이 등록되어 있지 않음.
    //8; // 미션 보상 아이템이 DB에 존재하지 않음.
    //9; // 선택 보상을 선택하지 않았음.
    //10;// Count가 1보다 작음
    //11;// 넷마블 파천황 캐시 이벤트 아이템 웹에 지급 성공
	//NetError::ERR_MISSION_27; // 피로도 상태라 미션 완료 불가
    //-99; // 알수없는 오류
    //-98    작업중인 패킷

    bool bCheckPromotion = false;

    if( kRecv.m_nOK == 0 
#ifdef NATION_KOREA
        || kRecv.m_nOK == 11 
#endif
        )
    {
        SMissionReward sReward;
        sReward.m_iGp = kRecv.m_iGP;
        sReward.m_iExp = kRecv.m_iExp;

        // 보상처리
        //g_kGlobalValue.m_kUserInfo.iGP += kRecv.m_iGP;
        g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( g_kGlobalValue.GetCurrentCharacterGP() + kRecv.m_iGP );
        if( kRecv.m_cCharType == -1)
        {
            if( kRecv.m_iExp != 0 )
            {
                printf("Error! CharType is not defined\n");
#if defined (_DEBUG)
                assert(kRecv.m_iExp == 0);
#endif
            }
        }
        else
        {            
            for(int i = 0; i < (int)g_kGlobalValue.m_kUserInfo.vecCharInfo.size(); i++ )
            {
                SCharInfo &Info = g_kGlobalValue.m_kUserInfo.vecCharInfo[i];

                if( Info.iCharType == kRecv.m_cCharType )
                {
                    int iMaxCharLevel = g_kGlobalValue.GetMaxCharLevel();
                    unsigned char cStartLevel  = Exp_2_Level(Info.biExp);
                    Info.biExp += kRecv.m_iExp;
                    unsigned char cResultLevel = Exp_2_Level(Info.biExp);
                    Info.iLevel = cResultLevel;
                    if( cStartLevel < cResultLevel )
                    {
                        sReward.m_bLevelUp = true;
                        sReward.m_iLevel = (int)cResultLevel;
                        sReward.m_eCharType = (EGCCharType)Info.iCharType;

#if defined( NEW_LEVELUP_EFFECT )
                        if ( g_pkChatManager != NULL )
                        {
                            std::wstring tempMsg = L"#c" + g_kGlobalValue.m_kUserInfo.strNickColor + g_kGlobalValue.m_kUserInfo.strNickName;
                            std::wstring& strLevelUpMessage = g_pkStrLoader->GetReplacedString( STR_ID_LEVELUP_MESSAGE, "l", tempMsg);
                            g_pkRoomChatBox->AddChat( strLevelUpMessage, KGCChatManager::CHAT_TYPE_NORMAL );
                        }
#endif

                    }
                    if( kRecv.m_cPromotionLevel != 0 )
                    {
                        Info.iPromotionLevel = (int)kRecv.m_cPromotionLevel;    // 전직 되었음
                        g_pkUIScene->m_pkMissionUI_S4->SetGetNewCharInfo(false, Info.iCharType, Info.iPromotionLevel);
                        bCheckPromotion = true;
                    }

                    // Jaeho 2008.01.10
                    // 전직레벨 정보를 변경시켜 주지 않으면 미션 보상받은 아이템을 바로 껴보지 못함.
                    if( Info.iCharType == g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar().iCharType )
                    {
                        if( g_MyD3D->m_pStateMachine->IsStateRoom() || g_MyD3D->m_pStateMachine->IsStateMyInfo() )
                        {
                            g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar().iPromotionLevel = Info.iPromotionLevel;
                        }

                        g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar().biExp        = Info.biExp;
                        g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar().iLevel       = Info.iLevel;
                    }

                    Info.kSkillInfo = kRecv.m_kSkillInfo;
                }
            }
        }

        if( kRecv.m_kCharacterInfo.m_cCharType != -1 )  // 새 캐릭터를 받음
        {
            //캐릭터를 등록하고..
            SCharInfo Info;
            GCFUNC::ConvertCharInfo( Info, kRecv.m_kCharacterInfo );
            g_pItemMgr->EquipBaseItem( &Info );
            g_kGlobalValue.m_kUserInfo.AddChar( Info, true );

            //태그매치용 케릭터 선택 UI를 갱신한다
            //2013-08 UI개선 후, 삭제된 컨텐츠에 대해 고려 작업 하지 않음
            //g_pIndigoSelect->Init();
            //g_pTagMatchSelect->Init();

            //memcpy( g_kGlobalValue.m_kUserInfo.aiTagSlot, g_pIndigoSelect->GetSlot(), sizeof(g_kGlobalValue.m_kUserInfo.aiTagSlot[0])*3 );

            g_pkUIScene->m_pkMissionUI_S4->SetGetNewCharInfo(true, Info.iCharType, static_cast< int >( kRecv.m_cPromotionLevel ) );
            bCheckPromotion = true;
        }

        for( int i = 0 ; i < (int)kRecv.m_vecInv.size() ; ++i )
        {
            sReward.m_vecItem.push_back( std::vector< std::pair< DWORD, int > >::value_type( kRecv.m_vecInv[i].m_ItemID / 10, kRecv.m_vecInv[i].m_nPeriod ) );
        }
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecInv, true );

        // Jaeho 2008.01.10
        // 지워질 미션 아이템을 인벤토리 아이템 리스트에서도 지우고, 전체 인벤토리에서도 지워준다.
        g_pItemMgr->m_kInventory.AddItemList( kRecv.vecDelItemInfo, true );
        for(int i=0;i<(int)kRecv.vecDelItemInfo.size();++i)
        {
            if( 0 == kRecv.vecDelItemInfo[i].m_nCount )
            {
                GCITEMUID itemUID =  kRecv.vecDelItemInfo[i].m_ItemUID;
                g_pItemMgr->m_kInventory.RemoveItem( itemUID );
            }
        }

        if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
        {
            g_pkUIScene->m_pkMyInfoScene->SetInvenWndCategory( g_pkUIScene->m_pkMyInfoScene->GetInvenCategory() );
        }
        //g_pItemMgr->AddInventory( kRecv.vecDelDurationItemInfo );   //수량이 0인 아이템을 넣어서 내부적으로는 삭제..

        int iIndex = g_MyD3D->Get_MyPlayer();
        if ( iIndex < MAX_PLAYER_NUM && iIndex >= 0 )
        {
            g_MyD3D->MyPlayer[iIndex]->SetMyPlayer();
        }

        if ( g_MyD3D->m_pStateMachine->IsStateRoom() || g_MyD3D->m_pStateMachine->GetState() == GS_GAME_END )
        {
            KP2P::GetInstance()->Send_ChangeIndoorUserInfoReq( &g_kGlobalValue.m_kUserInfo );
        }
        else
        {
            g_MyD3D->m_TempPlayer.SetMyPlayer(-1);
        }


        sReward.m_iNewChar = kRecv.m_kCharacterInfo.m_cCharType;
        sReward.m_iNewJob = (int)kRecv.m_cPromotionLevel;

        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_kGlobalValue.m_kUserMission.CompleteMission( kRecv.m_dwMissionID );
        g_kGlobalValue.m_kUserMission.SetNewMission( kRecv.m_dwMissionID, false );

        if( bCheckPromotion )
        {
            g_pkUIScene->m_pkMissionUI_S4->ShowGetCharacterUI( sReward );
        }
        else
        {
            g_pkUIScene->m_pkMissionUI_S4->ShowMissionComplete( sReward );
        }

        if ( g_MyD3D->m_pStateMachine->IsStateRoom() || g_MyD3D->m_pStateMachine->GetState() == GS_GAME_END )
        {
            g_pkUIScene->RoomSceneUpdateData(true);
        }

        g_kGlobalValue.m_kUserMission.RefreshUserMission();
        g_kGlobalValue.m_kUserInfo.mapStagePlayable = kRecv.m_mapDifficulty; // 캐릭터 획득시 오픈된 던전 정보 서버 데이터와 동기화.        
        SiKGCWorldMapManager()->UpdateWorldMap();

        //  룸안이면
        if ( g_MyD3D->m_pStateMachine->IsStateRoom() ) 
        {
            g_pkUIScene->m_pkRoomSceneS6->UpdateMissionData();
        }

        if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
        {
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        }

        if( (int)kRecv.m_vecMissiondata.size() > 0 )
        {
            g_kGlobalValue.m_kUserMission.AddMission( kRecv.m_vecMissiondata[0].m_dwMissionID );
        }
        g_pkUIScene->m_pkMissionUI_S4->RefreshUI();

#ifdef NATION_KOREA
        if( kRecv.m_nOK == 11 )
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_COMPLETE_CASH_MISSION ), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0,
                false, true );
        }
#endif

#if defined(USE_GUIDE_SYSTEM)
        g_MyD3D->m_kGuideMgr.UpdateMissionInfo( kRecv.m_dwMissionID );
#endif
        SiKGCMissionManager()->SetClearMissionData( kRecv.m_vecFinishedMission );

        if ( g_MyD3D->m_pStateMachine->IsStateRoom() ) 
        {
            // 획득가능한 에픽미션이 있는지 확인
            if ( false == SiKGCMissionManager()->CheckEpicMission( SiKGCRoomManager()->GetGameMode() ) )
            {
                // 획득가능한 일반미션 확인
                DWORD dwNormalMissionID = SiKGCMissionManager()->CheckNormalMission( SiKGCRoomManager()->GetGameMode() );
                g_pkUIScene->m_pkRoomSceneS6->m_pkRoomDungeonPanel->SetNormalMission(dwNormalMissionID);
            }
            else
                g_pkUIScene->m_pkRoomSceneS6->m_pkRoomDungeonPanel->SetNormalMission(0);
        }

        g_KDSound.Play( "Mission_Complete" );

    }
    else if( kRecv.m_nOK == 9 )
    {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_MISSION_ERROR4),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0,
            false, true );
    }
    else if( kRecv.m_nOK == -98)
    {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PACKET_DELAY ),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
    }
	else if ( kRecv.m_nOK == NetError::ERR_MISSION_27 )
	{
		g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_MISSION_COMPLETE_ERR ),
			L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
	}
    else
    {
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );

        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_MISSION_ERROR3),
            strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
    }

    SAFE_DELETE( pkBuff );
}
void On_EVENT_REMOVE_MISSION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    KSerBuffer* pkBuff = (KSerBuffer*)lParam;
    KEVENT_REMOVE_MISSION kRecv;
    ks.BeginReading( pkBuff );
    ks.Get( kRecv );
    ks.EndReading();

    //0; // 성공
    //1; // 유저가 존재하지 않음
    //2; // 제거하려는 미션이 등록되어 있지 않음.
    //3; // 미션 처리시 DB 오류.
    //4: // 삭제할 수 없는 미션.
    //-99; // 알수없는 오류
    //-98    작업중인 패킷

    if( kRecv.m_nOK == 0 )
    {
        //g_pMissionManager->DeleteUserMission( kRecv.m_dwMissionID );
        g_kGlobalValue.m_kUserMission.DeleteMission( kRecv.m_dwMissionID );
        g_kGlobalValue.m_kUserCollectionMission.DeleteCollectionMission( kRecv.m_dwMissionID );

        g_kGlobalValue.m_kUserMission.RefreshUserMission();

        g_pkUIScene->m_pkMissionUI_S4->RefreshUI();

        //  룸안이면
        if ( g_MyD3D->m_pStateMachine->IsStateRoom() ) 
        {
            g_pkUIScene->m_pkRoomSceneS6->UpdateMissionData();
        }
    }
    else if( kRecv.m_nOK == 4 )
    {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NO_DELETE_MISSION ),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
    }
    else if( kRecv.m_nOK == -98)
    {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PACKET_DELAY ),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
    }
    else
    {
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_MISSION_ERROR2),
            strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
    }

    SAFE_DELETE( pkBuff );
}

//void On_EVENT_CHANGE_JOB_ACK( WPARAM wParam, LPARAM lParam )
//{
//  KSerializer ks;
//  KSerBuffer* pkBuff = (KSerBuffer*)lParam;
//  KEVENT_CHANGE_JOB kRecv;
//  ks.BeginReading( pkBuff );
//  ks.Get( kRecv );
//  ks.EndReading();
//
//  if( kRecv.m_nOK == 0 )
//  {
//      // 전직 주문서 아이템은 절대로 수량성이 아니어야함!!!!!!
//      bool bPromotionSuccess = false;
//      g_pItemMgr->RemoveInventory( kRecv.m_dwGoodsUID );
//      g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
//      SProtectedUserInfo &UserInfo = g_MyD3D->m_TempPlayer.m_UserInfo;
//      for(int i = 0; i < (int)UserInfo.vecMyCharInfo.size(); i++ )
//      {
//          if( UserInfo.vecMyCharInfo[i].iCharType == (int)kRecv.m_cCharType )
//          {
//              UserInfo.vecMyCharInfo[i].iJobLevel = (int)kRecv.m_cPromotionLevel;
//              bPromotionSuccess = true;
//              break;
//          }
//      }
//
//      SProtectedUserInfo &UserInfo2 = g_kGlobalValue.m_kUserInfo;
//      for(i = 0; i < (int)UserInfo2.vecMyCharInfo.size(); i++ )
//      {
//          if( UserInfo2.vecMyCharInfo[i].iCharType == (int)kRecv.m_cCharType )
//          {
//              UserInfo2.vecMyCharInfo[i].iJobLevel = (int)kRecv.m_cPromotionLevel;
//              bPromotionSuccess = true;
//              break;
//          }
//      }
//
//      if( bPromotionSuccess )
//      {
//          g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_PROMOSION),
//              L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
//      }
//      else
//      {
//          g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_PROMOSION_ERROR1),
//              L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
//      }
//  }
//  else
//  {
//      g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_PROMOSION_ERROR2),
//          L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
//  }
//  /*
//  int             m_nOK;
//  DWORD           m_dwGoodsID;        // 전직 아이템 ID
//  DWORD           m_dwGoodsUID;       // 전직 아이템 UID
//  char            m_cCharType;        // 전직할 캐릭터
//  char            m_cPromotionLevel;  // 전직할 레벨(1,2, ... )
//  */
//
//  SAFE_DELETE( pkBuff );
//}
//void On_EVENT_TIME_LIMIT_EVENT_NOT( WPARAM wParam, LPARAM lParam )
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( KEVENT_TIME_LIMIT_EVENT_NOT );
//    g_kGlobalValue.m_mapEvent.clear();
//    memset( g_kGlobalValue.m_abEnableEvent, 0, sizeof(bool)*EVENT_ID_END );
//    for( int i = 0; i < (int)kRecv.m_vecTimeLimitEvent.size(); i++ )
//    {
//        g_kGlobalValue.m_mapEvent[kRecv.m_vecTimeLimitEvent[i].m_dwID] = kRecv.m_vecTimeLimitEvent[i];
//    }
//    SAFE_DELETE( pkBuff );
//}

void On_EVENT_LEAVE_GAME_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KGameResultOut );
    SAFE_DELETE( pkBuff );

    SiKGCMatchManager()->InitMatchInfo();
    SiKGCPartyManager()->EndParty();

    g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );


    if( kRecv.m_strLogin.size() == 0 )
    {
        return;
    }

    //KGCStateLoading* pState = (KGCStateLoading*)g_MyD3D->m_pStateMachine->GetStatePtr( GS_GAME_LOADING );
    //pState->SendTCPP2PDifference();
    
    g_pkUIScene->m_pkRoomSceneS6->InitLevelupEffect();

    SUserInfo* pUserInfo;
    int iPlayer = g_MyD3D->Get_MyPlayer();

    pUserInfo = &g_MyD3D->MyPlayer[iPlayer]->m_kUserInfo;

    //g_MyD3D->MyPlayer[iPlayer]->m_cLife = 0;

    // 미션 진행상황 갱신
    g_kGlobalValue.m_kUserMission.SetUserMissionList( kRecv.m_vecMissionSlot );
    g_kGlobalValue.m_kUserCollectionMission.SetUserCollectionMissionList( kRecv.m_vecCollectionSlot );

    std::vector< std::pair<char,KCharacterExpInfoOut> >::iterator vit;
    for( vit = kRecv.m_vecExps.begin();  vit != kRecv.m_vecExps.end(); ++vit )
    {
        std::pair<char,KCharacterExpInfoOut>& pairCharExp = (*vit);
        SCharInfo* pCharInfo = &pUserInfo->GetCurrentChar( (int)pairCharExp.first );
        if( pCharInfo == NULL )
        {
            g_kGlobalValue.m_strNullFunc =__FUNCTION__;
            continue;
        }

        char cStartLevel = Exp_2_Level(pCharInfo->biExp);
        pCharInfo->biExp = pairCharExp.second.m_biExp;
        pCharInfo->iLevel = Exp_2_Level(pairCharExp.second.m_biExp);
        char cResultLevel = pCharInfo->iLevel;

        //pairCharExp.second.m_cChatType;
        //pairCharExp.second.m_nOldSPLv;
        //pairCharExp.second.m_dwOldSPExp;
        //pairCharExp.second.m_dwSPExp;

        pCharInfo->kELOUserData.m_nELOWin = pairCharExp.second.m_nELOWin;
        pCharInfo->kELOUserData.m_nELOLose = pairCharExp.second.m_nELOLose;
        pCharInfo->kELOUserData.m_nRatingPoint = pairCharExp.second.m_nELORatingPoint;
        pCharInfo->kELOUserData.m_ucGrade = pairCharExp.second.m_ucGrade;
        pCharInfo->kELOUserData.m_nMatchTotalCount = pairCharExp.second.m_nMatchTotalCount;
        pCharInfo->kELOUserData.m_nELOType = pairCharExp.second.m_nELOType;
    }

    std::vector< std::pair<char,KPetInfo> >& vecPets = kRecv.m_vecPetInfo;
    std::vector< std::pair<char,KPetInfo> >::iterator mitPet;
    for( mitPet = vecPets.begin(); mitPet != vecPets.end(); ++mitPet )
    {
        std::pair<char,KPetInfo>& paircharPet = (*mitPet);
        SCharInfo* pCharInfo = &pUserInfo->GetCurrentChar( (int)paircharPet.first );
        if( pCharInfo == NULL )
        {
            g_kGlobalValue.m_strNullFunc =__FUNCTION__;
            continue;
        }

        GCITEMUID dwPetUID =  paircharPet.second.m_dwUID;
        if( g_MyD3D->IsExistPetInfo( dwPetUID ) && g_MyD3D->MyPlayer[iPlayer]->IsLocalPlayer() )
        {
            KPetInfo kPet = paircharPet.second;
            DWORD dwPetID = kPet.m_dwID / 10;
            DWORD dwCostumeID = kPet.m_kCostume.m_dwID / 10;
            GCITEMUID dwCostumeUID =  kPet.m_kCostume.m_dwUID;

            g_MyD3D->m_mapPetInfo[ dwPetUID ] = kPet;
            g_MyD3D->m_mapPetInfo[ dwPetUID ].m_dwUID = dwPetUID;
            g_MyD3D->m_mapPetInfo[ dwPetUID ].m_dwID = dwPetID;
            g_MyD3D->m_mapPetInfo[ dwPetUID ].m_kCostume.m_dwID = dwCostumeID;
            g_MyD3D->m_mapPetInfo[ dwPetUID ].m_kCostume.m_dwUID = dwCostumeUID;

            pCharInfo->kPetInfo = paircharPet.second;
            pCharInfo->kPetInfo.m_dwUID = dwPetUID;
            pCharInfo->kPetInfo.m_dwID = dwPetID;
            pCharInfo->kPetInfo.m_kCostume.m_dwID = dwCostumeID;
            pCharInfo->kPetInfo.m_kCostume.m_dwUID = dwCostumeUID;

            for( int i = 0; i < (int)pCharInfo->kPetInfo.m_vecEquipItem.size(); i++ )
            {
                // m_nItemType      0 영구/기간
                //                  1 수량
                GCITEMUID dwPetEquipItemUID = pCharInfo->kPetInfo.m_vecEquipItem[i].m_dwUID;
                DWORD dwPetEquipItemID = pCharInfo->kPetInfo.m_vecEquipItem[i].m_dwID / 10;

                pCharInfo->kPetInfo.m_vecEquipItem[i].m_dwUID = dwPetEquipItemUID;
                pCharInfo->kPetInfo.m_vecEquipItem[i].m_dwID = dwPetEquipItemID;
            }

            g_MyD3D->m_mapPetInfo[ dwPetUID ].m_vecEquipItem = pCharInfo->kPetInfo.m_vecEquipItem;
        }
    }

    pUserInfo->GetCurrentChar().SetCurrentGP( kRecv.m_nGamePoint );

    // 용사의 섬에서 승패
    if( g_kGlobalValue.ServerInfo.CheckServerType( ST_INDIGO ) )
    {
        pUserInfo->iIndigoLose = kRecv.m_iIndigoLose;
        pUserInfo->iIndigoWin = kRecv.m_iIndigoWin;
    }
    else
    {
        WinLoseProcess( pUserInfo, kRecv.m_vecWin, kRecv.m_vecLose );
    }

#if defined ( GUILD_RENEW_S4 )
    //if( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_GUILD_BATTLE )
    //{
    pUserInfo->iGuildScore = kRecv.m_dwContPoint;
    //}
#endif

    // 랭킹포인트 업데이트
    pUserInfo->iGetRP = kRecv.m_iRankingPoint - pUserInfo->iRP;
    pUserInfo->iRP = kRecv.m_iRankingPoint;

    // 플레이 가능한 던전 레벨을 구한다
    pUserInfo->mapStagePlayable = kRecv.m_mapDifficulty;
    
	if( iPlayer != 7 )
    {
		g_MyD3D->MyPlayer[iPlayer]->UpdateGlobalUserInfo();
        g_MyD3D->m_TempPlayer.SetMyPlayer(-1);
    }

    // 게임 도중에 나갔는데 아이템 획득하진 않을꺼 같아서 처리안함

    g_pStateGame->RemoveEmptyItem();

    // UI갱신
    // WONYWONY
    //g_pkUIScene->m_pkChannelScene->UpdateContestUserInfo();

    g_MyD3D->MyHead->Clear();
    g_MyD3D->MyHead->ComboClear();
    g_MyD3D->Clear2DObject();
    g_kGlobalValue.MakeErrorMotionToFile( "ErrorMotion.txt", true );

    Result_LeaveGame = 1;

    // 게임이 끝나면 다쓴 수량성 아이템 때문에 -_-;;
    g_MyD3D->MyPlayer[ iPlayer ]->SetDecChangeWeaponState( true );
    g_pItemMgr->UpdateUserItem( &g_kGlobalValue.m_kUserInfo );

    for ( int i = 0 ; i < MAX_PLAYER_NUM; i++ )
    {
        g_MyD3D->MyPlayer[i]->m_LoadingState.Init();
    }

// 	if (g_MyD3D->GetMyPlayer())
// 	{
// 		g_MyD3D->GetMyPlayer()->UpdateTempPlayerUserInfo();
// 	}

    SiKGCCoupleSystem()->ClearCoupleUserInfo();

    g_pkQuestManager->InitHackingCheckData();

    g_pItemMgr->UpdateUserItem( &g_kGlobalValue.m_kUserInfo );

    SiKGCRoomManager()->SetPlayedHeroDungeon(false);
	
	if ( SiKGCFatigueManager()->GetCurrentGameFatigueType() == KGCFatigueManager::YELLOW_TIME )
		g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_FATIGUE_SYSTEM_MESSAGE_7), L"" );
}

void On_EVENT_ENCHANT_GEMCOUNT_ACK( WPARAM wParam, LPARAM lParam )
{
    std::map<DWORD, DWORD>	mapEnchantGemCount;

    KSerializer ks;
    ACK_DESERIALIZE_MYPACKET( mapEnchantGemCount );
    g_pkUIScene->m_pkNewNecklaceEnchantDlg->SetEnchantGemCount( mapEnchantGemCount );
    g_iEnchantGemCountResult = 0;
    SAFE_DELETE( pkBuff );
}

void On_EVENT_SERVER_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SERVER_LIST_ACK );
    SAFE_DELETE( pkBuff );

    if( kRecv.m_nOK == 0 )
    {
        g_kGlobalValue.ServerList.clear();

        for( int i = 0; i < (int)kRecv.m_vecServerList.size(); ++i )
        {
            g_kGlobalValue.ServerList.push_back( kRecv.m_vecServerList[i] );
        }

        if( g_MyD3D->m_pStateMachine != NULL && g_MyD3D->m_pStateMachine->GetState() == GS_SERVER )
            g_pkUIScene->m_pkServerScene->UpdateServerList();

        // KServerInfo::m_prLvRange 여기에 해당 서버의 레벨 범위가 들어 있습니다. first, second => 시작 레벨, 끝레벨.
    }
}

// void On_EMS_VERIFY_ACCOUNT_ACK( WPARAM wParam, LPARAM lParam )
// {
//     KSerializer ks;
//     ACK_DESERIALIZE( KEMS_VERIFY_ACCOUNT_ACK );
//     SAFE_DELETE( pkBuff );
// 
//     if( kRecv.m_nOK == 0 )
//     {
//         g_pMsnDlg->SetBlockList( kRecv.m_setBlockList );
// 
//         std::map<DWORD,KFriendInfo>::iterator itor;
//         for( itor = kRecv.m_mapFriendList.begin() ; itor != kRecv.m_mapFriendList.end() ; ++itor )
//         {
//             if( KP2P::GetInstance()->m_kMsgServer != NULL )
//                 KP2P::GetInstance()->m_kMsgServer->AddFriend( itor->second );
//             g_pMsnDlg->UpdateList();
//         }
//     }
//     //#endif
// }

// void On_EMS_ADD_FRIEND_ACK( WPARAM wParam, LPARAM lParam )
// {
//     KSerializer ks;
//     ACK_DESERIALIZE( KEMS_ADD_FRIEND_ACK );
//     SAFE_DELETE( pkBuff );
// 
//     if( kRecv.m_nOK >= 0 )
//     {
//         if( KP2P::GetInstance()->m_kMsgServer != NULL )
//             KP2P::GetInstance()->m_kMsgServer->AddFriend( kRecv.m_kFriendInfo );
//         g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_SUCCESS_ADD_FRIEND).c_str(), L""
//             , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//     }
//     else if( kRecv.m_nOK == -1 )
//     {
//         g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_FRIEND_ERROR1).c_str(), L""
//             , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//     }
//     else if( kRecv.m_nOK == -2 )
//     {
//         g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_FRIEND_ERROR2).c_str(), L""
//             , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//     }
//     else if( kRecv.m_nOK == -4 )
//     {
//         g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_FRIEND_ERROR3).c_str(), L""
//             , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//     }
//     else if( kRecv.m_nOK == -5 )
//     {
//         g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_FRIEND_ERROR7).c_str(), L""
//             , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//     }
//     else if( kRecv.m_nOK == -6 ) // 초대 메세지에 사용 할 수 없는 단어가 포함되어 있습니다.
//     {
//         g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_FRIEND_ERROR8).c_str(), L""
//             , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//     }
//     else
//     {
//         std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
//         g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_FRIEND_ERROR4).c_str(), strTemp
//             , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//     }
//     //#endif
// }

// void On_EMS_DELETE_FRIEND_ACK( WPARAM wParam, LPARAM lParam )
// {
//     KSerializer ks;
//     ACK_DESERIALIZE( KEMS_DELETE_FRIEND_ACK );
//     SAFE_DELETE( pkBuff );
// 
//     JIF( KP2P::GetInstance()->m_kMsgServer != NULL );
// 
//     if( kRecv.m_nOK == 0 )
//     {
//         KP2P::GetInstance()->m_kMsgServer->DeleteFriend( kRecv.m_dwUserUID );
//         g_pkUIScene->m_pkMsnDlg->DeleteFriend( kRecv.m_dwUserUID );
//         g_pkUIScene->m_pkMsnDlg->UpdateList();
//     }
// }

// void On_EMS_ADD_FRIEND_NOT( WPARAM wParam, LPARAM lParam )
// {
//     KSerializer ks;
//     ACK_DESERIALIZE( KEMS_ADD_FRIEND_NOT );
// 
//     g_pkUIScene->MessageBox( KGCUIScene::GC_REGISTER_FRIEND, kRecv.m_strSenderNick, kRecv.m_strMessage,
//         KGCUIScene::GC_MBOX_USE_NORMAL, kRecv.m_dwSenderUID, 0, false, false );
// 
//     SAFE_DELETE( pkBuff );
// }

// void On_EMS_UPDATE_FRIENDS_NOT( WPARAM wParam, LPARAM lParam )
// {
//     KSerializer ks;
//     ACK_DESERIALIZE( std::vector<KFriendInfo> );
// 
//     if( KP2P::GetInstance()->m_kMsgServer != NULL )
//     {
//         for( int i=0 ; i<(int)kRecv.size() ; ++i )
//         {
//             KP2P::GetInstance()->m_kMsgServer->UpdateFriend( kRecv[i] );
//             g_pkUIScene->m_pkMsnDlg->UpdateFriend( kRecv[i].m_dwUserUID );
//         }
//     }
// 
//     SAFE_DELETE( pkBuff );
// }

// void On_EMS_UPDATE_FRIEND_NOT( WPARAM wParam, LPARAM lParam )
// {
//     KSerializer ks;
//     ACK_DESERIALIZE( KFriendInfo );
// 
//     if( KP2P::GetInstance()->m_kMsgServer != NULL )
//     {
//         // 친구가 오프라인이다가 온라인이 되었을 경우에는 접속을 알려줍니다.
//         if( KP2P::GetInstance()->m_kMsgServer->IsFriend( kRecv.m_dwUserUID ) )
//         {
//             if( !KP2P::GetInstance()->m_kMsgServer->GetFriend( kRecv.m_dwUserUID )->m_bOnline &&
//                 kRecv.m_bOnline )
//             {
//                 KP2P::GetInstance()->m_kMsgServer->FriendLogIn( kRecv.m_strNickName );
//             }
//         }
// 
//         KP2P::GetInstance()->m_kMsgServer->UpdateFriend( kRecv );
//         g_pkUIScene->m_pkMsnDlg->UpdateFriend( kRecv.m_dwUserUID );
//     }
// 
//     SAFE_DELETE( pkBuff );
// }

// void On_EMS_ACCEPT_FRIEND_ACK( WPARAM wParam, LPARAM lParam )
// {
//     KSerializer ks;
//     ACK_DESERIALIZE( KEMS_ADD_FRIEND_ACK );
// 
//     if( KP2P::GetInstance()->m_kMsgServer != NULL )
//     {
//         if( kRecv.m_nOK == 0 )
//         {
//             KP2P::GetInstance()->m_kMsgServer->AddFriend( kRecv.m_kFriendInfo );
//             g_pkUIScene->m_pkMsnDlg->UpdateList();
//         }
//         else if( kRecv.m_nOK == -5 )
//         {
//             g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_FRIEND_ERROR7).c_str(), L""
//                 , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//         }
//     }
// 
//     SAFE_DELETE( pkBuff );
// }

// void On_EMS_REJECT_FRIEND_NOT( WPARAM wParam, LPARAM lParam )
// {
//     KSerializer ks;
//     ACK_DESERIALIZE( DWORD );
// 
//     if( KP2P::GetInstance()->m_kMsgServer != NULL )
//     {
//         KP2P::GetInstance()->m_kMsgServer->DeleteFriend( kRecv );
//         g_pkUIScene->m_pkMsnDlg->DeleteFriend( kRecv );
//         g_pkUIScene->m_pkMsnDlg->UpdateList();
//     }
// 
//     SAFE_DELETE( pkBuff );
// }

// void On_EMS_CHAT_NOT( WPARAM wParam, LPARAM lParam )
// {
//     KSerializer ks;
//     ACK_DESERIALIZE( KFriendMsgInfo );
// 
//     g_pkUIScene->m_pkMsnDlg->AddChatStr( kRecv );
// 
//     SAFE_DELETE( pkBuff );
// }

// void On_EMS_BLOCK_FRIEND_ACK( WPARAM wParam, LPARAM lParam )
// {
//     KSerializer ks;
//     ACK_DESERIALIZE( KEMS_BLOCK_FRIEND_ACK );
// 
//     if( kRecv.m_nOK == 0 )
//     {
//         g_pkUIScene->m_pkMsnDlg->SetBlockFriend( kRecv.m_dwBlockUID );
//         g_pkUIScene->m_pkMsnDlg->UpdateList();
//     }
// 
//     SAFE_DELETE( pkBuff );
// }

// void On_EMS_UNBLOCK_FRIEND_ACK( WPARAM wParam, LPARAM lParam )
// {
//     KSerializer ks;
//     ACK_DESERIALIZE( KEMS_BLOCK_FRIEND_ACK );
// 
//     if( kRecv.m_nOK == 0 )
//     {
//         g_pkUIScene->m_pkMsnDlg->SetUnBlockFriend( kRecv.m_dwBlockUID );
//         g_pkUIScene->m_pkMsnDlg->UpdateList();
//     }
// 
//     SAFE_DELETE( pkBuff );
// }

// void On_EMS_KICK_NOT( WPARAM wParam, LPARAM lParam )
// {
//     KSerializer ks;
//     ACK_DESERIALIZE( int );
// 
//     // [7/20/2007 breadceo] 이중접속 감지 메세지를 띄워준다.
//     g_MyD3D->ExitWithMsgDlg( g_pkStrLoader->GetString( STR_ID_APPMSG_ERR_DOUBLE_CONNECT1 ).c_str(),
//         g_pkStrLoader->GetString( STR_ID_APPMSG_ERR_DOUBLE_CONNECT3 ).c_str() );
//     g_pkUIScene->m_pkMsnDlg->UpdateList();
// 
//     SAFE_DELETE( pkBuff );
// }

// void On_EMS_CLOSE_CONNECTION_NOT( WPARAM wParam, LPARAM lParam )
// {
//     KSerializer ks;
//     ACK_DESERIALIZE( KEVENT_CLOSE_CONNECTION_NOT );
// 
//     if( KP2P::GetInstance()->m_kMsgServer != NULL )
//     {
//         if( KP2P::GetInstance()->m_kMsgServer->ConnectToMsgServerAgain() == false )
//         {
//             if(g_pkUIScene->m_pkMsnDlg->IsRenderOn() == true )
//             {
//                 g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_FRIEND_ERROR5).c_str(),
//                     g_pkStrLoader->GetString(STR_ID_FRIEND_ERROR6).c_str(), KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//             }
//         }
//     }
// 
//     SAFE_DELETE( pkBuff );
// }

void On_EVENT_BUY_FOR_CASH_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BUY_FOR_CASH_ACK );

    // 110 ( 캐쉬 알수 없는 오류 )
    // 103 ( 캐쉬 차감 실패 )
    // 102 (캐쉬 포인트 얻기 실패 )
    // 101 (빌링 시스템 오류)
    // 100 ( 빌링 시스템 과부하 )
    // 8 (선물하려는 대상과 선물받는 대상이 같음)
    // 7 (선물하기 불가능 아이템)
    // 4 ( 인벤토리 아이템 갱신 실패. 서버 이동이 필요 )
    // 2 ( 허용되는 상태가 아님 )
    // 7 (선물하기 불가능 아이템)
    // 1 (빌링 타입이 올바르지 않음)
    //-1(OwnerLogin 없음)
    //-2(BuyerLogin 없음, BuyerCheck가 1일때 작동)
    //-3(입력받은 아이템이 캐쉬가 아니거나 비매품이거나 아예 없거나 패턴임)
    //-4(IPBP에 가격 정보가 존재하지 않음)
    //-5(입력할 아이템이 없음)
    //-6(Gash가 부족함, 보유Gash량에 0보다 큰값이 있을 경우 작동)
    //-7 ( 가상캐쉬와 혼합사용시 패키지 아이템 or 전직미션 구매 시도 )
    //-8 가상캐쉬 캐쉬구매 비율제한 초과
    // -10 ( 쿼리 실패 )
    // -11이하(트랜잭션 에러)

    switch( kRecv.m_nOK )
    {
    case 0: //성공
    case 4:
        {
            g_kGlobalValue.m_dwCash = kRecv.m_cashInfo.m_dwCashPoint;
            START_LOG( cout, kRecv.m_cashInfo.m_dwCashPoint );
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem, true );

            // 슬롯 아이템 구입 체크
            if( g_MyD3D->m_pStateMachine->GetState() == GS_CHAR_SELECT )
            {
                g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_BUT_ADD_SLOT_ITEM ) );
            } 

            if( kRecv.m_bPremium )
            {
                g_kGlobalValue.m_kUserInfo.dwPremium = KPremiumInfo::TYPE_GCCLUB;
            }
            
            g_kGlobalValue.m_dwVirtualCash = kRecv.m_kVirtualCashInfo.m_dwCashPoint; // 가상캐쉬 남은 잔액
            g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
            g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            
            if ( g_pkUIScene->m_pkRickoonTornado->GetCreateComplete() )
                g_pkUIScene->m_pkRickoonTornado->SetCoinCount();

            if ( g_pkUIScene->m_pkSphinxDlg->GetCreateComplete() )
                    g_pkUIScene->m_pkSphinxDlg->UpdateCoin();

            if ( g_pkUIScene->m_pkCoordiComposeDlg && g_pkUIScene->m_pkCoordiComposeDlg->IsWndState( KD3DWnd::D3DWS_ENABLED ) )
                g_pkUIScene->m_pkCoordiComposeDlg->UpdateItemCount();

            if ( g_pkUIScene->m_pkCoordiUpgradeDlg && g_pkUIScene->m_pkCoordiUpgradeDlg->IsWndState( KD3DWnd::D3DWS_ENABLED ) )
                g_pkUIScene->m_pkCoordiUpgradeDlg->UpdateItemCount();
            
            //	상점 UI 갱신
#if defined (USE_AGIT_SYSTEM)
            SiKGCAgitGameManager()->BuyDummyObject();
            SiKGCAgitGameManager()->RefreshInvenObject();
            g_pkUIScene->m_pkAgitShop->InitAgitShop( false );
            g_pkAgitOverlayUI->UpdatePlaceCollectUI();
#endif
            // GC 적립내역
            if( kRecv.m_kVirtualCashInfo.m_dwAddCashPoint == 0 ){
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
                    	g_pkStrLoader->GetString( STR_ID_BUY_ITEM_SUCCEEDED1 ),
                    	g_pkStrLoader->GetString( STR_ID_BUY_ITEM_SUCCEEDED2 ), KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
            } else {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_BUY_CASH_ITEM_ACCUMULATED_GC_DLG, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
                g_pkUIScene->m_pkBuyCashItemAccumulatedGCDlg->SetAccumulateInfo( kRecv.m_kVirtualCashInfo );
            }
           break;
        }
    case 3: // 구매제한 상품
        break;
    case 7: //선물하기 불가능 아이템
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PRESENT_FAIL_ERROR ) );
            break;
        }
    case 8:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GIFT_ITEM_FAIL ) );
            break;
    	}		
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp );

            break;
        }
        break;
    }
    Result_Buy_CashItem = kRecv.m_nOK ;
    SAFE_DELETE( pkBuff );
}

void On_EVENT_CURRENT_CASH_POINT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KCashInfo );

    // 110 ( 캐쉬 알수 없는 오류 )
    // 103 ( 캐쉬 차감 실패 )
    // 104 ( 체험 계정 )
    // 102 (캐쉬 포인트 얻기 실패 )
    // 101 (빌링 시스템 오류)
    // 100 ( 빌링 시스템 과부하 )

    switch( kRecv.m_nOK )
    {
    case 100: // 과부하, 다시 달라고 요청하자.
        {
            KSingleton<KP2P>::GetInstance()->Send_CurrentCashPoint();
            break;
        }
    case 104: //대만에서만 오는 return값이다.
        {
            g_kGlobalValue.m_kLoginInfo.bExpAccount = true;
            g_kGlobalValue.m_dwCash = 0;
            break;
        }
    case 105:
    case 101:
    case 102:
    case 110: // 오류.
        {
            g_kGlobalValue.m_dwCash = 0;
            break;
        }
    default:  // 정상처리
        {
            g_kGlobalValue.m_dwCash = kRecv.m_dwCashPoint;
            if ( g_MyD3D->m_pStateMachine->GetState() == GS_SHOP_CASH )
                g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
            if( g_MyD3D->m_pStateMachine->GetState() == GS_SHOP_GP )
                g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();
            if ( g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO )
                g_pkUIScene->m_pkMyInfoScene->m_pkInfoPanel->SetUserInfo();
            break;
        }
    }
    SAFE_DELETE( pkBuff );
}

void On_EVENT_CHECK_PURCHASE_ITEM_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    //KSerializer ks;
    //ACK_DESERIALIZE( KEVENT_CHECK_PURCHASE_ITEM_LIST_ACK );

    // 0 = 사용 금지, 1 = 선물, 2 = 구매
    //if ( kRecv.m_nOK != 0 )
    //{
    //}
    //else
    //{
    //    switch ( kRecv.m_nType )
    //    {
    //        case 0:
    //        {
    //            break;
    //        }
    //        case 1:
    //        {
    //            break;
    //        }
    //        case 2:
    //        {
    //            break;
    //        }
    //    }
    //}

    //SAFE_DELETE( pkBuff );
}

//void On_EVENT_SET_GAME_MODE( WPARAM wParam, LPARAM lParam ) //레벨별 모드 제한.
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( KEVENT_SET_GAME_MODE );
//
//    SAFE_DELETE( pkBuff );
//}

void On_EVENT_SHANGHAI_DROP_ACK( WPARAM wParam, LPARAM lParam ) //상하이 드랍 단독
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SHANGHAI_DROP_ACK );
    //이 패킷이 오면 반드시 드랍이 있는것이다.

    kRecv.m_vecInv; //일반 아이템

    //아이템 획득
    static int pItemNum[MAX_ITEM_RECEIVE];
    static int pItemDuration[MAX_ITEM_RECEIVE];
    OnItemReceive( kRecv.m_vecInv );


    //상하이 미션 자동 등록 - 자동등록된 미션은 안 보여주고 그냥 등록하고, 그 다음 느낌표 띄워서 표시!
    for ( int i = 0 ; i < (int)kRecv.m_vecAutoMission.size() ; i++ )
    {
        //g_pMissionManager->AddUserMission( kRecv.m_vecAutoMission[i] );
        g_kGlobalValue.m_kUserMission.AddMission( kRecv.m_vecAutoMission[i].m_dwMissionID );
        g_kGlobalValue.m_kUserCollectionMission.AddCollectionMission( kRecv.m_vecAutoMission[i].m_dwMissionID );
    }

    g_kGlobalValue.m_kUserMission.SetAutoMission( kRecv.m_vecAutoMission );

    g_pkUIScene->m_pkMissionUI_S4->RefreshUI();

    // UI갱신 // 드랍을 받았는데 UI를 왜 갱신 해야 하는가?? 안해도 될것 같은데 ㅡㅡ
    // WONYWONY
    //g_pkUIScene->m_pkChannelScene->UpdateContestUserInfo();
    //g_pkUIScene->RoomSceneUpdateData();

    //  인벤토리
    if ( !kRecv.m_vecInv.empty() )
    {
        g_pkChatManager->AddChatMsg( g_pkStrLoader->GetString( STR_ID_SHANGHAI_INVEN_NOTY ), KGCChatManager::CHAT_TYPE_ALERT );
    }
    
    //  우편확인
    if ( kRecv.m_bPostItem )
    {
        g_pkChatManager->AddChatMsg( g_pkStrLoader->GetString( STR_ID_SHANGHAI_POST_NOTY ), KGCChatManager::CHAT_TYPE_ALERT );
    }



    SAFE_DELETE( pkBuff );
}

void On_EVENT_RECOMMENDER_ACK( WPARAM wParam, LPARAM lParam ) //추천인 시스템
{
    KSerializer ks;

    ACK_DESERIALIZE( int );

    // 3  추천인 시스템 없음
    // 2  추천인 닉네임이 비어 있음
    // 1  비추하였음
    // 0  정상적으로 추천인이 등록 되었음
    // -1 추천하려는 사람의 정보가 없음 --> 이녀석인 경우 심각한 문제이다. 넘어가시오.
    // -2 이미 추천하였습니다.(이중접속등으로 인해서 다른넘이 먼저 등록했다. 일수 있음)
    // -3 다시 추천하세욤.(대상이 존재하지 않음)

    SAFE_DELETE( pkBuff );

}

void On_EVENT_EQUIP_ITEM_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;

    ACK_DESERIALIZE(KEVENT_EQUIP_ITEM_ACK);

    Result_ItemEquip = kRecv.m_nOK;

    if (kRecv.m_nOK == 0)
    {
        SAFE_DELETE(pkBuff);
        Result_ItemEquip = kRecv.m_nOK;
        return;
    }
	
    On_EQUIP_ITEM(kRecv);
    Result_ItemEquip = kRecv.m_nOK;
    SAFE_DELETE(pkBuff);

}

void On_EVENT_EQUIP_ITEM_BROAD(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEquipUser);
    On_CHANGE_EQUIP_ITEM(kRecv);
    Result_ItemEquip = 0;
    SAFE_DELETE(pkBuff);
}

void On_EVENT_CHANGE_ROOMUSER_INFO_BROAD(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KChangeRoomUserInfo);
    SAFE_DELETE(pkBuff);

    if (kRecv.m_ucChangeType == KChangeRoomUserInfo::RUI_INFO_STATE)
        Result_Change_Room_UserInfo = kRecv.m_nOK;

    if (kRecv.m_nOK == 1 || kRecv.m_nOK == -1)
    {
        g_MyD3D->m_pStateMachine->ExitRoom(true);
        return;
    }

    if (kRecv.m_nState == GC_RUS_NONE)
    {
        return;
    }

    switch (kRecv.m_ucChangeType)
    {
    case KChangeRoomUserInfo::RUI_CHAR:
    {
        On_CHANGE_CHARACTER(kRecv);
        break;
    }
    case KChangeRoomUserInfo::RUI_USER_SLOT:
    case KChangeRoomUserInfo::RUI_TEAM:
    case KChangeRoomUserInfo::RUI_INFO_STATE:
    {
        On_CHANGE_TEAM_READY(kRecv);
        if (SiKGCRoomManager()->GetGameModeCategory() != GC_GMC_DUNGEON)
        {
            On_CHANGE_SLOT(kRecv);
        }
        On_CHANGE_INTO_INFO(kRecv);
        break;
    }
    case KChangeRoomUserInfo::RUI_INDIGO_SLOT:
    {
        On_CHANGE_INDIGO_SLOT(kRecv);
        break;
    }
    default:
    {
        break;
    }
    }

    if (g_MyD3D->m_pStateMachine->IsStateRoom())
    {
        int iUserIndex = g_MyD3D->Get_Player(kRecv.m_dwUserUID);
        if (g_MyD3D->MyPlayer[iUserIndex]) {
            g_MyD3D->MyPlayer[iUserIndex]->Calcualte_Point();
        }
        g_pkUIScene->RoomSceneUpdateData();
    }

}

void On_EVENT_CHANGE_INDOOR_USERINFO_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KInDoorUserInfo );
    if ( g_MyD3D->m_pStateMachine->IsStateRoom() || g_MyD3D->m_pStateMachine->GetState() == GS_GAME_END )
        On_CHANGE_INDOORUSER_INFO( kRecv );
    SAFE_DELETE( pkBuff );
}

void On_EVENT_KAIRO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_KAIRO_ACK );

    //m_nOK = 0;
    //m_nOK = 1;    요청받은 아이템이 인벤토리에 없음.)
    //m_nOK = 2;    보상할 아이템이 없음.)
    //m_nOK = 3;    Kairo에 등록된 아이템이 아님.)
    //m_nOK = 4     DB작업 실패
    //m_nOK = 5     상자 아이템 동기화 실패

    Result_Kid_Gift = kRecv.m_nOK;

    if( kRecv.m_nOK == 1 || kRecv.m_nOK == 3 || kRecv.m_nOK == 4 || kRecv.m_nOK == 5 )
    {
        START_LOG( cout, "KAIRO_ACK ERROR!!!!" )
            << BUILD_LOG( kRecv.m_nOK );
    }
    else
    {
        if ( kRecv.m_nOK == 2 )
        {
			std::wstring strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_RECEIVE_GGUANG );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, L"" );
        }
        else
        {
            if( KGCItemManager::ITEM_TREASURE_ITEM_BOX == kRecv.m_kReqItemInfo.m_ItemID )
            {
                int iTreasureItemID = -1;
				int nEnchantLevel = 0;
                if( kRecv.m_vecItem.size() )
                {
                    iTreasureItemID = kRecv.m_vecItem.begin()->m_ItemID;
					nEnchantLevel = kRecv.m_vecItem.begin()->m_cEnchantLevel;
                }

                if( -1 != iTreasureItemID )
                {
                    g_pkUIScene->m_pkTreaureItemBox->SetItem( iTreasureItemID, nEnchantLevel );
                    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"" );
                }

                // 지울꺼 지우고
                g_pItemMgr->m_kInventory.AddItem( kRecv.m_kReqItemInfo , true);
                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem, true );
            }
            else
            {
                g_pItemMgr->m_kInventory.AddItem( kRecv.m_kReqItemInfo, true );
                OnItemReceiveSmallBox( kRecv.m_vecItem );
            }
        }

        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_KAIRO_ONESHOT_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_KAIRO_ONESHOT_ACK);

    Result_Kairo_Oneshot = kRecv.m_nOK;

    if (kRecv.m_nOK == 1 || kRecv.m_nOK == 3 || kRecv.m_nOK == 4 || kRecv.m_nOK == 5)
    {
    }
    else
    {
        if (kRecv.m_nOK == 2)
        {
            std::wstring strMsg = g_pkStrLoader->GetString(STR_ID_ITEM_RECEIVE_GGUANG);
            g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, strMsg, L"");
            g_pItemMgr->m_kInventory.AddItem(kRecv.m_kReqItemInfo, true);
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
        }
        else
        {
            if (KGCItemManager::ITEM_TREASURE_ITEM_BOX == kRecv.m_kReqItemInfo.m_ItemID)
            {
                int iTreasureItemID = -1;
                int nEnchantLevel = 0;
                if (kRecv.m_vecItem.size())
                {
                    iTreasureItemID = kRecv.m_vecItem.begin()->m_ItemID;
                    nEnchantLevel = kRecv.m_vecItem.begin()->m_cEnchantLevel;
                }

                if (-1 != iTreasureItemID)
                {
                    g_pkUIScene->m_pkTreaureItemBox->SetItem(iTreasureItemID, nEnchantLevel);
                    g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"");
                }

                g_pItemMgr->m_kInventory.AddItem(kRecv.m_kReqItemInfo, true);
                g_pItemMgr->m_kInventory.AddItemList(kRecv.m_vecItem, true);
            }
            else
            {
                g_pItemMgr->m_kInventory.AddItem(kRecv.m_kReqItemInfo, true);
                OnItemReceive(kRecv.m_vecItem, false, false);
            }
        }

        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    }

    SAFE_DELETE(pkBuff);
}

void On_EVENT_ACCUMULRATION_TIME_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ACCUMULRATION_TIME_NOT );

	//kRecv.m_nAccOfflineTime;
	//kRecv.m_nAccOnlineTime;
	//kRecv.m_mapFatigueTable;
	SiKGCFatigueManager()->InitFatigueSystem(kRecv);

    SAFE_DELETE( pkBuff );
}

//펫 관련
//void On_EVENT_BINDING_PET_ACK( WPARAM wParam, LPARAM lParam )
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( KEVENT_BINDING_PET_ACK );
//
//  Result_BindindPet = kRecv.m_nOK;
//  if( kRecv.m_nOK == 0 )
//  {
//      if( kRecv.m_pairEquipPet.second.m_dwUID != 0 )
//      {
//          DWORD dwPetUID =  kRecv.m_pairEquipPet.second.m_dwUID;
//          g_MyD3D->m_mapPetInfo[ dwPetUID ] = kRecv.m_pairEquipPet.second;
//          g_MyD3D->m_mapPetInfo[ dwPetUID ].m_dwUID = dwPetUID;
//      }
//  }
//
//    SAFE_DELETE( pkBuff );
//}

//void On_EVENT_BINDING_PET_BROAD( WPARAM wParam, LPARAM lParam )
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( KEVENT_BINDING_PET_BROAD );
//
//  //KEVENT_BINDING_PET_BROAD
//  //std::wstring                m_strLogin;         // 유저 로긴
//  //DWORD                       m_dwUserUID;        // 유저 UID
//  //std::pair<char,KPetInfo>    m_pairEquipPet;     // 장착된 펫 정보
//  //std::vector<char>           m_vecReleaseChar;   // 해지된 펫 정보( 방에서 펫 삭제시 여러개 릴리즈 되는경우 있다.)
//
//  for( int i = 0; i < MAX_PLAYER_NUM; i++ )
//  {
//      // 플레이어 정보 중 브로드의 대상을 찾는다
//      if( wcscmp( g_MyD3D->MyPlayer[i]->GetPlayerLoginID(), kRecv.m_strLogin.c_str() ) == 0
//          && g_MyD3D->MyPlayer[i]->m_kUserInfo.dwUID == kRecv.m_dwUserUID )
//      {
//          // 장착된 놈이 있다
//          if( kRecv.m_pairEquipPet.first != -1 )
//          {
//              SCharInfo &SChar = g_MyD3D->MyPlayer[i]->m_kUserInfo.GetCurrentChar( kRecv.m_pairEquipPet.first );
//              SChar.kPetInfo = kRecv.m_pairEquipPet.second;
//          }
//
//          // 해제된 놈이 있다
//          for( int j = 0; j < (int)kRecv.m_vecReleaseChar.size(); j++ )
//          {
//              SCharInfo &SChar = g_MyD3D->MyPlayer[i]->m_kUserInfo.GetCurrentChar( kRecv.m_vecReleaseChar[i] );
//              SChar.kPetInfo.m_dwUID = 0;
//          }
//      }
//  }
//
//    SAFE_DELETE( pkBuff );
//}

void On_EVENT_CREATE_PET_ACK( WPARAM wParam, LPARAM lParam )
{
    /*
    kPacket.m_nOK, 0  // 성공
    kPacket.m_nOK, 1  // 펫 존재하지 않음
    kPacket.m_nOK, 2  // 펫 아이템을 가지고 있지 않음
    kPacket.m_nOK, 3  // 신규 생성하려는 펫이 이미 존재함
    kPacket.m_nOK, 4  // 해당 유저가 존재하지 않음
    kPacket.m_nOK, 5  // 펫 아이템이 아님
    kPacket.m_nOK, 6  // 해당 캐릭터가 존재하지 않음
    kPacket.m_nOK, 7  // 펫 귀속 아이템이 아닌데 캐릭터 타입이 전달됨.
    */

    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CREATE_PET_ACK );

    Result_CreatePet = kRecv.m_nOK;

    if( kRecv.m_nOK == 0 )
    {
        if( kRecv.m_pairCreatePet.second.m_dwUID != 0 )
        {
            // 펫 생성 시 생성된 펫 정보를 저장 시킨다
            GCITEMUID dwPetUID =  kRecv.m_pairCreatePet.second.m_dwUID;
            DWORD dwPetID = kRecv.m_pairCreatePet.second.m_dwID / 10;
            DWORD dwCostumeID = kRecv.m_pairCreatePet.second.m_kCostume.m_dwID / 10;
            GCITEMUID dwCostumeUID =  kRecv.m_pairCreatePet.second.m_kCostume.m_dwUID;
            g_MyD3D->m_mapPetInfo[ dwPetUID ] = kRecv.m_pairCreatePet.second;
            g_MyD3D->m_mapPetInfo[ dwPetUID ].m_dwUID = dwPetUID;
            g_MyD3D->m_mapPetInfo[ dwPetUID ].m_dwID = dwPetID;
            g_MyD3D->m_mapPetInfo[ dwPetUID ].m_kCostume.m_dwID = dwCostumeID;
            g_MyD3D->m_mapPetInfo[ dwPetUID ].m_kCostume.m_dwUID = dwCostumeUID;

            // 캐릭터가 장착하고 있는 펫 정보도 바꿔준다
            g_MyD3D->m_TempPlayer.SetEquipPetInfo( kRecv.m_pairCreatePet.first, dwPetUID );

            // 생성 시 아이템을 준다면?
            std::wstring strMsg;
            if( kRecv.m_vecRewardItem.size() > 0 )
            {
                for(int i = 0; i < (int)kRecv.m_vecRewardItem.size(); i++ )
                {
                    GCItem* kItem = g_pItemMgr->GetItemData( kRecv.m_vecRewardItem[i].m_ItemID / 10 );
                    CONTINUE_NIL( kItem );

                    if( kRecv.m_vecRewardItem[i].m_nCount == -1 )
                    {
                        strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE1, "l", kItem->strItemName );
                    }
                    else
                    {
                        DWORD dwReceivedCount = kRecv.m_vecRewardItem[i].m_nCount;
                        KItem* pkItem = g_pItemMgr->m_kInventory.FindItemByItemID( kItem->dwGoodsID );
                        if( pkItem != NULL )
                            dwReceivedCount -= pkItem->m_nCount;
#if defined(NATION_USA)
                        strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE1, "l", kItem->strItemName );
#else
                        strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE2, "li", kItem->strItemName, (int)dwReceivedCount );
#endif
                    }
                    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, L"" );
                }

                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewardItem, true );
            }

            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        }
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_SET_CURRENT_CHARACTER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    Result_SetCurrentChar = kRecv;
    SAFE_DELETE( pkBuff );
}

void On_EVENT_DELETE_PET_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DELETE_PET_ACK );

    /*
    kPacket.m_nOK, 0  // 펫 삭제 성공
    kPacket.m_nOK, 1  // 펫 아이템(시민권)이 없음
    kPacket.m_nOK, 2  // 펫 정보가 존재하지 않음
    kPacket.m_nOK, 3  // 해당 유저가 존재하지 않음
    kPacket.m_nOK, 4  // 펫 아이템이 아님
    kPacket.m_nOK, 5  // 시민권을 팔다가 오류 발생
    kPacket.m_nOK, 6  // DB와 User Data 동기화 실패
    kPacket.m_nOK, 7  // PC 방 펫 제거 하려고 함.
    kPacket.m_nOK, 8  // 펫의 소유권을 가진 캐릭터가 아닌데 펫 삭제 시도했음.
    kPacket.m_nOK, -98 // 아직 처리중인 작업입니다.
    */

    Result_DeletePet = kRecv.m_nOK;

    // 성공
    if( kRecv.m_nOK == 0 )
    {
        g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_iGP );

        if( kRecv.m_vecRewardItem.size() > 0 )
        {
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewardItem, true );
        }
    }
    else { 
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false);
    }

    SAFE_DELETE( pkBuff );
}

//void On_EVENT_PET_EQUIP_ACK( WPARAM wParam, LPARAM lParam )
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( KEVENT_PET_EQUIP_ACK );
//
//  if( kRecv.m_nOK == 0 )
//  {
//
//  }
//
//    SAFE_DELETE( pkBuff );
//}
//
//void On_EVENT_PET_EQUIP_BROAD( WPARAM wParam, LPARAM lParam )
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( KEVENT_PET_EQUIP_BROAD );
//
//
//    SAFE_DELETE( pkBuff );
//}

void On_EVENT_FEEDING_PET_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_FEEDING_PET_ACK );

    Result_FeedingPet = kRecv.m_nOK;

    // 성공
    if( kRecv.m_nOK == 0 )
    {
        GCITEMUID dwPetUID =  kRecv.m_dwPetUID;
        if( dwPetUID != 0 )
        {
            if( g_MyD3D->m_mapPetInfo.count( dwPetUID ) != 0 )
            {
                if( kRecv.m_iSatiation <= MAX_SATIATION )
                    g_MyD3D->m_mapPetInfo[ dwPetUID ].m_iSatiation = kRecv.m_iSatiation;
                else
                    g_MyD3D->m_mapPetInfo[ dwPetUID ].m_iSatiation = MAX_SATIATION;
            }
        }
    }

    SAFE_DELETE( pkBuff );

}

void On_EVENT_CHANGE_PET_NAME_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHANGE_PET_NAME_ACK );

    Result_ReportPetNickName = kRecv;

    SAFE_DELETE( pkBuff );
}

// 유저 강제 선행 플레이
void On_EVENT_PRE_COMPLETE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );

    //kRecv = 0; // 정상
    //kRecv = 1; // 시스템이 동작 중이지 않음.
    //kRecv = 2; // 모드 리스트에 없다.
    //kRecv = 3; // 초기에 모드 셋팅하지 못했다.

    SAFE_DELETE( pkBuff );
}

// 인벤토리 늘리는 아이템
void On_EVENT_USE_INVENTORY_EXTEND_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KExtendItem );

    //kRecv.m_nOK = 0; // 성공
    //kRecv.m_nOK = 1; // 아이템 아이디가 다름
    //kRecv.m_nOK = 2; // 아이템을 보유하고 있지 않음
    //kRecv.m_nOK = 3; // 아이템 수량이 부족
    //kRecv.m_nOK = 4; // 더이상 인벤토리를 확장할수 없음
    //kRecv.m_nOK = 5; // 해당 유저가 존재하지 않음

    Result_ExtendInventory = kRecv.m_nOK;

    if( kRecv.m_nOK == 0 ) // 성공
    {
        g_kGlobalValue.m_iInvenCapacity = kRecv.m_nInvenCapacity; // 인벤 용량

        g_kGlobalValue.m_kUserInfo.GetCurrentChar().m_nInvenCapacity = kRecv.m_nInvenCapacity;
        g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar().m_nInvenCapacity = kRecv.m_nInvenCapacity;
    }

    SAFE_DELETE( pkBuff );
}

// Verify Account Ack 를 받기 전에 인벤토리 퍼주는 패킷.
void On_EVENT_VERIFY_INVENTORY_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_VERIFY_INVENTORY_NOT );

    // 2007.03.15 wony
    // 원래 VerifyAccountAck 에서 아래일을 했으나..
    // 인벤토리의 용량을 크게 해 주는 아이템이 나옴으로써..
    // 아이템퍼주는 패킷을 따로 빼기로 했다..

    // 인벤토리를 받아온다
    if ( kRecv.m_nCurrentIndex == 1 ) {
        g_pItemMgr->m_kInventory.ClearItem();
        g_kGlobalValue.SetInventoryPacketMaxCnt(kRecv.m_nMaxIndex);
    }


    g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecInv, true );

    if ( g_kGlobalValue.IsSuccessRecvInventoryPacket(kRecv.m_nCurrentIndex) ) {
        g_kGlobalValue.SetInventoryPacketMaxCnt(0);
        Result_InventoryRecvData = 0;

//         //  코디 합성 관련 임시 동작
//         {
//             std::vector<GCITEMID> vecCoordiID;
//             std::vector<GCITEMID> vecCoordiID2;
// 
//             vecCoordiID.push_back( 75459 );
//             vecCoordiID.push_back( 75460 );
//             vecCoordiID.push_back( 75461 );
//             vecCoordiID.push_back( 75463 );
//             vecCoordiID.push_back( 75465 );
//             vecCoordiID.push_back( 75466 );
//             vecCoordiID.push_back( 75467 );
//             vecCoordiID.push_back( 75469 );
// 
//             vecCoordiID2.push_back( 69637 );
//             vecCoordiID2.push_back( 69638 );
//             vecCoordiID2.push_back( 69639 );
//             vecCoordiID2.push_back( 69640 );
//             vecCoordiID2.push_back( 71076 );
//             vecCoordiID2.push_back( 71077 );
//             vecCoordiID2.push_back( 71078 );
//             vecCoordiID2.push_back( 71079 );
// 
//             for ( int i = 0; i < (int) vecCoordiID.size(); ++i ) 
//             {
//                 KItem* kItem = g_pItemMgr->GetInventoryItemFromID( vecCoordiID[i] );
//                 if ( kItem ) 
//                 {
//                     kItem->m_DesignCoordiID = vecCoordiID2[i];
//                 }
//             }
//         }
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_REPETITION_PROVIDE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_QUERY_INVENTORY_INFO_ACK );

    bool bRepetitionEvent = false;
    DWORD dwItemID = 0;
    int iItemSize = 0;

    if( !kRecv.m_vecInv.empty() )
    {
        bRepetitionEvent = true;
        dwItemID = kRecv.m_vecInv[0].m_ItemID / 10;
    }

    if( bRepetitionEvent )
    {
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecInv, true );

        iItemSize = (int)kRecv.m_vecInv.size();

        GCItem* kItem = g_MyD3D->m_kItemMgr.GetItemData( dwItemID );
        if( kItem != NULL )
        {
            // 축하합니다 무슨무슨 아이템을 받았습니다.. 라는 메세지
            std::wstring str = g_pkStrLoader->GetString( STR_ID_REPETITION_MESSAGE2 ) + L"\n";
            str += g_pkStrLoader->GetReplacedString( STR_ID_REPETITION_MESSAGE3, "l", kItem->strItemName );
            if( iItemSize > 1 )
                str += g_pkStrLoader->GetReplacedString( STR_ID_REPETITION_MESSAGE4, "i", ( iItemSize - 1 ) );
            str += L"\n";
            str += g_pkStrLoader->GetString( STR_ID_REPETITION_MESSAGE5 );

            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_REPETITION_EVENT_BOX,
                str,
                g_pkStrLoader->GetString( STR_ID_REPETITION_MESSAGE1 ),
                KGCUIScene::GC_MBOX_USE_NORMAL, dwItemID*10, kRecv.m_vecInv[0].m_ItemUID );
        }
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_FORCE_CHANGE_ROOMUSER_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    // 방장에게 오는것...
    // 성공 실패 반드시 확인..
    KSerializer ks;
    ACK_DESERIALIZE( KForceChangeRoomUserInfo );

    if( kRecv.m_nOK != 0 ) // 실패.........
    {
        switch( kRecv.m_nOK )
        {
        case -1:
            {
                ASSERT(!"m_ucChangeType이 올바르지 않음");
                ExitWithHackAlert( L"Invalid m_ucChangeType" );
            }
            break;
        }
    }

    switch( kRecv.m_ucChangeType )
    {
    case KForceChangeRoomUserInfo::FRUI_READY:
        {
            if ( g_kGlobalValue.m_kUserInfo.nUserState == GC_RUS_READY )
            {
                g_kGlobalValue.m_kUserInfo.nUserState = GC_RUS_WAIT;

            }

            for( int i = 0; i < MAX_PLAYER_NUM; ++i )
            {
                if ( g_MyD3D->MyPlayer[i]->m_kUserInfo.nUserState == GC_RUS_READY )
                {
                    g_MyD3D->MyPlayer[i]->m_kUserInfo.nUserState = GC_RUS_WAIT;

                }
            }
            g_pkUIScene->RoomSceneUpdateData();
            g_pkUIScene->EnableMessageBox( !kRecv.m_bReady );
        }
        break;
    default:
        break;
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_FORCE_CHANGE_ROOMUSER_INFO_BROAD( WPARAM wParam, LPARAM lParam )
{
    // 방원 에게 오는거..
    // 실패가 없어요..
    // 그러나 체크 하세요..
    KSerializer ks;
    ACK_DESERIALIZE( KForceChangeRoomUserInfo );

    if( kRecv.m_nOK != 0 ) // 실패.........
    {
        switch( kRecv.m_nOK )
        {
        case -1:
            {
                ASSERT(!"m_ucChangeType이 올바르지 않음");
                ExitWithHackAlert( L"Invalid m_ucChangeType" );
            }
            break;
        }
    }

    switch( kRecv.m_ucChangeType )
    {
    case KForceChangeRoomUserInfo::FRUI_READY:
        {
            if ( g_kGlobalValue.m_kUserInfo.nUserState == GC_RUS_READY )
            {
                g_kGlobalValue.m_kUserInfo.nUserState = GC_RUS_WAIT;

            }

            for( int i = 0; i < MAX_PLAYER_NUM; ++i )
            {
                if ( g_MyD3D->MyPlayer[i]->m_kUserInfo.nUserState == GC_RUS_READY )
                {
                    g_MyD3D->MyPlayer[i]->m_kUserInfo.nUserState = GC_RUS_WAIT;

                }
            }

            g_pkUIScene->RoomSceneUpdateData();
            g_pkUIScene->EnableMessageBox( !kRecv.m_bReady );
        }
        break;
    default:
        break;
    }

    SAFE_DELETE( pkBuff );
}

// 펫 진화 관련
void On_EVENT_CHECK_TRANSFORMATION_PET_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHECK_TRANSFORMATION_PET_ACK );

    Result_TransformationPet = kRecv.m_nOK;

    if( kRecv.m_nOK == 0 )
    {
        GCITEMUID dwPetUID =   kRecv.m_dwPetUID;
        DWORD dwUseItemID = kRecv.m_itemID / 10;

        switch( kRecv.m_ePTT ) // 0 - 진화
        {
        case 0:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_PET_NAME_SELECT, kRecv.m_strOriginName, kRecv.m_strNewName,
                KGCUIScene::GC_MBOX_USE_EVOLUTION_PET_NAME_SELECT, dwPetUID, dwUseItemID, true );
            break;
        case 1:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_PET_NAME_SELECT, kRecv.m_strOriginName, kRecv.m_strNewName,
                KGCUIScene::GC_MBOX_USE_DEVOLUTION_PET_NAME_SELECT, dwPetUID, dwUseItemID, true );
            break;
        }
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_TRANSFORMATION_PET_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_TRANSFORMATION_PET_ACK );

    Result_TransformationPet = kRecv.m_nOK;

    if( kRecv.m_nOK == 0 )
    {
        KPetInfo kPetInfo = kRecv.m_kPetInfo;
        kPetInfo.m_dwUID =  kRecv.m_kPetInfo.m_dwUID;
        kPetInfo.m_dwID = kRecv.m_kPetInfo.m_dwID / 10;

        kPetInfo.m_kCostume.m_dwID = 0;
        kPetInfo.m_kCostume.m_dwUID = 0;

        GCITEMUID dwPetUID = kPetInfo.m_dwUID;
        // 현재 진화 한 녀석를 모두 장착해제 시켜준다
        // 펫이 끼고 있는 아이템이라든지.. 그런문제 때문에..
        g_MyD3D->m_TempPlayer.UnEquipPetforUID( dwPetUID );
        g_MyD3D->m_TempPlayer.UpdateGlobalUserInfo();

        // 펫 정보를 업데이트 한다
        g_MyD3D->m_mapPetInfo[ dwPetUID ] = kPetInfo;

        // 사용한 진화 마법서를 하나 깍아준다
        std::vector<GCITEMUID> vecItemUID;
        g_pItemMgr->DecInventoryDurationItemForItemID( kRecv.m_dwItemID / 10 , &vecItemUID );

        // 진화 시 보상 아이템을 받았을 경우..
        std::wstring strMsg;
        if( kRecv.m_vecRewardItem.size() > 0 )
        {
            for(int i = 0; i < (int)kRecv.m_vecRewardItem.size(); i++ )
            {
                KItem kReward = kRecv.m_vecRewardItem[i];
                GCItem* kItem = g_pItemMgr->GetItemData( kReward.m_ItemID / 10 );
                CONTINUE_NIL( kItem );

                if( kReward.m_nCount == KItem::UNLIMITED_ITEM )
                {
                    strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE1, "l", kItem->strItemName );
                }
                else
                {
                    KItem* pkItem = g_pItemMgr->m_kInventory.FindItemByItemID( kReward.m_ItemID / 10 );
                    
                    DWORD dwReceivedCount = kReward.m_nCount;
                    if( pkItem != NULL )
                    {
                        dwReceivedCount -= pkItem->m_nCount;
                    }

#if defined(NATION_USA)
                    strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE1, "l", kItem->strItemName );
#else
                    strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE2, "li", kItem->strItemName, (int)dwReceivedCount );
#endif
                }


                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, L"" );
            }

            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewardItem, true );
        }

        // 진화한 녀석의 프리뷰를 보여준다
        g_pkUIScene->MessageBox( KGCUIScene::GC_PET_PREVIEW );
        g_pkUIScene->m_pkPetPreview->SetMyInfoPreview();
        g_pkUIScene->m_pkPetPreview->SetDescState( 2 );
        g_pkUIScene->m_pkPetPreview->SetNowPet( g_kGlobalValue.GetPetIDFromItemID( kPetInfo.m_dwID ), kPetInfo.m_cPromotion ); // 처음생성되는 놈이니 진화레벨은 0 이겠지..
        g_pkUIScene->m_pkPetPreview->m_pkPetMsg->SetMentState( PET_MENT_FIRST_MEETING );

        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_LOAD_POINTSYSTEM_INFO_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KCalendarInfo);

    if (kRecv.m_nOK == 0)
    {
        g_kGlobalValue.m_bExistCalendar = true;
        g_kGlobalValue.SetCalendarInfo(kRecv);
    }
    else
    {
        g_kGlobalValue.m_bExistCalendar = false;
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK);
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_LOAD_CALENDAR_ERROR), strTemp);
    }

    SAFE_DELETE(pkBuff);
}

void On_EVENT_GET_CURRENT_POINT_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(int);

    g_kGlobalValue.m_iGCPoint = kRecv;

    SAFE_DELETE(pkBuff);
}

void On_EVENT_SEALLING_CALENDAR_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_SEALLING_CALENDAR_ACK);

    Result_SeallingCalendar = kRecv.m_nOK;

    if (kRecv.m_nOK == 0)
    {
        int iGetPoint = kRecv.m_nIncGCPoint;
        g_kGlobalValue.m_iGCPoint = kRecv.m_nGCPoint;

        std::vector<KDailyInfo>& vecDailyInfo = g_kGlobalValue.m_mapCalendar[kRecv.m_kDailyInfo.m_cWeekID];

        for (int i = 0; i < (int)vecDailyInfo.size(); ++i)
        {
            if (vecDailyInfo[i].m_kDate == kRecv.m_kDailyInfo.m_kDate)
            {
                vecDailyInfo[i] = kRecv.m_kDailyInfo;
            }
        }

#if !defined(NATION_IDN)
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK,
            g_pkStrLoader->GetReplacedString(STR_ID_GET_STAMP, "mii", kRecv.m_kDailyInfo.m_kDate.m_cMonth, kRecv.m_kDailyInfo.m_kDate.m_cDay, iGetPoint),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
#else
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK,
            g_pkStrLoader->GetReplacedString(STR_ID_GET_STAMP, "imi", kRecv.m_kDailyInfo.m_kDate.m_cDay, kRecv.m_kDailyInfo.m_kDate.m_cMonth, iGetPoint),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
#endif

    }

    SAFE_DELETE(pkBuff);
}

void On_EVENT_MONTHLY_ATTEND_NOT(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_MONTHLY_ATTEND_NOT);

    if (kRecv.m_nOK == 0)
    {
        g_kGlobalValue.m_vecReservedReward = kRecv.m_vecReservedReward;

        std::vector<KItem>::iterator vit;
        for (vit = kRecv.m_vecMonthlyRewardList.begin(); vit != kRecv.m_vecMonthlyRewardList.end(); ++vit)
        {
            vit->m_ItemID /= 10;
        }

        g_MyD3D->m_kItemMgr.SetPerfectMonthItemList(kRecv.m_vecMonthlyRewardList);
        std::map<char, std::vector<KDailyInfo> >::iterator mit;
        for (mit = g_kGlobalValue.m_mapCalendar.begin(); mit != g_kGlobalValue.m_mapCalendar.end(); ++mit)
        {
            std::vector<KDailyInfo>& vecDailyInfo = mit->second;
            for (int i = 0; i < (int)vecDailyInfo.size(); ++i)
            {
                vecDailyInfo[i].m_cSealType |= ST_HEA;
            }
        }
    }

    SAFE_DELETE(pkBuff);
}

void On_EVENT_ACC_TIME_NOT(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_ACC_TIME_NOT);

    bool bRefresh = false;

    g_kGlobalValue.m_dwAccTimeNot = timeGetTime();
    if (kRecv.m_nAccTime >= g_kGlobalValue.m_iAttendTime)
    {
        std::map<char, std::vector<KDailyInfo> >::iterator mit;

        for (mit = g_kGlobalValue.m_mapCalendar.begin(); mit != g_kGlobalValue.m_mapCalendar.end(); ++mit)
        {
            std::vector<KDailyInfo>& vecDailyInfo = mit->second;

            for (int i = 0; i < (int)vecDailyInfo.size(); ++i)
            {
                if (vecDailyInfo[i].m_kDate == g_kGlobalValue.m_kToday)
                {
                    if (vecDailyInfo[i].m_cSealType == ST_TRI)
                        vecDailyInfo[i].m_cSealType = ST_SQU;
                }
            }
        }
        bRefresh = true;
    }
    if (!(g_kGlobalValue.m_kToday == kRecv.m_kToday))
    {
        bRefresh = true;
#ifdef CALENDAR_RECOMMAND
        g_pkUIScene->m_pkAttendanceInfoMsg->SetExtraValue2(0);
#endif
    }
    if (bRefresh)
    {
        if (g_pkUIScene->m_pkAttendanceCalendar->IsRenderOn())
            g_pkUIScene->m_pkAttendanceCalendar->SetCalendar();
    }
    g_kGlobalValue.m_kToday = kRecv.m_kToday;
    g_kGlobalValue.m_iPlayTime = kRecv.m_nAccTime;
    g_kGlobalValue.m_tmServerTime += CTimeSpan(0, 0, 1, 0);
    if (g_pkUIScene->m_pkBingo) {
        g_pkUIScene->m_pkBingo->SetAccPlayerTime(std::max<int>(g_pkUIScene->m_pkBingo->GetAccPlayerTime() - 1, 0));
    }

#if defined( EVENT_ITEM_CHANGE )
    for (std::set<CTime>::iterator itor = g_pItemMgr->m_setApplyRefreshEventTimeChange.begin(); itor != g_pItemMgr->m_setApplyRefreshEventTimeChange.end(); ++itor)
    {
        if (g_kGlobalValue.m_tmServerTime >= *itor) {
            g_pBrowser->DestroyWin();
            g_pkUIScene->m_pkCashShopScene->RefreshtemBox();
            g_pkUIScene->m_pkGPShopScene->RefreshtemBox();
            g_pItemMgr->m_setApplyRefreshEventTimeChange.erase(itor++);
        }
}
#endif

#if defined( EVENT_VIEW_ITEM )
    for (std::set<CTime>::iterator itor = g_pItemMgr->m_setApplyRefreshEventTimeView.begin(); itor != g_pItemMgr->m_setApplyRefreshEventTimeView.end(); ++itor)
    {
        if (g_kGlobalValue.m_tmServerTime >= *itor) {
            DWORD dwReqGoodsID = g_pBrowser->GetReqGoodsID();
            for (std::vector< KGCItemManager::EVENTITEMVIEW >::iterator itorVec = g_pItemMgr->m_vecEventItemView.begin(); itorVec != g_pItemMgr->m_vecEventItemView.end(); ++itorVec)
            {
                if (itorVec->dwViewItem == dwReqGoodsID) {
                    g_pBrowser->SetReqGoodsID(-1);
                    g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_END_EVENT));
                    g_pBrowser->DestroyWin();
                    break;
                }
            }

            g_pItemMgr->UpdateShopItemList();
            g_pkUIScene->m_pkCashShopScene->RefreshtemBox();
            g_pkUIScene->m_pkGPShopScene->RefreshtemBox();
            g_pItemMgr->m_setApplyRefreshEventTimeView.erase(itor++);
        }
    }
#endif

    SAFE_DELETE(pkBuff);
}

void On_EVENT_WEEKLY_ATTEND_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_WEEKLY_ATTEND_ACK);
    Result_WeeklyAttend = kRecv.m_nOK;
    Result_GetRewardItem = kRecv.m_nOK;
    switch (kRecv.m_nOK)
    {
    case 0:
    {
        int iGetPoint = kRecv.m_nIncGCPoint;
        g_kGlobalValue.m_iGCPoint = kRecv.m_nGCPoint;
        std::vector<KDailyInfo>& vecDailyInfo = g_kGlobalValue.m_mapCalendar[kRecv.m_cWeekID];
        for (int i = 0; i < (int)vecDailyInfo.size(); ++i)
        {
            vecDailyInfo[i].m_cSealType |= ST_STA;
        }
        g_pItemMgr->m_kInventory.AddItemList(kRecv.m_vecInv, true);

#if defined( NATION_KOREA )
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_PERFECT_WEEK, "iii", kRecv.m_cMonth, kRecv.m_cWeekID, iGetPoint),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
#else
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_PERFECT_WEEK, "mii", kRecv.m_cMonth, kRecv.m_cWeekID, iGetPoint),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
#endif
        if (!kRecv.m_vecInv.empty())
        {
            GCITEMID itemID = 0;
            g_pkUIScene->m_pkTreaureItemBox->SetTitle(g_pkStrLoader->GetString(STR_ID_WEEKLY_ATTENDANCE_REWARD));
            for (int i = 0; i < (int)kRecv.m_vecInv.size(); i++) {
                itemID = kRecv.m_vecInv[i].m_ItemID;
                g_pkUIScene->m_pkTreaureItemBox->SetTitle(g_pkStrLoader->GetString(STR_ID_WEEKLY_ATTENDANCE_REWARD));
                g_pkUIScene->m_pkTreaureItemBox->SetItem(itemID);
                g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, itemID, 0, false, true);
            }
        }
        g_pkUIScene->DeleteWaitMsgBox(KGCUIScene::GC_MBOX_PERFECT_ATTENDANCE);
    }
    break;
    case 1:
        break;
    case 2:
        break;
    case 3:
        break;
    case 4:
        break;
    case 5:
        break;
    case 6:
        break;
    case 7:
        break;
    default:
        break;
    }

    SAFE_DELETE(pkBuff);
}

void On_EVENT_LOAD_NEW_CALENDAR_NOT(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KCalendarInfo);

    if (kRecv.m_nOK == 0)
    {
        g_kGlobalValue.m_bExistCalendar = true;
        g_kGlobalValue.SetCalendarInfo(kRecv);
        if (g_pkUIScene->m_pkAttendanceCalendar->IsRenderOn())
            g_pkUIScene->m_pkAttendanceCalendar->SetCalendar();
    }
    else
    {
        g_kGlobalValue.m_bExistCalendar = false;
        if (g_pkUIScene->m_pkAttendanceCalendar->IsRenderOn())
            g_pkUIScene->m_pkAttendanceCalendar->CloseCalendar();
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK);
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_LOAD_CALENDAR_ERROR), strTemp);
    }

    SAFE_DELETE(pkBuff);
}

void On_EVENT_MONTHLY_ATTEND_REWARD_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_MONTHLY_ATTEND_REWARD_ACK);

    Result_GetRewardItem = kRecv.m_nOK;

    if (kRecv.m_nOK == 0)
    {
        OnItemReceive(kRecv.m_vecInv);
        g_kGlobalValue.m_vecReservedReward = kRecv.m_vecReservedReward;
        g_pkUIScene->DeleteWaitMsgBox(KGCUIScene::GC_MBOX_PERFECT_ATTENDANCE);
        if (g_MyD3D->m_pStateMachine->IsStateMyInfo())
        {
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        }
    }

    SAFE_DELETE(pkBuff);
}

void On_EVENT_MONTHLY_ATTEND_REWARD_LIST_NOT(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(std::vector<KSimpleDate>);
    g_kGlobalValue.m_vecReservedReward = kRecv;
    SAFE_DELETE(pkBuff);
}

void On_EVENT_GET_CALENDAR_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KCalendarInfo);

    if (kRecv.m_nOK == 0)
    {
        g_kGlobalValue.m_bExistCalendar = true;
        g_kGlobalValue.SetCalendarInfo(kRecv);
    }
    else
    {
        g_kGlobalValue.m_bExistCalendar = false;
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK);
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_LOAD_CALENDAR_ERROR), strTemp);
    }

    SAFE_DELETE(pkBuff);
}

void On_EVENT_HATCHING_EGG_ACK( WPARAM wParam, LPARAM lParam ) // 알 부화
{
    //  0   성공
    //  1   펫 정보가 존재하지 않음
    //  2   알 펫이 아니라서 부화 불가능.
    //  3   부화 대상 정보가 존재하지 않음
    //  4   아이템을 보유하고 있지 않음.
    //  5   아이템 수량이 부족.
    //  6   부화 하기에 레벨이 부족함.
    //  7   해당 펫 아이템을 가지고 있지 않음
    //  8   해당 유저가 존재하지 않음
    //  9   펫 아이템이 아님..
    //  10  펫 아이템(시민권)이 없음
    //  11  부화시 새펫 봉인 카드 넣기 실패.
    //  12  \신규 생성하려는 팻이 이미 존재함
    //  13  해당 캐릭터가 존재하지 않음.
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_HATCHING_EGG_ACK );

    Result_TransformationPet = kRecv.m_nOK;

    //KItemInfo                           m_kPetCard;        // 펫 봉인 카드

    if( Result_TransformationPet == 0 )
    {
        // 옛날 펫..
        KPetInfo kOldPetInfo = kRecv.m_kOldPetInfo;
        kOldPetInfo.m_dwUID =  kRecv.m_kOldPetInfo.m_dwUID;
        kOldPetInfo.m_dwID = kRecv.m_kOldPetInfo.m_dwID / 10;
        g_pItemMgr->m_kInventory.RemoveItem( kOldPetInfo.m_dwUID );

        // 현재 부화 한 녀석를 모두 장착해제 시켜준다
        GCITEMUID dwOldPetUID = kOldPetInfo.m_dwUID;
        g_MyD3D->m_TempPlayer.UnEquipPetforUID( dwOldPetUID );
        g_MyD3D->m_TempPlayer.UpdateGlobalUserInfo();

        // 옛날의 알 펫 정보는 삭제한다
        std::map<GCITEMUID, KPetInfo>::iterator mit = g_MyD3D->m_mapPetInfo.find( dwOldPetUID );
        if( mit != g_MyD3D->m_mapPetInfo.end() )
        {
            g_MyD3D->m_mapPetInfo.erase( mit );
        }
        else
        {           
            ASSERT( !"Pet정보가 없다" );
        }

        // 새 펫..
        KPetInfo kNewPetInfo = kRecv.m_kPetInfo;
        kNewPetInfo.m_dwUID =  kRecv.m_kPetInfo.m_dwUID;
        kNewPetInfo.m_dwID = kRecv.m_kPetInfo.m_dwID / 10;

        // 새 펫 정보를 집어넣는다
        GCITEMUID dwNewPetUID = kNewPetInfo.m_dwUID;
        g_MyD3D->m_mapPetInfo[ dwNewPetUID ] = kNewPetInfo;

        // 사용한 진화 마법서를 하나 깍아준다
        std::vector<GCITEMUID> vecItemUID;
        g_pItemMgr->DecInventoryDurationItemForItemID( kRecv.m_dwHatchingID / 10 , &vecItemUID );

        // 부화 시 아이템을 준다면?
        std::wstring strMsg;

        for(int i = 0; i < (int)kRecv.m_vecItem.size(); i++ )
        {
            KItem kReward = kRecv.m_vecItem[i];
            kReward.m_ItemID /= 10;
            GCItem* kItem = g_pItemMgr->GetItemData( kRecv.m_vecItem[i].m_ItemID / 10 );
            CONTINUE_NIL( kItem );

            strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE1, "l", kItem->strItemName );
            
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, L"" );
        }
        // 이번에 받은 새로운 펫 카드도 넣어준다
        g_pItemMgr->m_kInventory.AddItem( kRecv.m_kPetCard , true);
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);


        // 부화한 녀석의 프리뷰를 보여준다
        g_pkUIScene->MessageBox( KGCUIScene::GC_PET_PREVIEW );
        g_pkUIScene->m_pkPetPreview->SetMyInfoPreview();
        g_pkUIScene->m_pkPetPreview->SetDescState( 2 ); // First Meeting
        g_pkUIScene->m_pkPetPreview->SetNowPet( g_kGlobalValue.GetPetIDFromItemID( kNewPetInfo.m_dwID ), kNewPetInfo.m_cPromotion );
        g_pkUIScene->m_pkPetPreview->m_pkPetMsg->SetMentState( PET_MENT_FIRST_MEETING );

        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_BUY_GCPOINT_ITEM_ACK( WPARAM wParam, LPARAM lParam )// 포인트 제품 구매..
{
    // 0(성공),
    // -1 (유저가 존재하지 않음),
    // -2 (아이템 정보 테이블에 아이템 정보가 없음),
    // -3 (포인트백 정보가 없음),
    // -4 (포인트백 아이템 정보 테이블에 아이템 정보가 없음),
    // -5 (판매중이 아님)
    // -6 (포인트가 부족함)
    // -7 아이템 받아 오는중 오류.
    // -8 아이템 타입 정보가 올바르지 않음.
    // -9 일일 구매회수 제한에 걸림
    //-98    작업중인 패킷
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BUY_GCPOINT_ITEM_ACK );

    Result_Buy = kRecv.m_nOK;

    if( kRecv.m_nOK == 0 )
    {
        g_kGlobalValue.m_iGCPoint = kRecv.m_nGCPoint;

        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);
    }
    else if( kRecv.m_nOK == -98)
    {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PACKET_DELAY ));
    }
    else
    {
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp );
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_BUY_VIRTUAL_CASH_ACK( WPARAM wParam, LPARAM lParam )// 포인트 제품 구매..
{
    /*
    kPacket_.m_nOK, 0     // 성공
    kPacket_.m_nOK, 1     // 가격 정보가 존재하지 않음  
    kPacket_.m_nOK, 2     // 가상캐쉬 정보가 존재하지 않거나 해당 아이템을 구매할 캐쉬량이 부족함  
    kPacket_.m_nOK, 3     // 유저 정보가 존재하지 않음.
    kPacket_.m_nOK, 4     // 아이템 목록이 없음.
    kPacket_.m_nOK, 5     // 가상캐쉬로 패키지 아이템 구매 불가
    kPacket_.m_nOK, 6     // 가상캐쉬 아이템 가격이 잔액을 초과
    kPacket_.m_nOK, 7     // 구매 횟수 제한에 걸림.
    kPacket_.m_nOK, 8     // 가상캐시로 구매하는 아이템이 아님.
    kPacket_.m_nOK, 9     // 아이템 구매 시도 실패.
    kPacket_.m_nOK, 10    // 선물받을 닉네임이 비어있음.
    kPacket_.m_nOK, 11    // 선물받을 대상이 존재하지 않음.
    kPacket_.m_nOK, 12    // 선물받을 대상이 보낼 대상과 동일함.
    kPacket_.m_nOK, -98   // 아직 처리중인 작업입니다.
    */

    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BUY_VIRTUAL_CASH_ACK );

    Result_Buy_VirtualCashItem = kRecv.m_nOK;

    if( kRecv.m_nOK == 0 )
    {
        g_kGlobalValue.m_dwVirtualCash = kRecv.m_kVirtualCashInfo.m_dwCashPoint;
        START_LOG( cout, kRecv.m_kVirtualCashInfo.m_dwCashPoint );
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecInv , true);
        g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
        g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();

        // 슬롯 아이템 구입 체크
        if( g_MyD3D->m_pStateMachine->GetState() == GS_CHAR_SELECT )
        {
            g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_BUT_ADD_SLOT_ITEM ) );
        }

        if( kRecv.m_bPremium )
        {
            g_kGlobalValue.m_kUserInfo.dwPremium = KPremiumInfo::TYPE_GCCLUB;
        }

        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();

        if ( g_pkUIScene->m_pkRickoonTornado->GetCreateComplete() ) {
            g_pkUIScene->m_pkRickoonTornado->SetCoinCount();
        }

        if (g_pkUIScene->m_pkSphinxDlg->GetCreateComplete()) {
            g_pkUIScene->m_pkSphinxDlg->UpdateCoin();
        }

        if ( g_pkUIScene->m_pkCoordiComposeDlg && g_pkUIScene->m_pkCoordiComposeDlg->IsWndState( KD3DWnd::D3DWS_ENABLED ) )
            g_pkUIScene->m_pkCoordiComposeDlg->UpdateItemCount();

        if ( g_pkUIScene->m_pkCoordiUpgradeDlg && g_pkUIScene->m_pkCoordiUpgradeDlg->IsWndState( KD3DWnd::D3DWS_ENABLED ) )
            g_pkUIScene->m_pkCoordiUpgradeDlg->UpdateItemCount();

#if defined (USE_AGIT_SYSTEM)
        SiKGCAgitGameManager()->BuyDummyObject();
        SiKGCAgitGameManager()->RefreshInvenObject();
        g_pkUIScene->m_pkAgitShop->InitAgitShop( false );
        g_pkAgitOverlayUI->UpdatePlaceCollectUI();  
#endif

#if defined( USE_VIP_POINT)
        // 가상캐쉬 구매 결과
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_BUY_CASH_ITEM_BUY_COMPLETE, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, kRecv.m_kVirtualCashInfo.m_dwDeductCashPoint, 0, true, false );
#endif
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_CURRENT_VIRTUAL_CASH_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );

    g_kGlobalValue.m_dwVirtualCash = kRecv;
    if ( g_MyD3D->m_pStateMachine->GetState() == GS_SHOP_CASH )
        g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
    if( g_MyD3D->m_pStateMachine->GetState() == GS_SHOP_GP )
        g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();
    START_LOG( cout, kRecv );

    SAFE_DELETE( pkBuff );
}

void On_EVENT_SELL_GCPOINT_ITEM_ACK( WPARAM wParam, LPARAM lParam )// 포인트 제품 판매.
{
    // 1  아이템이 존재하지 않음.
    // 2  아이템 타입 정보가 올바르지 않음
    // 3   아이템 제거 실패
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SELL_GCPOINT_ITEM_ACK );

    Result_RemovePointItem = kRecv.m_nOK;

    SAFE_DELETE( pkBuff );
}

void On_EVENT_FORCE_TRANSITION_STATE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );

    Result_ForceTransition = 0;

    if( kRecv != 0 ) // 실패
    {
        switch( kRecv )
        {
        case -1: // 상태 변경 오류
            Result_ForceTransition = 1;
            break;
        default:
            Result_ForceTransition = 2;
            break;

        }
    }
    SAFE_DELETE( pkBuff );
}
void On_EVENT_MONTHLY_REWARD_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<KItem> );

    // KItemUnit 의 데이터 중에..
    //m_iItemType;
    //m_iID;
    //m_iDuration;
    // 이 세가지만 사용한다
    std::vector<KItem>::iterator vit;
    for( vit = kRecv.begin(); vit != kRecv.end(); ++vit )
    {
        // 클라이언트에서 사용하는 값으로 바꿔줘-ㅅ-
        vit->m_ItemID /= 10;
    }

    g_MyD3D->m_kItemMgr.SetPerfectMonthItemList( kRecv );

    SAFE_DELETE( pkBuff );

}

void On_EVENT_WEEKLY_REWARD_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<KItem> );

    // 주개근 보상 아이템 리스트
    // KItemUnit 의 데이터 중에..
    //m_iItemType;
    //m_iID;
    //m_iDuration;
    // 이 세가지만 사용한다
    std::vector<KItem>::iterator vit;
    for( vit = kRecv.begin() ; vit != kRecv.end() ; ++vit  )
    {
        vit->m_ItemID /= 10;
    }
    g_MyD3D->m_kItemMgr.SetPerfectWeekItemList( kRecv );
    SAFE_DELETE( pkBuff );

}

void On_EVENT_FH_CHECK_ACCOUNT_TYPE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );

    KSingleton<KGCNewTerm>::GetInstance()->ProcessEventPacket( kRecv );

    SAFE_DELETE( pkBuff );
}

void On_EVENT_FH_RECOMMEND_REGIST_ACK( WPARAM wParam, LPARAM lParam )
{
    //추천 한것이 성공했는지 알려준다.
    //이녀석이 실패하면 쌩까볼까요?
    // -1 : 이벤트 기간 만료
    // 0 : 성공
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );
}

void On_EVENT_GCPOINT_RECOMMEND_ACK( WPARAM wParam, LPARAM lParam )// 신규유저 추천 포인트 요청
{
    KSerializer ks;
    ACK_DESERIALIZE( KOKnValue );

    KSingleton<KGCNewTerm>::GetInstance()->ProcessRecommandAck( kRecv.m_nOK, kRecv.m_nValue );

    SAFE_DELETE( pkBuff );
}

void On_EVENT_FH_RECOMMENDEE_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_FH_RECOMMENDEE_INFO_ACK );
    //kRecv.m_nRecomCount; //추천 받은 카운트
    // 이전에 이 패킷을 받은 이후 부터 추천을 추가적으로 더 받았는지 확인 가능하고
    // 선물 받았는지 확인 가능하다.

    //ID,   true/false
    //0,    '추천이 있었삼'
    //1,    '1추천 선물 받음'
    //2,    '5추천 선물 받음'
    //3,    '10추천 선물 받음'
    //4,    '20추천 선물 받음'
    //kRecv.m_vecRewardList;

    SAFE_DELETE( pkBuff );
}

void On_EVENT_RESET_WIN_LOSE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KResetWinLoseData );
    SAFE_DELETE( pkBuff );

    //  0 성공
    //  1 승률 초기화 아이템이 아님니다.
    //  2 아이템과 캐릭터의 쌍이 맞지 않음.
    //  3 승률 초기화 아이템을 보유하고 있지 않습니다.
    //  4 캐릭터 정보가 없습니다.
    //  5 해당 유저가 존재하지 않습니다.
    //  6 캐릭터 타입이 잘못 되었습니다.
    //  7 캐릭터테이블에 캐릭터 정보가 없습니다.
    //  8 알수 없는 오류
    // 룸이나 게임중에는 서버에서 쌩깝니다.
    Result_ResetWinLoseData = kRecv.m_nOK;

    if( kRecv.m_nOK == 0 ) // 성공!
    {
        std::vector<GCITEMUID> vecItemUID;
        g_pItemMgr->DecInventoryDurationItemForItemID( kRecv.m_ItemID / 10, &vecItemUID ); // 사용한 아이템을 하나 깍는다

        for( int i = 0; i < (int)kRecv.m_vecChar.size(); ++i )
        {
            KCharInfoVector::iterator vitChar = std::find( g_MyD3D->m_TempPlayer.m_kUserInfo.vecCharInfo.begin(),
                g_MyD3D->m_TempPlayer.m_kUserInfo.vecCharInfo.end(),
                kRecv.m_vecChar[i] );
            if ( vitChar == g_MyD3D->m_TempPlayer.m_kUserInfo.vecCharInfo.end() )
                continue;

            vitChar->iWin = 0;
            vitChar->iLose = 0;
        }

        // Jaeho 2008.01.15 전적초기화 하고 캐릭터 변경시, 전적초기화 전으로 돌아가서...
        g_MyD3D->m_TempPlayer.UpdateGlobalUserInfo();
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    }
}

void On_EVENT_CHANGE_ROOM_OPTION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KRoomOption );
    SAFE_DELETE( pkBuff );

    kRecv.m_nOK;
    // 1  방정보 변경 실패. 방장 부재
    // 2  방정보 변경 실패. 방장 또는 운영자가 아님
    // 3  방제나 비번에 금칙어 포함
    // 4  올바른 상태가 아님
    // 5  가능한 옵션이 아님

    if( kRecv.m_nOK == 0 )
    {
        g_pkUIScene->UpdateRoomTitle();
        g_pStateRoom->UpdateRoomOption();
    }

}

void On_EVENT_CHANGE_ROOM_OPTION_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KRoomOption );
    SAFE_DELETE( pkBuff );

    kRecv.m_nOK;
    kRecv.m_strRoomTitle;
    kRecv.m_strPassWord;
    kRecv.m_nDeathLimitTime;
    kRecv.m_nDeathKillCount;
    kRecv.m_bDeathMatchIntrudable;

    SiKGCRoomManager()->GetRoomInfo().bDeathMatchIntrudable = kRecv.m_bDeathMatchIntrudable;
    SiKGCRoomManager()->GetRoomInfo().bDeathMatchBalancing = kRecv.m_bDeathMatchBalancing;


    if ( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_DEATHMATCH ||
         SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_FATAL_DEATHMATCH )
    {
        KGCDeathMatch* pGamemode = (KGCDeathMatch*)g_pStateGame->GetCurGameModePtr();
        pGamemode->m_fTime = (float)kRecv.m_nDeathLimitTime;
        pGamemode->m_iGoal = kRecv.m_nDeathKillCount;
    }


    // 업데이트
    g_pStateRoom->SetRoomName( kRecv.m_strRoomTitle );
    g_pStateRoom->SetRoomPassword( kRecv.m_strPassWord );
    g_pStateRoom->UpdateRoomOption();

    if( g_pkUIScene->RoomButtonIsAutoStart() == false )
        g_pkUIScene->RoomButtonSetStartDelay( 219 );

}

void On_EVENT_LUCKYDAY_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_LUCKYDAY_NOT );

    // 0; 성공
    // 1; 럭키데이 아이템 없음
    // 2; 럭키데이 아이템 얻기 실패
    // 3; 유저가 존재하지 않음
    // 4; Count가 1보다 작음.
    // 5; 럭키데이 처리시 DB 오류.
    // 6; 럭키데이로 지급된 넷마블 파천황 캐시 쿠폰 DB작업 성공.

    // 럭키데이이다!
    if( kRecv.m_nOK == 0 
#ifdef NATION_KOREA
        || kRecv.m_nOK == 6
#endif
        )
    {
        // 유져에게 보여 줄 아이템 선택..=ㅅ= 하나만 보여주도록 지원한다..
        DWORD dwItemID = 0;
        if( !kRecv.m_vecInv.empty() )
        {
            dwItemID = kRecv.m_vecInv[0].m_ItemID / 10;
        }

        // 아이템을 인벤토리에 추가
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecInv , true);



        // 메세지박스를 띄워서 받은 아이템을 보여준다
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_LUCKY_DAY_RECEIVE_BOX, L"", L"",
            KGCUIScene::GC_MBOX_USE_NORMAL, dwItemID, 0, true, false );

        if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
        {
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        }
    }




#ifdef NATION_KOREA
        if( kRecv.m_nOK == 6)
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_COMPLETE_CASH_MISSION ), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0,
                false, true );
        }
#endif

    SAFE_DELETE( pkBuff );
}

void On_EVENT_WRONG_STATE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );

    g_MyD3D->m_pStateMachine->GoState( GS_SERVER, false );
    g_MyD3D->m_pStateMachine->JumpToSafeState( GS_SERVER );

    SAFE_DELETE( pkBuff );
}

void On_EVENT_YAHOO_BENEFIT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KInven_GP );

    // 사용하지 않겠어요..
    kRecv.m_nOK; // 여기에서 이녀석은 무시해도 됩니다.

    // GP와 받은 아이템들을 갱신해 준다.
    g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( g_kGlobalValue.GetCurrentCharacterGP() + kRecv.m_nGP );
    g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);

    // 메세지 띄워준다!
    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, kRecv.m_strComment );

    if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
    {
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    }

    SAFE_DELETE( pkBuff );
}


void On_EVENT_MSG_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::wstring );
    SAFE_DELETE( pkBuff );

    kRecv; // 여기에 들어 있음...
    if( g_pkUIScene != NULL )
    {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
            kRecv,
            L"" );
    }


}

void On_EVENT_GET_NASTY_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GET_NASTY_INFO_NOT );
    SAFE_DELETE( pkBuff );

    g_kGlobalValue.m_vecHackCount = kRecv.m_vecHackCount; // 최근 일주일 정보만 들어 있습니다.
    g_kGlobalValue.m_iReportedCount = kRecv.m_nReported;    // 최근 일주일간 신고 당한 회수.
    g_kGlobalValue.m_iReportAvailableCount = kRecv.m_nReport;      // 오늘 신고 가능한 횟수.
}

// 1  이미 신고 횟수 초과
// 2  신고 대상이 존재하지 않음
// 3  신고 타입이 등록된 타입이 아님
// 4  신고한 유저 정보 없음
// 5  해당 신고 타입이 없음
// 6  신고당한 유저 정보 없음
void On_EVENT_REPORT_USER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_REPORT_USER_ACK );
    SAFE_DELETE( pkBuff );

    switch( kRecv.m_nOK )
    {
    case 0:
        g_pkChatManager->AddChatMsg( g_pkStrLoader->GetString( STR_ID_FAIRPLAY_REPORT17 ), KGCChatManager::CHAT_TYPE_ALERT );
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_FAIRPLAY_REPORT11) );
        SiGCPairPlaySystem()->ClearReportDatas();
        return;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_FAIRPLAY_REPORT12, "i", kRecv.m_nOK ) );
        SiGCPairPlaySystem()->ClearReportDatas();
        return;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_FAIRPLAY_REPORT13, "i", kRecv.m_nOK ) );
        SiGCPairPlaySystem()->ClearReportDatas();
        return;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_FAIRPLAY_REPORT13, "i", kRecv.m_nOK ) );
        SiGCPairPlaySystem()->ClearReportDatas();
        return;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_FAIRPLAY_REPORT13, "i", kRecv.m_nOK ) );
        SiGCPairPlaySystem()->ClearReportDatas();
        return;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_FAIRPLAY_REPORT12, "i", kRecv.m_nOK ) );
        SiGCPairPlaySystem()->ClearReportDatas();
        return;
    case -99:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_FAIRPLAY_REPORT13, "i", kRecv.m_nOK ) );
        SiGCPairPlaySystem()->ClearReportDatas();
        return;
    default:
        break;
    }

    SiGCPairPlaySystem()->SendReportData( kRecv.m_dwSerialNum );
    g_kGlobalValue.m_iReportAvailableCount = kRecv.m_nCount;
    START_LOG( cout, L"kRecv.m_nCount : " << kRecv.m_nCount );
    SiGCPairPlaySystem()->ClearReportDatas();

}

void On_EVENT_REPORT_USER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_REPORT_USER_NOT );
    SAFE_DELETE( pkBuff );

    kRecv.m_strName;    //신고한 유저
    kRecv.m_nReason;    //신고 사유
    //kRecv.m_vecUser;    //신고 당한 유저

    /* 신고 되었다는 정보를 받아, 채팅창에 띄워주던 부분 삭제 knight26h 2007.10.16
    // 본인만 글자를 출력해 준다.*/
    if (kRecv.m_strName==g_kGlobalValue.m_kUserInfo.strNickName)
    {
        g_pkChatManager->AddSystemMsg( -1, g_pkStrLoader->GetReplacedString( STR_ID_FAIRPLAY_REPORT4, "ll", kRecv.m_strName, kRecv.m_strUser ) );
    }
}

void On_EVENT_CHATTING_EVENT_MSG_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KChatEventInfo );
    SAFE_DELETE( pkBuff );

    // 타이밍은 JoinRoom, Create Room 의 ACK 직후에 옵니다.
    // 나중에 채팅중에 kRecv.m_vecEventMsg에 포함된 문자를 타이핑 하면 서버로
    // EVENT_CHATTING_EVENT_CORRECT_NOT 패킷을 보내주삼.. 보낼때 kRecv.m_nUID를 넣어서 보내주셔야 해요..
    g_kGlobalValue.m_kChattingEvent.SetData( kRecv.m_nUID, kRecv.m_vecEventMsg );
}

void On_EVENT_MANUFACTURE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MANUFACTURE_ACK );
    SAFE_DELETE( pkBuff );
    //0 성공
    //1 해당 아이템은 제작 문서가 아님.
    //2 제작 문서 아이템이 인벤토리에 존재하지 않음.
    //3 아이템 제작에 필요항 아이템이 없음_부족.
    //4 트랜잭션 에러
    //5 DB에 해당 유저가 존재하지 않음.
    //6 DB에 존재하지 않는 아이템.


    if( kRecv.m_nOK == 0 )
    {
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_recvItems , true);
        g_MyD3D->m_kItemMgr.SetDurationItem( kRecv.m_vecUsedItem );
        std::vector<GCITEMUID> vecDecItemUID;
        g_pItemMgr->DecDurationItem(  kRecv.m_delItem.m_dwUID, &vecDecItemUID );
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    }
}

void On_EVENT_BONUS_POINT_REFILL_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BONUS_POINT_REFILL_NOT );
    SAFE_DELETE( pkBuff );

    /*
    kRecv.m_cCharType: 포인트가 충전된 캐릭터 타입
    kRecv.m_kBonusPointInfo: 충전된 포인트 정보
    */

    
    // [12/18/2007] breadceo. 하루에 한번 충전되는 리필이다
    int nBaseBonusDiff = kRecv.m_kBonusPointInfo.m_nBaseBonus - SiKGCElvis()->GetBaseBonusPoint();
    int nSpBonusDiff = kRecv.m_kBonusPointInfo.m_nSpecialBonus - SiKGCElvis()->GetSpBonusPoint();

    std::wstring strBonusFill(L"");


    // 현재 캐릭터일때만 메세지 박스 띄운다. 
    if ( kRecv.m_cCharType == g_kGlobalValue.m_kUserInfo.GetCurrentCharType() )
    {
        if( nBaseBonusDiff != 0 )
        {
            strBonusFill = g_pkStrLoader->GetReplacedString( STR_ID_BONUS_REFILL , "i" , nBaseBonusDiff );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strBonusFill,
                L"" );
        }
        // [12/18/2007] breadceo. 샵에서 아이템을 사서 충전한 것
        else if( nSpBonusDiff != 0 )
        {
            strBonusFill = g_pkStrLoader->GetReplacedString( STR_ID_BONUS_REFILL , "i" , nSpBonusDiff );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strBonusFill,
                L"" );
        }

        if( g_MyD3D->m_pStateMachine->GetState() == GS_GAME )
        {
            g_MyD3D->m_kChatManager.AddSystemMsg( -1, strBonusFill, KGCChatManager::CHAT_TYPE_ADMIN );
        }
    }

    // [12/18/2007] breadceo. 변동사항 적용
    SiKGCElvis()->SetBonusPointInfo( kRecv.m_cCharType, kRecv.m_kBonusPointInfo );
    if ( g_MyD3D->m_pStateMachine->GetState() == GS_SHOP_CASH )
        g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
     if( g_MyD3D->m_pStateMachine->GetState() == GS_SHOP_GP )
        g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();
    if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
        g_pkUIScene->m_pkMyInfoScene->m_pkInfoPanel->SetUserInfo();
    
}

void On_EVENT_CHANGE_BONUS_COIN_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHANGE_BONUS_COIN_ACK );
    SAFE_DELETE( pkBuff );

    // NetError::NET_OK  성공.
    // NetError::ERR_BONUS_01  Best Character가 존재하지 않음_캐릭터 맵이 비어 있음.
    // NetError::ERR_BONUS_02  요청한 아이템은 보너스 코인 아이템이 아님.
    // NetError::ERR_BONUS_03 해당 보너스 아이템을 보유하고 있지 않음.
    // NetError::ERR_BONUS_04 보너스 코인 아이템의 수량 부족.
    // NetError::ERR_BONUS_05 더이상 보너스 포인트를 보유할수 없음.
    // NetError::ERR_BONUS_06 보너스 충전 아이템 DB 동기화 실패.
    // NetError::ERR_BONUS_07 보너스 충전 아이템 사용시 포인트 DB 동기화 실패.

    Result_Bonus_Charging = kRecv.m_nOK;
    SiKGCElvis()->SetBonusPointInfo( kRecv.m_kCurrentBonus );
    // [12/20/2007] breadceo. 성공시에만 업데이트 해준다
    if( kRecv.m_nOK == NetError::NET_OK )
    {
        g_pItemMgr->m_kInventory.RemoveItem( kRecv.m_kDurItem.m_ItemUID );
        g_pItemMgr->m_kInventory.AddItem( kRecv.m_kDurItem , true);
    }
    g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
}

void On_EVENT_USE_BONUS_POINT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_USE_BONUS_POINT_ACK );
    SAFE_DELETE( pkBuff );

    // 0이 아니면 보유 보너스 수량이 부족.
    switch( kRecv.m_nOK )
    {
    case 0:
        {
            g_MyD3D->MyPlayer[ g_MyD3D->Get_MyPlayer() ]->Rebirth();
            if(!g_kGlobalValue.m_bMUHANBonusPoint){    
                //SiKGCElvis()->IncreaseRevivalCount();
            }
            g_pStateGame->GetCurGameModePtr()->SetLastRebirthTime( ::timeGetTime() );
        }
        break;
    default:
        {
            g_MyD3D->m_kChatManager.AddSystemMsg( -1, g_pkStrLoader->GetString( STR_ID_NOT_ENOUGH_BONUS ), KGCChatManager::CHAT_TYPE_ALERT );
        }
        break;
    }

    g_pStateGame->GetCurGameModePtr()->SetRequestRebirth( false );
    // [12/18/2007] breadceo. 게임에서만 사용하기 때문에 따로 ui를 업데이트 하지 않는다.
    // 현재 보너스 정보 이녀석은 실패해도 올바른값..
    SiKGCElvis()->SetBonusPointInfo( kRecv.m_kCurrentBonus );
}



void On_EVENT_SLOT_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KQuickSlot );
    SAFE_DELETE( pkBuff );

    //kRecv.m_vecItemSlot;
    //kRecv.m_vecEmoticonSlot;

    g_MyD3D->GetMyShortCutSlot()->Clear();
    g_kGlobalValue.m_kUserInfo.kQuickSlot = kRecv;
    g_MyD3D->GetMyShortCutSlot()->initQuickSlot(kRecv);

}

void On_EVENT_CHANGE_SLOT_EQUIP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHANGE_SLOT_EQUIP_ACK );
    SAFE_DELETE( pkBuff );

    // 0  성공
    // 1  퀵슬롯 장착 변경시 이모티콘 오류.
    // 2  퀵슬롯 장착 변경시 사용 아이템 오류.
    //kRecv.m_nOK;

    //kRecv.m_kQuickSlot; // 성공 여부 상관 없이 덮어 쓰시오.
    g_kGlobalValue.m_kUserInfo.kQuickSlot = kRecv.m_kQuickSlot;
    g_MyD3D->GetMyShortCutSlot()->initQuickSlot(kRecv.m_kQuickSlot);
}

void On_EVENT_USE_QUICK_SLOT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_USE_QUICK_SLOT_ACK );
    SAFE_DELETE( pkBuff );

    // 0 성공
    // 1 사용할려는 슬롯이 슬롯에 등록되어 있지 않음.
    // 2 사용할려는 슬롯 아이템 정보와, 등록된 아이템 정보가 같지 않음.
    // 3 사용할려는 슬롯 아이템을 보유하고 있지 않음.
    // 4 사용할려는 슬롯 아이템타입이 옳지 않음.
    //kRecv.m_nOK;
    //kRecv.m_nSlotType;
    //kRecv.m_kSlotData;

    DWORD dwItemID = kRecv.m_kSlotData.m_kItem.m_dwID;

    switch( kRecv.m_nOK )
    {
    case 0:
        g_MyD3D->MyPlayer[ g_MyD3D->Get_MyPlayer() ]->AddControlInfoPotionCount( kRecv.m_nPositionType );
        break;
    }
}

void On_EVENT_PREMIUM_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( USER_PREMIUM_INFO ); 
    SAFE_DELETE( pkBuff );

    USER_PREMIUM_INFO::iterator vit;
    for( vit = kRecv.begin(); vit != kRecv.end(); ++vit )
    {
        for( int i = 0; i < MAX_PLAYER_NUM; ++i )
        {
            if( g_MyD3D->MyPlayer[i]->m_kUserInfo.bLive == false )
                continue;

            if( g_MyD3D->MyPlayer[i]->m_kUserInfo.dwUID == vit->first){
                g_MyD3D->MyPlayer[i]->m_kUserInfo.dwPremium = vit->second.m_dwPremiumType;
            }
        }
    }
}
void On_EVENT_QUICKSLOT_UPDATE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_QUICKSLOT_UPDATE_NOT );
    SAFE_DELETE( pkBuff );

    // 방안에서 퀵슬로 변경이 있었을때..
    //  kRecv.m_strLogin;
    // 	kRecv.m_kQuickSlot;

    for( int i = 0; i< MAX_PLAYER_NUM; ++i )
    {
        if (g_MyD3D->MyPlayer[i] != g_MyD3D->GetMyPlayer()) {
            if (boost::iequals(g_MyD3D->MyPlayer[i]->m_kUserInfo.strLogin, kRecv.m_strLogin))
            {
                g_MyD3D->MyPlayer[i]->m_kUserInfo.kQuickSlot = kRecv.m_kQuickSlot;
                break;
            }
        }
    }
}

void On_EVENT_INDIGO_RANK_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<KIndigoRankInfo> );
    SAFE_DELETE( pkBuff );
    // 서버 들어 갈때 한번 받는다. 하루 한번 갱신 이므로..
    g_kGlobalValue.SetIndigoRank( kRecv );
}

void On_EVENT_SQUARE_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<KSquareInfo> );
    SAFE_DELETE( pkBuff );
    SiGCSquare()->SetSquareInfo( kRecv );
    g_pkUIScene->m_pkSquareEnterWndS6->UpdateChannelBar();
    if (g_pkUIScene->m_pkInviteRequestBox)
        g_pkUIScene->m_pkInviteRequestBox->UpdateSquareInfo();
}

void On_EVENT_ENTER_SQUARE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ENTER_SQUARE_ACK );
    SAFE_DELETE( pkBuff );

    //ERR_CASE( NET_OK, kPacket.m_nOK, 0 );
    //ERR_CASE( ERR_SQUARE_00, kPacket.m_nOK, 1 );  // 광장 진입 예약시 없는 캐릭터 선택 했음. )
    //ERR_CASE( ERR_SQUARE_01, kPacket.m_nOK, 2 );  // 요청한 광장을 찾을수 없음. )
    //ERR_CASE( ERR_SQUARE_02, kPacket.m_nOK, 3 );  // 입장 하려는 광장에 사람이  찼습니다. )
    //ERR_CASE( ERR_SQUARE_03, kPacket.m_nOK, 4 );  // 입장하려는 광장에 이미 들어 있음. 게임종료 유도 )
    //ERR_CASE( ERR_SQUARE_06, kPacket.m_nOK, 5 );  // 아직 닉네임을 만들지 않았음

    Result_Enter_Square = kRecv.m_nOK;

    if( Result_Enter_Square == 0 )
    {
        SiGCSquare()->SetRelayServer( kRecv.m_dwRelayServerIP, kRecv.m_usRelayServerPort );
        for( int i = 0; i < (int)kRecv.m_vecUserInfo.size(); ++i )
        {
            KSquareUserInfo& user = kRecv.m_vecUserInfo[i];
            SiGCSquare()->AddSquarePeople( user.m_dwUID, user );
            SiKGCCoupleSystem()->AddCoupleUserInfo( user );
            g_kGlobalValue.m_kRanking.AddUserRankingInfo( user.m_dwUID, user.m_mapRankInfo );
        }
    }
    // 광장정보 다시 받아 UI갱신
    else if( Result_Enter_Square == 3 )
    {
        g_pkUIScene->m_pkSquareEnterWndS6->UpdateList();
    }
}

void On_EVENT_SQUARE_LOADING_COMPLETE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SQUARE_LOADING_COMPLETE_ACK );
    SAFE_DELETE( pkBuff );

    Result_Enter_Square = kRecv.m_nOK;
    if( kRecv.m_nOK == 0 )
    {
        // [1/31/2008] breadceo. 빠지는거 먼저 처리
        for( int i = 0; i < (int)kRecv.m_vecLeaveUsers.size(); ++i )
        {
            SiGCSquare()->RemoveSquarePeople( kRecv.m_vecLeaveUsers[i] );
        }

        // [1/21/2008] breadceo. square rough 예약해야되..
        for( int i = 0; i < (int)kRecv.m_vecSquareUsers.size(); ++i )
        {
            KSquareUserInfo& Info = kRecv.m_vecSquareUsers[i];
            SiGCSquare()->AddSquarePeopleReserve( Info.m_dwUID, Info );
        }
    }
}

void On_EVENT_NEW_SQUARE_USER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSquareUserInfo );
    SAFE_DELETE( pkBuff );

    // [1/21/2008] breadceo. square rough 예약해야되..
    SiGCSquare()->AddSquarePeopleReserve( kRecv.m_dwUID, kRecv );
    SiKGCCoupleSystem()->AddCoupleUserInfo( kRecv );

    g_kGlobalValue.m_kRanking.AddUserRankingInfo( kRecv.m_dwUID, kRecv.m_mapRankInfo );
}

void On_EVENT_LEAVE_SQUARE_USER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( DWORD );
    SAFE_DELETE( pkBuff );

    SiGCSquare()->RemoveSquarePeople( kRecv );
    SiKGCCoupleSystem()->RemoveCoupleUserInfo( kRecv );
    g_pkSquareOverlayUI->DeleteBalloonMsg(kRecv);
}

void On_EVENT_LEAVE_SQUARE_ACK( WPARAM wParam, LPARAM lParam )
{
    g_kGlobalValue.ReleaseCurrentStateUser();
    //KSerializer ks;
    //ACK_DESERIALIZE( 없는듯 );
    //SAFE_DELETE( pkBuff );

    g_kGlobalValue.m_kRanking.ClearOtherUserRank();
    SiKGCCoupleSystem()->ClearCoupleUserInfo();
}

void On_EVENT_SQUARE_CHAT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KChatData );
    SAFE_DELETE( pkBuff );
    // 누가 채팅한것.. 타입 보고 어떤 채팅 인지 확인
    WCHAR strTemp[MAX_PATH] = { 0, };

    //오후 4:44 2008-02-28 jemitgge - 차단당한 아뒤는 띄워주지 않습니다!
    if ( true == g_kGlobalValue.IsBlockUser( kRecv.m_strSenderNick ) || 
         true == SiKFriendShip()->IsBlockFriend( kRecv.m_strSenderNick ) )
        return;

    g_pkChatManager->ChatMsgProc( kRecv.m_strSenderNickColor, kRecv.m_strSenderNick,kRecv.m_strChatMsg, kRecv.m_cChatType, kRecv.m_dwChatColor);

    SiKD3DEmoticonString()->clear();
    if( false == SiKD3DEmoticonString()->IsEmoticonHasMessage( kRecv.m_strChatMsg ) )
    {
        g_pkSquareOverlayUI->SetBalloonMsg(kRecv.m_strChatMsg, kRecv.m_dwSenderUID,(KChatData::ENUM_CHAT_TYPE)kRecv.m_cChatType, kRecv.m_dwChatColor);
    }
}

void On_EVENT_SQUARE_CHAT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );
/*
    kPacket: 1  // 운영자가 아님.
    kPacket: 2  // 채팅 대상 유저가 광장에 존대하지 않음.
    kPacket: 3  // GCClub이 없이 컬러 채팅을 사용하려 했음.
    kPacket: 4  // 채팅 타입이 올바르지 않음.
    kPacket: 5  // 채팅 블럭 상태임.
*/
    // 채팅 보내기 실패 하면 이게 나옵니다.. 그닥 처리 않해도 될듯..
    g_pkChatManager->AddChatMsg(g_pkStrLoader->GetString(STR_ID_ERROR_MESSAGE_TITLE),KGCChatManager::CHAT_TYPE_RESULT,0xffffffff,false);
}

void On_EVENT_UPDATE_SQUARE_USER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<DWORD> ); // 나를 포함한 유저들의 UID가 들어 있다.(주변)
    SAFE_DELETE( pkBuff );

    SiGCSquare()->SetNearPeopleUIDVector( kRecv );
}

void On_EVENT_SQUARE_USER_SYNC_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<KPosUID> ); // 나를 포함한 유저들의 UID, Pos가 들어 있다.(주변)
    SAFE_DELETE( pkBuff );

    SiGCSquare()->UpdateSquarePeoplePosition( kRecv );
}

void On_EVENT_NEW_CHARACTER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_NEW_CHARACTER_ACK );
    SAFE_DELETE( pkBuff );

    Result_New_Character = kRecv.m_nOK;
    switch( Result_New_Character )
    {
    case 0:
        {
             
            g_kGlobalValue.m_kUserMission.DeleteMission( kRecv.m_dwMissionID );

            // 아이템 지우고
            g_pItemMgr->m_kInventory.RemoveItem( kRecv.m_ItemUID );
            g_pItemMgr->RemoveInventoryItemList(  kRecv.m_ItemUID );

            //캐릭터를 등록하고..
            SCharInfo Info;
            GCFUNC::ConvertCharInfo( Info, kRecv.m_kCharacterInfo );
            g_pItemMgr->EquipBaseItem( &Info );
            g_kGlobalValue.m_kUserInfo.AddChar( Info, true );


            g_kGlobalValue.m_mapChangeWeapon.insert(std::pair<char,std::pair<bool,GCITEMUID>>(kRecv.m_kCharacterInfo.m_cCharType,std::pair<bool,GCITEMUID>(kRecv.m_kCharacterInfo.m_bChangeWeaponLock,kRecv.m_kCharacterInfo.m_kChangeWeaponItem.m_dwUID)));

            g_MyD3D->m_TempPlayer.SetMyPlayer();
            if( GS_ROOM == g_MyD3D->m_pStateMachine->GetState() )
            {
                g_MyD3D->GetMyPlayer()->SetMyPlayer();
            }

            // 알린다
            if( g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO_FROM_ROOM )
            {
                KP2P::GetInstance()->Send_ChangeIndoorUserInfoReq( &g_kGlobalValue.m_kUserInfo );
                g_pkUIScene->RoomSceneUpdateData();
            }


            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            std::wstring strCharName = GCFUNC::GetCharName( Info.iCharType );

            // 플레이 가능한 던전 업데이트 
            g_MyD3D->m_TempPlayer.m_kUserInfo.mapStagePlayable = kRecv.m_mapDifficulty;
            g_kGlobalValue.m_kUserInfo.mapStagePlayable = kRecv.m_mapDifficulty;
            SiKGCWorldMapManager()->UpdateWorldMap();

            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewardItem, true );
            g_kGlobalValue.m_iGetCharType = -1;

            g_MyD3D->m_OriginalEquip = g_MyD3D->m_TempPlayer.m_kUserInfo;

            for(std::vector<KItem>::iterator vit = kRecv.m_vecRewardItem.begin(); vit != kRecv.m_vecRewardItem.end(); ++vit )
            {
                //여기로 UID가 들어옴
                GCItem* kItem = g_pItemMgr->GetItemData( vit->m_ItemID / 10  );
                g_pItemMgr->EquipInventoryItem(&g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar(), vit->m_ItemUID );
            }

            g_MyD3D->SendEquipItemList( &g_MyD3D->m_TempPlayer );
            
            int iUserIndex = g_MyD3D->Get_Player( g_kGlobalValue.m_kUserInfo.dwUID );
            if ( g_MyD3D->MyPlayer[iUserIndex] != NULL )
                g_MyD3D->MyPlayer[iUserIndex]->m_kUserInfo = g_kGlobalValue.m_kUserInfo;

            g_MyD3D->m_pStateMachine->GoCharSelect();
        }
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BONUS_CHARGING_ERR2 ) );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ALREADY_ACQUIRED_CHARACTER ) );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_CHARACTER_ACQUIRE_INVALID_ITEM ) );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_CHARACTER_ACQUIRE_QUERY_FAIELD ) );
        break;
    default:
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_CHARACTER_ACQUIRE_UNKNOWN_ERROR ), strTemp );
        break;
    }
}

void On_EVENT_TW_USER_AGREEMENT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );

    // 0x01 일 경우 이미 동의 했다는 뜻입니다.
    if( 0x01 == kRecv )
    {
        g_iResult_ShopAgreeMent = 0;
        g_MyD3D->SetUserAgreement( g_iResult_ShopAgreeMent );
    }
}

void On_EVENT_TW_USER_AGREEMENT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );

    //0 : 성공
    //-1 : 해당 유저 정보가 존재하지 않음
    //-2 : 해당 유저의 동의 정보가 존재하지 않음
    if( kRecv != 0 ) // error
    {
        ASSERT( !"샵 인증 실패!!" );
    }

    g_iResult_ShopAgreeMent = kRecv;
}

void On_EVENT_USE_EMOTICON_NOT( WPARAM wParam, LPARAM lParam ) // 보낸 사람 포함 해서 주변에 있는 사람에게 전송.
{
    KSerializer ks;
    ACK_DESERIALIZE( KUserEmoticon );
    SAFE_DELETE( pkBuff );

    kRecv.m_dwItemID; // 사용한 이모티콘 아이템
    kRecv.m_dwUserUID; // 사용한 사람.

    KGCEmoticonInstance* pInst = SiKGCEmoticonManager()->CreateEmoticon( kRecv.m_dwItemID / 10);
    GCSquarePeople* pPerson = SiGCSquare()->GetSquarePeople( kRecv.m_dwUserUID );
    if ( pPerson && pInst )
    {
        g_pkSquareOverlayUI->DeleteBalloonMsg( kRecv.m_dwUserUID );
        pPerson->SetEmoticon( pInst );
    }
}

void On_EVENT_USE_EMOTICON_ACK( WPARAM wParam, LPARAM lParam ) // 이녀석은 요청한 사람한테 실패하면 도착.
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );

    // 1 = 해당 이모티콘 아이템이 없음.
    kRecv;
}

void On_EVENT_CHANGE_OBSERVER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );

    // kRecv == 0 이면 옵저버 활성화
    // kRecv == 1 이면 옵저버 끔

    if( kRecv  == 0)
    {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, L"Observer Mode On" );
        g_kGlobalValue.m_bIsObserverMode = true;
    }
    else
    {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, L"Observer Mode Off" );
        g_kGlobalValue.m_bIsObserverMode = false;
    }

    g_kGlobalValue.SetObserverMode( kRecv == 0 );
    
}

void On_EVENT_INVITED_ROOM_FROM_SQUARE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KJoinRoomAckInfo );
    SAFE_DELETE( pkBuff );

    Result_Join_From_Square = kRecv.m_nOK;
    switch( Result_Join_From_Square )
    {
    case 0: // OK
        {
//#ifdef __PATH__
//
//			if(g_pGCDeviceManager2->GetMassFileManager()->IsDuplicateExist() ||
//				g_pGCDeviceManager2->GetMassFileManager()->GetDuplicatedHackCheck() != (957452)){
//				g_MyD3D->m_pStateMachine->GoServer();
//				return;
//			}
//#endif
            SiGCSquare()->ClearResourceOnSquare();
            SiGCSquare()->RefreshRenderTech();

            const KInviteInfo& kInfo = SiKGCInviteManager()->GetCurrentInviteInfo();
            g_MyD3D->m_pStateMachine->SetJoinChannel( true );
            SiKGCChannelManager()->SetCurrentChannel( kInfo.m_dwChannelUID );
            SiKGCRoomManager()->UpdateShowGameModeCategory( false, SiKGCChannelManager()->GetCurrentChannelType() );
            if( true == SiKGCChannelManager()->CheckChannel( CT_GUILD ) )
            {
                g_MyD3D->m_pStateMachine->SetJoinGuild( true );
            }

            // 가상으로 JoinRoom
            SiKGCRoomManager()->JoinRoom( KJoinRoomReqInfo::JOIN_NORMAL, kInfo.m_usRoomID, kInfo.m_strRoomPasswd, false, false );
            EnterRoom( kRecv );

            g_MyD3D->m_pStateMachine->Clear_SavedState();
            if( false == SiGCSquare()->SavedStateEmpty() )
            {
                g_MyD3D->m_pStateMachine->Set_SavedState( SiGCSquare()->GetSavedState() );
                SiGCSquare()->ClearSavedState();
            }

            if( true == SiKGCChannelManager()->CheckChannel( CT_DUNGEON ) )
            {
                g_MyD3D->m_pStateMachine->SavePrevState( GS_WORLDMAP );
            }
            else
            {
                g_MyD3D->m_pStateMachine->SavePrevState( GS_MATCH );
            }
            Result_Join_From_Square = INT_MAX;
            break;
        }
    case 5: // 상태 전이중 문제 발생 채널 로비로 강제 퇴장
        {
            g_MyD3D->m_pStateMachine->GoServer();
            break;
        }
    default:
        {
            // 1   초대 요청한 유저가 존재하지 안음. )
            // 2   해당 채널과 요청 채널이 맞지 않음. )
            // 3   해당 Room과 요청 Room이 맞지 않음. )
            // 4   초대 요청자가 이미 방장이 아님. )
            // 5   상태 전이중 문제 발생 채널 로비로 강제 퇴장 )
            // 6   방 참여 실패. 잘못된 정보로 접속을 시도함.
            // 7   방 참여 실패. P2P 버전이 맞지 않음. )
            // 8   방 참여 실패. 현재 방이 대기상태가 아님. )
            // 9   방 참여 실패. 비밀번호가 다름. )
            // 10  방 접속 불가능. 방장 부재중 )
            // 11  방 참여 실패. 방장에게 접속 알림 패킷을 보내지 못함. )
            // 12  존재하지 않는 캐릭터가 선택되었습니다. )
            // 13  입장할수 있는 올바른 레벨이 아닙니다. )
            // 14  방 접속 불가능. 정원이 모두 찾습니다. )   // 접속자가 운영자 권한이 없음)
            // 15  방 참여 실패. 운영자 이벤트 기간중 이벤트 아이템을 이미 가지고 있음. )
            // 16  옵저버가 이미 존재하는 방에 옵저버가 들어갈려고 했다. )
            // 17  더이상 다른 길드는 입장할수 없습니다. )
            // 18  이미 동일한 길드원이 3명 있습니다. )
            // 19  방 접속 불가능. 현재 방에 동시에 다른 사용자가 접속중 임.)  // 현재 방에 똑같은 UID를 가진 사용자가 접속중임

            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, Result_Join_From_Square );	
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_INVITE_ACK_ERROR ),
                strTemp );
            break;
        }
    }
}

void On_EVENT_SQUARE_USER_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPageInfo );
    SAFE_DELETE( pkBuff );

    // OK = 1 해당 광장이 존재 하지 않음..
    if( kRecv.m_nOK == 0 )
    {
        kRecv.m_buffCompList.UnCompress();

        std::vector<KInviteUserInfo> kPacket;
        ks.BeginReading( &kRecv.m_buffCompList );
        ks.Get( kPacket );
        ks.EndReading();

        SiKGCInviteManager()->SetInviteUserList( kPacket );
        SiKGCInviteManager()->SetCurrentPage( kRecv.m_nCurrentPage );
        SiKGCInviteManager()->SetMaxPage( kRecv.m_nMaxPage );
        if (g_pkUIScene->m_pkInviteRequestBox){
            g_pkUIScene->m_pkInviteRequestBox->UpdateUserList();
            g_pkUIScene->m_pkInviteRequestBox->SetUserListTitle( SiKGCInviteManager()->GetCurSelectSquareName() );

        }
        
    }
}

void On_EVENT_SIGN_BOARD_NUM_ACK( WPARAM wParam, LPARAM lParam )
{
    typedef std::pair<DWORD,DWORD> PR_DWORD_DWORD;
    KSerializer ks;
    ACK_DESERIALIZE( PR_DWORD_DWORD );
    SAFE_DELETE( pkBuff );

    //kRecv.first; // 용량
    //kRecv.second; // 등록된 개수
    SiKGCAnnounceMgr()->SetAnnounceList( kRecv );
    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_YES_NO,
        g_pkStrLoader->GetReplacedString( STR_ID_NEONSIGN_RESERVE_NUM, "ii", (int)kRecv.second, (int)kRecv.first ), L"",
        KGCUIScene::GC_MBOX_USE_NEONSIGN_RESERVE, 0, 0, false, true );
}

void On_EVENT_SIGN_BOARD_REG_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SIGN_BOARD_REG_ACK );
    SAFE_DELETE( pkBuff );

    switch( kRecv.m_nOK )
    {
    case 0:
        {
            std::vector< GCITEMUID > vecTemp;
            if( g_pItemMgr->DecDurationItem( kRecv.m_dwItemUID, &vecTemp ) == false )
            {
                ASSERT( !"Invalid Item UID" );
            }
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            SiKGCAnnounceMgr()->SetWaitTime( kRecv.m_dwOrder );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, SiKGCAnnounceMgr()->GetWaitTime() );
        }
        break;
    default:
        {
            //1  Item의 요청 범위가 맞지 않습니다.
            //2  아이템 수량이 부족.
            //3  메세지가 비어 있음.
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );	
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ANNOUNCE_ERR ),
                strTemp );
        }
        break;
    }
}

void On_EVENT_SIGN_BOARD_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSignBoardData );
    SAFE_DELETE( pkBuff );

    SiKGCAnnounceMgr()->ReserveAnnounce( kRecv );
}

void On_EVENT_EMOTICON_MIX_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_EMOTICON_MIX_ACK );
    SAFE_DELETE( pkBuff );
    // 0
    // 1 조합할 이모티콘 개수가 3개가 아닙니다
    // 2 GP가 부족함
    // 3 해당 이모티콘 아이템이 없음
    // 4 이모티콘 조합 실패
    // 5 이모티콘 조합 아이템 DB 작업 실패

    Result_New_Emoticon = kRecv.m_nOK;

    if ( 0 == Result_New_Emoticon )
    {
        std::set<DWORD>::iterator sit = kRecv.m_setMixMaterial.begin();
        for (; sit != kRecv.m_setMixMaterial.end(); ++sit )
            g_pItemMgr->DecInventoryDurationItemForItemIdWithOutAck( (*sit) / 10 );
        g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGamePoint );
        g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGamePoint );

        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecResultItem , true);
        g_kDurItemInfo = kRecv.m_vecResultItem[0];
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
    }
}

void On_EVENT_CONNECTION_MSG_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<std::wstring> );
    SAFE_DELETE( pkBuff );

    if( kRecv.empty() ) return;

    Result_Connect_Msg = *(kRecv.begin());
    Result_Case = 0;

    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_CONNECTION_MSG );
}

void On_EVENT_BAD_USER_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BAD_USER_INFO_NOT );
    SAFE_DELETE( pkBuff );
    //     kRecv.m_cLastGrade;
    //     kRecv.m_cCurrentGrade;
    //     kRecv.m_cCause;
    //     kRecv.m_tmLimit;

    // 자신의 정보 변경시

    /*
    m_cLastGrade, m_cCurrentGrade 설명
    0 : 일반 유저
    1, 2 : 랭커 (랭킹등급이 높은 일반 유저 )
    3 : 운영자
    -1 : 경고
    -2 : 불량 유저
    -3 : 블럭 유저
    */

    /*
    m_cCause 변수 설명
    0 : 해당 없음.
    1 : 욕설
    2 : 도배
    3 : 허위 신고
    4 : 해킹툴 사용
    5 : 운영자 사칭
    6 : 캐시 사기
    */
    Result_BadUser_Info = kRecv;
    g_pkChatManager->SetChatUserState( kRecv );
    if ( kRecv.m_cLastGrade >= 0 && kRecv.m_cCurrentGrade >= 0 && kRecv.m_cCause == 0)
        return;
    else if ( kRecv.m_cCurrentGrade == -4 ) //채팅금지일 경우
        return;

    Result_Case = 1;

    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_BADUSER_INFO );
}

void On_EVENT_BAD_USER_INFO_CHANGE_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BAD_USER_INFO_CHANGE_BROAD );
    SAFE_DELETE( pkBuff );

    // 방원 들이 받는 패킷 변경 사항이 발생 하면 이 패킷이 전달..
    // 본인한테는 오지 않음

    Result_BadUser_Info_Room = kRecv;

    int iIndex = g_MyD3D->Get_Player( kRecv.m_dwUserUID );
    if ( iIndex > MAX_PLAYER_NUM || iIndex < 0 )
        return;
    g_MyD3D->MyPlayer[iIndex]->m_kUserInfo.eGCUserLevel = (EGCUserLevel)kRecv.m_cAuthLevel;

    //kRecv.m_dwUserUID; // 어느 유저가..
    //kRecv.m_cAuthLevel; // Grade 정보가 옴..
}

void On_EVENT_RANK_PAGE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RANK_PAGE_ACK );
    SAFE_DELETE( pkBuff );

    Result_GuildRankingInfo_Req = kRecv.m_nOK;

    if( kRecv.m_nOK != 0 ) return; //....
    kRecv.m_cRnkType; // 랭킹 타입
    kRecv.m_cCharType; // 캐릭터 타입.
    kRecv.m_cTotalPageCount; // 전체 페이지 개수
    kRecv.m_cPageNum; // 현재 페이지 번호.

    kRecv.m_kCompBuff.UnCompress(); // 압축 풀기.

    switch( kRecv.m_cRnkType )
    {
    case KGCRanking::RT_DAILY:
    case KGCRanking::RT_WEEKLY:
    case KGCRanking::RT_MONTHLY:
        {
            // 일반 적인 랭킹이라면..
            std::vector< KWinRateRank > vecRankData;
            ks.BeginReading( &kRecv.m_kCompBuff );
            ks.Get( vecRankData );
            ks.EndReading();

            g_kGlobalValue.m_kRanking.SetRankingPage( kRecv.m_cRnkType, kRecv.m_cCharType, kRecv.m_cPageNum, vecRankData );
        }
        break;
    case KGCRanking::RT_EXP:
        {
            // Exp 랭킹이라면
            std::vector< KExpRank > vecExpRankData;
            kRecv.m_kCompBuff.UnCompress();
            ks.BeginReading( &kRecv.m_kCompBuff );
            ks.Get( vecExpRankData );
            ks.EndReading();

            g_kGlobalValue.m_kRanking.SetRankingPage( kRecv.m_cRnkType, kRecv.m_cCharType, kRecv.m_cPageNum, vecExpRankData );
        }
        break;
    }

    g_pkUIScene->m_pkRanking->Update();
}

void On_EVENT_MY_RANK_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KMyRankInfo );
    SAFE_DELETE( pkBuff );

    //<CharType, RankData>
    // 비어 있으면 랭킹 정보가 없다는 뜻..
    //kRecv.m_mapDailyRank;
    //kRecv.m_mapWeeklyRank;
    //kRecv.m_mapMonthlyRank;
    //kRecv.m_mapExpRank;

    g_kGlobalValue.m_kRanking.SetMyRanking( KGCRanking::RT_DAILY, kRecv.m_mapDailyRank );
    g_kGlobalValue.m_kRanking.SetMyRanking( KGCRanking::RT_WEEKLY, kRecv.m_mapWeeklyRank );
    g_kGlobalValue.m_kRanking.SetMyRanking( KGCRanking::RT_MONTHLY, kRecv.m_mapMonthlyRank );
    g_kGlobalValue.m_kRanking.SetMyRanking( kRecv.m_mapExpRank );
}

void On_EVENT_RANK_SEARCH_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RANK_SEARCH_ACK );
    SAFE_DELETE( pkBuff );

    // 1; 랭킹 조사시 닉네임이 비어 있음.
    // 2; 랭킹 조사시 닉네임에 사용할수 없는 문자 포함.
    // 3; 랭킹 조사시 없는 랭킹 타입 입니다.
    // 4; 랭킹 조사시 없는 캐릭터 타입 입니다.
    // 5; 랭킹 조사시 자기 자신을 조사하려 했음.
    // 6; 랭킹 정보가 없음.

    if( kRecv.m_nOK == 0 )
    {
        switch( kRecv.m_cRankType )
        {
        case KGCRanking::RT_DAILY:
        case KGCRanking::RT_WEEKLY:
        case KGCRanking::RT_MONTHLY:
            g_pkUIScene->m_pkRanking->SetFindedData( kRecv.m_kWinRank );
            break;
        case KGCRanking::RT_EXP:
            g_pkUIScene->m_pkRanking->SetFindedData( kRecv.m_kExpRank );
            break;
        }
    }
    else
    {
        switch( kRecv.m_nOK )
        {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
            g_pkUIScene->m_pkRanking->FindErrorMsg( STR_ID_RANKING6 );
            break;
        }
    }
}

//void On_EVENT_P2P_STANDBY_LIST_REQ( WPARAM wParam, LPARAM lParam ) // server -> client
//{
//    //KSerializer ks;
//    //ACK_DESERIALIZE(  );
//    //SAFE_DELETE( pkBuff );
//
//    // Event ID 만 보내는 거라 아무것도 필요없는 듯?
//
//    std::set<DWORD> setStandbyList = ((KGCStateLoading*)g_MyD3D->m_pStateMachine->GetStatePtr( GS_GAME_LOADING ))->GetWaittingUserList();
//    std::set<DWORD>::iterator sit = setStandbyList.find( g_kGlobalValue.m_kUserInfo.dwUID );
//    if ( sit != setStandbyList.end() )
//    {
//        setStandbyList.erase( sit );
//    }
//
//    KP2P::GetInstance()->Send_P2PStandbyListAck( setStandbyList );
//}

void On_EVENT_INVITE_FAIL_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<std::wstring> );
    SAFE_DELETE( pkBuff );

    // 실패 유저가 없으면 이 패킷이 오지 않음..
    kRecv;

    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_INVITE_DENY_SOME_USERS),
        L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false );



}

void On_EVENT_GET_HELL_ITEM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<KItem> );
    SAFE_DELETE( pkBuff );

    if( kRecv.empty() ) return;

    g_pItemMgr->m_kInventory.AddItemList( kRecv , true);
    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"",KGCUIScene::GC_MBOX_USE_NORMAL, KGCItemManager::ITEM_HELLMODE_TICKET, 0, true, false );

    if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
    {
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    }

}

void On_EVENT_SELL_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SELL_INFO_ACK );
    SAFE_DELETE( pkBuff );


    // 0 : 성공
    // 1 : 해당 아이템 정보가 서버에 존재하지 않음
    // 나머지 알수 없는 올휴..

    // 계산후 int로 캐스팅 하면 됩니다.

    //    kRecv.m_kSellInfo.m_cSellMoneyType;     // 어떤 화폐로 팔리는지 (GP, Gem, Crystal)
    //    kRecv.m_kSellInfo.m_fMinCount;          // 최소한 이만큼 팔아야 한다.
    //    kRecv.m_kSellInfo.m_fSellPrice;         // 최소한으로 팔았을때 받는 보상.
    int temp = kRecv.m_kSellInfo.m_nBuyPrice;

    Result_SellItemInfo = kRecv.m_nOK;

    if ( Result_SellItemInfo == 0 )
    {
        g_pItemMgr->AddSellPriceInfo( kRecv.m_ItemID, kRecv.m_kSellInfo );
        g_pkUIScene->m_pkSellCountItemDlg->SetUpdateUI();   //화폐정보를 갱신한다
    }
}

void On_EVENT_SELL_COUNT_ITEM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SELL_COUNT_ITEM_ACK );
    SAFE_DELETE( pkBuff );

    // 0 : 성공.
    // 1 : 팔려고 하는 수량아이템이 없음
    // 2 : 팔려고 하는 수량아이템의 수량이 부족함
    // 3 : 0개 혹은 음수개를 팔려고 함.
    // 4 : 수량 아이템 판매시 해당 유저가 존재하지 않음
    // 5 : 수량 아이템 판매시 해당 아이템 정보가 DB에 없음
    // 6 : Item 동기화 실패
    // 7 : DB와 User Data 동기화 실패
    // 8 : 트랜잭션 에러
    // 나머지는 알수 없는 오류..

    Result_Sell_Count_Item = kRecv.m_nOK;
    //kRecv.m_nGP;               // 보상이 GP인경우 천체 GP를 넘겨 준다. (항상 전체 GP를 줌.. )
    //kRecv.m_vecDurationItem;    // 팔은 결과 보상이 아이템인 경우 여기 들어 온다.( Empty인지 체크.. )
    //m_kReqItem

    if ( kRecv.m_nOK == 0 )
    {
        g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGP );
        g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGP );
        g_pItemMgr->m_kInventory.AddItem( kRecv.m_kReqItem , true);
        if ( false == kRecv.m_vecDurationItem.empty() )
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecDurationItem , true);

        //====================================================================================
        // 2009.02.26 : DD
        // Comment : 숏컷 아이템 창에서 이모티콘 팔 시나 물약등 팔 때 숏컷슬롯이상하게 나오는 부분
        //           해결 위해서 숏컷슬롯부분만 하드코딩 처리합니다.
        if( g_pkUIScene->m_pkMyInfoScene->GetEquipCategory() == UEC_SHORTCUT_SLOT )
        {
            if( g_pkUIScene->m_pkMyInfoScene->m_pkUserEquipBox->GetCurItemSlot() == 1 )
                g_pkUIScene->m_pkMyInfoScene->UpdateGameData(false, UEC_NUM, g_pkUIScene->m_pkMyInfoScene->GetEquipCategory());
            else
                g_pkUIScene->m_pkMyInfoScene->UpdateData();
            g_pkUIScene->m_pkMyInfoScene->m_pkInfoPanel->SetUserInfo();
        }
        else
        {
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
        }
    }
}

void On_EVENT_CHAT_EVENT_ENABLE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( bool );
    SAFE_DELETE( pkBuff );

    if( kRecv == true )
    {
        g_kGlobalValue.m_bChatEventMessageTemp = true;
        g_kGlobalValue.m_kChattingEvent.SetSuccessEvent ( true );
        g_kGlobalValue.m_iChatEventCount = GC_FPS_LIMIT * 60;	// 1분
        g_pkChatManager->AddSystemMsg( -1, g_pkStrLoader->GetString( STR_ID_CHAT_EVENT_ENABLED ) );
    }
}
void On_EVENT_GACHA_COIN_COUNT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );

    g_kGlobalValue.m_dwGachaCoin = kRecv;

    if( g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO )
    {
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
    }
    else if( g_MyD3D->m_pStateMachine->GetState() == GS_SHOP_CASH  )
    {
        g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
    }
    else if( g_MyD3D->m_pStateMachine->GetState() == GS_SHOP_GP )
    {
        g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();
    }
    g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    g_pkUIScene->m_pkMyInfoScene->UpdateData();

    g_pkUIScene->m_pkVipGachaBox->UpdateBadgeNum();


    // kRecv : 가챠코인 개수
}
void On_EVENT_COLLECTION_MISSION_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_COLLECTION_MISSION_NOT );
    SAFE_DELETE( pkBuff );

    g_kGlobalValue.m_kUserCollectionMission.ClearUserCollectionMission();
    g_kGlobalValue.m_kUserCollectionMission.SetUserCollectionMissionList( kRecv.m_vecCollection );
}

void On_EVENT_COLLECTION_COMPLETE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_COLLECTION_COMPLETE_ACK );
    SAFE_DELETE( pkBuff );

    //0 ); // 성공
    //1 ); // 해당 유저 정보가 없음
    //2 ); // 칭호 미션 정보가 없거나 완료한 상태임
    //3 ); // 유저가 존재하지 않음
    //4 ); // 칭호 보상 아이템이 DB에 존재하지 않음
    //5 ); // 스크립트에 미션 정보가 없는 경우
    //6 ); // 컬렉션 미션 완료 조건이 되지 않음
    //7 ); // 해당 컬렉션 미션이 슬롯에 존재하지 않음
    //8 ); // 이미 해당 칭호를 가지고 있음
    //9 ); // 칭호획득 선행조건이 완료되지 않음.


    switch( kRecv.m_nOK )
    {
    case 0:// 정상
        {
            //kRecv.m_dwMissionID;
            //kRecv.m_vecDurationItemInv;
            //kRecv.m_vecInv;

            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecInv , true);

            GCITEMID itemID = 0;
            if( kRecv.m_vecInv.size() )
                itemID = kRecv.m_vecInv[0].m_ItemID;

            if( 0 != itemID )
            {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, itemID, 0, true, true );
            }

            g_kGlobalValue.m_kUserCollectionMission.CompleteCollectionMission( kRecv.m_dwMissionID );
            g_pkUIScene->m_pkTitleCollection->RefreshTitleList();
            g_pkUIScene->m_pkTitleCollection->RefreshAllTitleIndex();
        }
        break;
    case 8:
        {
            //kRecv.m_dwMissionID;
            //kRecv.m_vecDurationItemInv;
            //kRecv.m_vecInv;

            // 인벤토리에 없는 칭호인 경우 추가해준다.
            std::vector<KItem> vtAdditemInfo;
            for(int i=0;i<(int)kRecv.m_vecInv.size();++i)
            {
                if( g_pItemMgr->m_kInventory.FindItemByItemID( kRecv.m_vecInv[i].m_ItemID ) == NULL )
                {
                    vtAdditemInfo.push_back( kRecv.m_vecInv[i] );
                }
            }

            g_pItemMgr->m_kInventory.AddItemList( vtAdditemInfo , true);

            GCITEMID itemID = 0;
            if( vtAdditemInfo.size() )
                itemID = vtAdditemInfo[0].m_ItemID;

            if( 0 != itemID )
            {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, itemID, 0, true, true );
            }

            g_kGlobalValue.m_kUserCollectionMission.CompleteCollectionMission( kRecv.m_dwMissionID );
        }
        break;
    case 9:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_TITLE_DONT_HAVE_PREV_TITLE),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;

    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_CANT_COMPLETE_COLLECTION),
                strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
    }

}

void On_EVENT_JOIN_GAME_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KDeathMatchScore );
    SAFE_DELETE( pkBuff );

    kRecv.m_nOK; // 실패 사유
    kRecv.m_nDestKill; // 목표
    kRecv.m_LimitTime; // 목표
    kRecv.m_nCurrentKill; // 현재
    kRecv.m_nCurrentTime; // 현재

    //// 게임에 조인 했을때 실패 하면 이쪽 메세지가 온다.
    if ( kRecv.m_nOK == 3 )
    {

        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
            g_pkStrLoader->GetReplacedString(STR_ID_DEATHMATCH_UNABLE_TO_JOIN,"iiii",kRecv.m_nCurrentKill,kRecv.m_nDestKill ,kRecv.m_nCurrentTime ,kRecv.m_LimitTime  ),L""  );
    }
    else if ( kRecv.m_nOK == 4 )
    {
        //다른아이가 로딩중일때도 막아줄라나?
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
            g_pkStrLoader->GetString(STR_ID_START_GAME_ERROR30), L"" );
    }
    else
    {
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
            g_pkStrLoader->GetString( STR_ID_START_GAME_ERROR30 ),
            strTemp );
    }
}

void On_EVENT_JOIN_GAME_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_START_GAME_BROAD );
    SAFE_DELETE( pkBuff );

    if ( g_kGlobalValue.IsObserverMode() )
    {
        StartGame( kRecv );
        return;
    }
    // 성공하면 이메세지가 방에 있는 모든 유저에게 간다.
    // 이걸 받으면 m_vecStartingUsers 안에 있는 유저를 시작 상태로 바꿔야 한다.
    // 본인이면 게임에 진입하면 된다.
    JIF( !kRecv.m_vecStartingUsers.empty() && kRecv.m_vecStartingUsers.size() == 1 );

    if( g_kGlobalValue.m_kUserInfo.dwUID == kRecv.m_vecStartingUsers[0] ) // 내가 게임 들어간다.
    {
        for( int i = 0 ; i < MAX_PLAYER_NUM ; ++i )
        {
            if( g_MyD3D->MyPlayer[i]->m_kUserInfo.CheckState( GC_RUS_PLAYING ) &&
                g_kGlobalValue.m_kUserInfo.dwUID != g_MyD3D->MyPlayer[i]->m_kUserInfo.dwUID ) // 플레이 중인 유저들의 정보를 백터에 담는다.
            {
                kRecv.m_vecStartingUsers.push_back( g_MyD3D->MyPlayer[i]->m_kUserInfo.dwUID );
            }
        }
        StartGame( kRecv );
    }
    else // 넘이 게임에 들어 간다.
    {
        PLAYER* pPlayer = g_MyD3D->GetPlayerByUID( kRecv.m_vecStartingUsers[0] );
        JIF( pPlayer );

        if( g_MyD3D->m_pStateMachine->GetState() != GS_ROOM ) // 난이미 게임중이거나 로딩중이다/
        {
            if ( pPlayer->m_kUserInfo.CheckState( GC_RUS_PLAYING ) == false )
            {
                pPlayer->m_LoadingState.m_iStep = 1;
            }
        }
        else // 난 룸에 있다.
        {
            pPlayer->m_kUserInfo.nUserState = GC_RUS_PLAYING;
            g_pkUIScene->RoomSceneUpdateData();
        }
    }


    //if ( kRecv.m_vecStartingUsers[0] != g_kGlobalValue.m_kUserInfo.dwUID && g_pkChatManager != NULL )
    //{
    //    int iIndex = g_MyD3D->GetPlayerByUID(kRecv.m_vecStartingUsers[0])->m_iPlayerIndex;
    //    g_pkChatManager->AddSystemMsg( iIndex, g_pkStrLoader->GetString( STR_ID_GAMEMSG_REPORT_JOIN ) );
    //}
}

void On_EVENT_END_GAME_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( DWORD );
    SAFE_DELETE( pkBuff );

    //로딩중인데 겜이 끝났다.
    if ( g_MyD3D->m_pStateMachine->GetState() == GS_GAME_LOADING )
    {
        g_MyD3D->m_pStateMachine->GoState( GS_ROOM, false );
        return;

    }

    // 게임이 끝나는 순간 ( 결과가 오자마자? 옴 )
    //KGCStateLoading* pState = (KGCStateLoading*)g_MyD3D->m_pStateMachine->GetStatePtr( GS_GAME_LOADING );
    //pState->SendTCPP2PDifference();
}

void On_EVENT_P2P_UNIQUE_NUM_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( DWORD );
    SAFE_DELETE( pkBuff );

    KSingleton<KncP2P>::GetInstance()->SetConnectionUID( kRecv );
}

void On_EVENT_RELAY_DATA( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( DWORD );
    SAFE_DELETE( pkBuff );

    // 완료한 녀석의 UID
    KGCStateLoading* pState = (KGCStateLoading*)g_MyD3D->m_pStateMachine->GetStatePtr( GS_GAME_LOADING );
    pState->SetLoadComplete( kRecv );
}

void On_EVENT_MINIGAME_INFO_NOT( WPARAM wParam, LPARAM lParam ) // 내 미니 게임 점수와 순위 정보
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MINIGAME_INFO_NOT );
    SAFE_DELETE( pkBuff );

    if ( false == kRecv.m_vecMiniGameInfo.empty() )
    {
        SiKGCMinigameManager()->SetMyRankingInfo( kRecv.m_vecMiniGameInfo );
    }
}

void On_EVENT_START_MINIGAME_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );

    // kRecv 가 0 이면 성공
    //          1 일 때   , ERR_MINIGAME_03, 미니게임에 이미 동일 유저가 존재


    Result_Start_MiniGame = kRecv;
}

void On_EVENT_END_MINIGAME_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KMiniGameRankInfo );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK    :  0  정상
    // kRecv.m_nOK    :  1  플레이 한 유저가 없음
    //                   2  현재 최고 기록보다 갱신하려는 Point가 작음

    if ( Result_MyMinigame_info.m_nOK != 1 )
    {
        Result_MyMinigame_info.m_nRank = kRecv.m_nRank; // 순위, -1 이면 순위권(100위) 밖의 경우
        Result_MyMinigame_info.m_dwBestScore = kRecv.m_dwBestScore; // users highest score

        // 보상받은 GP
        g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGP );
        g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGP ); 
        Result_End_MIniGame = 0;
    }
}

void On_EVENT_EXIT_MINIGAME_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ENTER_SQUARE_ACK );
    SAFE_DELETE( pkBuff );

    Result_Exit_MIniGame = kRecv.m_nOK;

    if( Result_Exit_MIniGame == 0 )
    {
        // jemitgge 광장으로 보내주셈
        SiKGCMinigameManager()->SetExitGame( true );
        SiGCSquare()->SetConnectSkip( true );

        SiGCSquare()->SetRelayServer( kRecv.m_dwRelayServerIP, kRecv.m_usRelayServerPort );
        SiGCSquare()->ConnectTRServer();
        for( int i = 0; i < (int)kRecv.m_vecUserInfo.size(); ++i )
        {
            KSquareUserInfo& user = kRecv.m_vecUserInfo[i];
            SiGCSquare()->AddSquarePeople( user.m_dwUID, user );
            g_kGlobalValue.m_kRanking.AddUserRankingInfo( user.m_dwUID, user.m_mapRankInfo );
        }
    }
    else
    {
        g_MyD3D->m_pStateMachine->GoServer();
    }
}

void On_EVENT_MINIGAME_RESTART_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );

    kRecv; // 0 : 성공
}

void On_EVENT_MINIGAME_TOPRANK_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MINIGAME_TOPRANK_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK == 0; // 정상  , 1이면  랭킹 정보 얻기 실패

    if ( false == kRecv.m_vecRank.empty() )
    {
        SiKGCMinigameManager()->SetRankingInfo( static_cast<int>(kRecv.m_cGameMode), kRecv.m_vecRank );

        if(static_cast<int>(kRecv.m_cGameMode) == g_pkUIScene->m_pkMiniGameDlg->GetCurrentGameMode())
            g_pkUIScene->m_pkMiniGameDlg->SetRanker(kRecv.m_vecRank);
        //i'm so sorry but i'm love you...
        if ( static_cast<int>(kRecv.m_cGameMode) == 1 )
            g_pkUIScene->m_pkMiniGameDlg->SetNPCSpeech();
    }
}

void On_EVENT_MINIGAME_MY_RANK_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MINIGAME_INFO_NOT );
    SAFE_DELETE( pkBuff );

    if ( false == kRecv.m_vecMiniGameInfo.empty() )
    {
        SiKGCMinigameManager()->SetMyRankingInfo(kRecv.m_vecMiniGameInfo );
        g_pkUIScene->m_pkMiniGameDlg->SetMyHighScore(g_pkUIScene->m_pkMiniGameDlg->GetCurrentGameMode());
    }
}

void On_EVENT_RESET_POSITION_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerBuffer* pkBuff = (KSerBuffer*)lParam;
    SAFE_DELETE( pkBuff );

    if( g_MyD3D->m_pStateMachine->GetState() == GS_SQUARE )
    {
        //이벤트 시작
        D3DXVECTOR3 vMyPos = SiGCSquare()->GetSquarePeople( g_kGlobalValue.m_kUserInfo.dwUID )->GetPos();
        vMyPos.x = 0.25f;
        vMyPos.y = 0.0f;
        SiGCSquare()->GetSquarePeople( g_kGlobalValue.m_kUserInfo.dwUID )->SetPos(vMyPos);
        g_pkSquareOverlayUI->m_dwRallyTime = timeGetTime();
        g_pkSquareOverlayUI->m_bRallyEvent = true;
    }
}

void On_EVENT_FINISH_EVENT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerBuffer* pkBuff = (KSerBuffer*)lParam;
    SAFE_DELETE( pkBuff );
    //이벤트 종료.


    if( g_MyD3D->m_pStateMachine->GetState() == GS_SQUARE )
        g_pkSquareOverlayUI->m_bRallyEvent = false;
}
// 여기까지 했음
//----------------------------------------------------------------------------------------------------------------------//

void On_EMS_S2_VERIFY_ACCOUNT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_VERIFY_ACCOUNT_ACK );
    SAFE_DELETE( pkBuff );

    //kRecv.m_bNewPaperAlarm // 내가 읽지 않은 쪽지가 있으면 알림
    //kRecv.m_dwEmoticon // 내 대표 이모티콘
    //kRecv.m_kBlockGroup // 블럭 유저 리스트
        //kRecv.m_kBlockGroup.m_mapMembers.begin()->second.m_bIsFriend == true; //이전에 내친구였다.
        //kRecv.m_kBlockGroup.m_mapMembers.begin()->second.m_bIsFriend == false;//생판 남이다.
    //kRecv.m_kGuildGroup // 길드 유저 리스트
    //kRecv.m_mapFriendGroup // 내 친구 리스트

    switch( kRecv.m_nOK )
    {
    case 0: // 인증 성공
        SiKFriendShip()->SetData( kRecv );
        break;
#if defined( __PATH__ )
    case 1: // 이중 접속
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_APPMSG_ERR_DOUBLE_CONNECT1 ) );
        break;
#endif
    default: // 알 수 없는 오류
        break;
    }
}

void On_EMS_S2_ADD_FRIEND_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_ADD_FRIEND_ACK );
    SAFE_DELETE( pkBuff );

    //kRecv.m_strMessage // 내가 보냈던 초대 메세지. 클라이언트에선 사용되지 않음
    //kRecv.m_kFriendInfo// 성공시 상대의 UID와 닉네임을 받아옴

    switch( kRecv.m_nOK )
    {
    case 0:		// 성공
        SiKFriendShip()->AddBuddy( kRecv );
        g_pkUIScene->m_pkNateOn->UpdateTreeData();
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
            g_pkStrLoader->GetReplacedString( STR_ID_MESSENGER_FRIEND_ADD_SUCCESS, "l", kRecv.m_kFriendInfo.m_strNickName ), L""
            , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 10:	// 바로 친구 맺어진 경우
    case 100: // 이전에 요청한 기록이 있다. 나하고 친구는 아니다. 고로 친구추가메세지만 안보내면 된다.
        SiKFriendShip()->AddBuddy( kRecv );
        g_pkUIScene->m_pkNateOn->UpdateTreeData();
        break;
    //case 1: // 내 정보가 존재하지 않음
    //    break;
    case 2: // 상대방 정보가 존재하지 않음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_FRIEND_ERROR1 ), L""
            , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 6: // 자기 자신을 추가하려고 함
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_ERROR_ADD_ME ), L""
            , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 7: // 이미 요청한 상대임
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_ERROR_ADD_ALREADY ), L""
            , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_ERROR_ADD_DEFAULT ), strTemp
                , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        }
        break;
    }
}

void On_EMS_S2_ADD_FRIEND_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_ADD_FRIEND_NOT );
    SAFE_DELETE( pkBuff );

    // 친구 추가 알림 메세지
    //kRecv.m_dwSenderUID // 보낸 사람 UID
    //kRecv.m_strSenderNick // 보낸 사람 닉네임
    //kRecv.m_strMessage // 친구 추가 메세지
    SiKFriendShip()->RegisterFriendRequest( kRecv );

    SiKFriendShip()->CheckAlramAddFriend();
}

void On_EMS_S2_DELETE_FRIEND_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_DELETE_FRIEND_ACK );
    SAFE_DELETE( pkBuff );

    //kRecv.m_dwFriendUID// 대상 유저UID
    //kRecv.m_nGroupID // 대상 유저의 그룹ID

    Result_NateOn_Delete_Buddy = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        SiKFriendShip()->DeleteBuddy( kRecv );
        g_pkUIScene->m_pkNateOn->SetOnlineCount();
        break;
    }
}

void On_EMS_S2_ACCEPT_FRIEND_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_ACCEPT_FRIEND_ACK );
    SAFE_DELETE( pkBuff );

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        SiKFriendShip()->AddBuddy( kRecv );
        g_pkUIScene->m_pkNateOn->SetOnlineCount();
        break;
    //case 1: // 내 정보가 존재하지 않음
    //    break;
    //case 2: // 상대방 정보가 존재하지 않음
    //    break;
    //case 6: // 자신을 추가하거나 삭제할 수 없음
    //    break;
    //case 9: // 친구정보를 요청한 적이 없음
    //    break;
    case 7: // 이미 요청중이거나 친구이거나 블록상태임
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_ADD_ALREADY_BLOCK ), L""
            , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 8: // 친구리스트 제한인원수 초과
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_ERROR_ADD_OVERFLOW ), L""
            , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    default: // 알 수 없는 오류
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_ERROR_ADD_DEFAULT ), strTemp
            , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    }
}

void On_EMS_S2_REJECT_FRIEND_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( DWORD );
    SAFE_DELETE( pkBuff );

    // kRecv // 내가 보낸 친구 요청을 거절한 상대의 UID
    SiKFriendShip()->RejectMyRequest( kRecv );
    g_pkUIScene->m_pkNateOn->UpdateTreeData();
}

void On_EMS_S2_UPDATE_FRIENDS_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_UPDATE_FRIENDS_NOT );
    SAFE_DELETE( pkBuff );

    // std::map< int,std::map<DWORD,KFriend> >
    // 친구그룹리스트< 그룹ID, 맴버리스트<친구UID,친구정보> >
    SiKFriendShip()->UpdateBuddy( kRecv );
    g_pkUIScene->m_pkNateOn->UpdateTreeData();

    g_pkUIScene->m_pkNateOn->SetOnlineCount();
}

void On_EMS_S2_UPDATE_FRIEND_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KFriend );
    SAFE_DELETE( pkBuff );

    // kRecv // 친구의 현재 정보
    // kRecv.m_bIsOnline // 현재 온라인 여부. 이전 상태랑 체크해서 채팅창에 알려주면 될것 같아요.
    SiKFriendShip()->UpdateBuddy( kRecv );
    g_pkUIScene->m_pkNateOn->UpdateTreeData();
    g_pkUIScene->m_pkNateOn->SetOnlineCount();

    {
        std::vector< DWORD > vecOnlineFriendList;
        SiKFriendShip()->GetOnlienFriendList(GCNateOn::FRIEND_MODE, vecOnlineFriendList);
        KP2P::GetInstance()->Send_OnlineFriendList(vecOnlineFriendList);
    }
}

void On_EMS_S2_BLOCK_FRIEND_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_BLOCK_FRIEND_ACK );
    SAFE_DELETE( pkBuff );

    //kRecv.m_dwBlockUID // 내가 블럭시킨 유저 UID
    //kRecv.m_strBlockNick// 내가블럭시킨 유저 닉네임

    Result_NateOn_Block_Buddy = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        SiKFriendShip()->BlockBuddy( kRecv );
        break;
    case 2: //추가하려는 님이 존재하지 않음
        break;
    case 6: // 자기 자신을 추가하려 함
        break;
    case 7: // 이미 블럭임
        break;
    case 8: // 제한 인원수 초과
        break;
    case 25: // 쿼리에 사용할수 없는 문자 포함
        break;
    }
}

void On_EMS_S2_UNBLOCK_FRIEND_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_UNBLOCK_FRIEND_ACK );
    SAFE_DELETE( pkBuff );

    //kRecv.m_dwBlockUID // 내가 블럭해제시킨 유저 UID
    //kRecv.m_strBlockNick// 내가 블럭해제시킨 유저 닉네임

    Result_NateOn_UnBlock_Buddy = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        SiKFriendShip()->UnBlockBuddy( kRecv );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_UNBLOCK_BUDDY_SUCCESS ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        g_pkUIScene->m_pkNateOn->UpdateTreeData();
        break;
    case 2: // 해당 리스트에 없는 유저임
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_DONT_FIND ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 6: // 자기 자신을 추가하려 함
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_UNBLOCK_ME ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 1: // 내 정보가 존재하지 않음
    case 7: // 이미 요청한 상태,이미 친구임
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, Result_NateOn_UnBlock_Buddy );	
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_UNBLOCK_BUDDY_ERROR ),
                strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
            break;
        }
    }
}

void On_EMS_S2_BLOCK_MOVE_FRIEND_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_BLOCK_MOVE_FRIEND_ACK );
    SAFE_DELETE( pkBuff );

    //kRecv.m_dwFriendUID// 내가 블럭시킨 유저 UID
    //kRecv.m_strBlockNick// 내가블럭시킨 유저 닉네임
    //kRecv.m_nGroupID// 내가 블럭시킨 유저의 이전 그룹ID

    Result_NateOn_Block_Buddy = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        SiKFriendShip()->BlockBuddy( kRecv );
        break;
    case 8: // 제한 인원수 초과
        break;
    case 11: // 해당하는 그룹이 없음
        break;
    case 16: // 해당 그룹에 이미 등록된 유저임
        break;
    case 27: // 그룹내 해당유저를 찾을 수 없음
        break;
    }
}

void On_EMS_S2_UNBLOCK_MOVE_FRIEND_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_UNBLOCK_MOVE_FRIEND_ACK );
    SAFE_DELETE( pkBuff );

    //kRecv.m_dwFriendUID// 내가 블럭해제시킨 유저 UID
    //kRecv.m_strBlockNick// 내가블럭해제시킨 유저 닉네임
    //kRecv.m_nGroupID// 내가 블럭해제시킨 유저가 이동할 그룹ID

    Result_NateOn_UnBlock_Buddy = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        SiKFriendShip()->MoveBuddy_BlockToFriend( kRecv );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_UNBLOCK_BUDDY_SUCCESS ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        g_pkUIScene->m_pkNateOn->UpdateTreeData();
        break;
    case 2: // 해당 리스트에 없는 유저임
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_DONT_FIND ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 6: // 자기 자신을 추가하려 함
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_UNBLOCK_ME ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 1: // 내 정보가 존재하지 않음
    case 7: // 이미 요청한 상태,이미 친구임
    case 11: // 해당하는 그룹이 없음
    case 16: // 해당 그룹에 이미 등록된 유저임
    case 27: // 그룹내 해당유저를 찾을 수 없음
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, Result_NateOn_UnBlock_Buddy );	
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_UNBLOCK_BUDDY_ERROR ),
                strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
            break;
        }
    }
}

void On_EMS_S2_ADD_GROUP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_ADD_GROUP_ACK );
    SAFE_DELETE( pkBuff );

    //kRecv.m_strGroupName // 내가 요청했던 그룹 이름
    //kRecv.m_nGroupID // 성공시,만들어진 그룹 ID 날아옴

    Result_NateOn_Add_Group = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        SiKFriendShip()->AddBuddyGroup( kRecv );
        break;
    case 9: // 최초 메신저 접속해서 친구 리스트가 요청된 적이 없음
        break;
    case 10: // 해당 이름을 가진 그룹이 존재함
        break;
    case 12: // 최대 그룹수 초과
        break;
    case 13: // 그룹명 문자열 길이 초과
        break;
    case 25: // 쿼리에 사용할수 없는 문자 포함
        break;
    case 33: // 친구 기본그룹이 없음.
        break;
    }
}

void On_EMS_S2_DELETE_GROUP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_DELETE_GROUP_ACK );
    SAFE_DELETE( pkBuff );

    //kRecv.m_nGroupID // 삭제 요청한 그룹ID

    Result_NateOn_Delete_Group = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        SiKFriendShip()->DeleteBuddyGroup( kRecv );
        break;
    }
}
void On_EMS_S2_RENAME_GROUP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_RENAME_GROUP_ACK );
    SAFE_DELETE( pkBuff );

    //kRecv.m_nGroupID //이름 변경 요청한 그룹 ID
    //kRecv.m_strGroupName//변경 요청한 그룹명

    Result_NateOn_Rename_Group = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        SiKFriendShip()->RenameBuddyGroup( kRecv );
        break;
    case 10: // 해당 그룹이 존재함
        break;
    case 11:// 해당그룹이 없음
        break;
    case 13:// 그룹명 문자열 길이 초과
        break;
    case 15:// 기본그룹을 변경하려 함
        break;
    case 25:// 쿼리에 사용할수 없는 문자 포함
        break;

    }
}

void On_EMS_S2_MOVE_FRIEND_TO_GROUP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_MOVE_FRIEND_TO_GROUP_ACK );
    SAFE_DELETE( pkBuff );

    Result_NateOn_Move_Group = kRecv.m_nOK;

    //kRecv.m_dwFriendUID//이동시킬 친구 UID
    //kRecv.m_nFromGroupID//이전 그룹ID
    //kRecv.m_nToGroupID//이동할 그룹ID

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        SiKFriendShip()->MoveBuddy( kRecv );
        break;
    }
}

void On_EMS_S2_SET_EMOTICON_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_SET_EMOTICON_ACK );
    SAFE_DELETE( pkBuff );

    Result_NateOn_Change_Emoticon = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        SiKFriendShip()->SetMyEmoticon( kRecv );
        break;
    }
}

void On_EMS_S2_START_CHAT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_START_CHAT_NOT );

    //kRecv.m_prRoomKey // 채팅방 식별키(서버UID,채팅방UID)
    //kRecv.m_mapMemberInfo //채팅 그룹정보(UID,Nick)

    GCNateOnChat* pNateOnChat = g_pkUIScene->m_pkNateOn->GetNateOnChatWindow();
    GCTalkList* pTalkList = g_pkUIScene->m_pkNateOn->GetTalkListWindow();

    if( pNateOnChat && pTalkList )
    {
        NATE_TALK_BOX TalkBox;

        std::map<DWORD,std::pair<std::wstring, std::wstring>>::iterator itMember = kRecv.m_mapMemberInfo.begin();
        std::wstring wstrNickName = L"";
        std::wstring wstrNickColor = L"FFFFFF";
        for(;itMember != kRecv.m_mapMemberInfo.end();++itMember)
        {
            if( 0 == wstrNickName.length() )
            {
                if( g_kGlobalValue.m_kUserInfo.strNickName != itMember->second.first )
                    wstrNickName = itMember->second.first;
                    wstrNickColor = itMember->second.second;
            }

            TalkBox.InsertTalker( itMember->first, itMember->second.first, itMember->second.second );
        }

        pTalkList->AddTalkList( kRecv.m_prRoomKey, wstrNickName.c_str(), wstrNickColor);
        pTalkList->RefreshTalkList();
        pNateOnChat->AddTalkBox( kRecv.m_prRoomKey, TalkBox );

        g_pkUIScene->m_pkNateOn->SetNateonMode( GCNateOn::CHAT_MODE );

        // 기존에 선택된 대화박스가 없다면?
        if( NULL == pNateOnChat->GetTalkBox( pNateOnChat->GetCurTalkKey() ) )
        {
            pNateOnChat->ClearTalkListBox();
            pNateOnChat->SetCurTalkKey( kRecv.m_prRoomKey );
            pTalkList->SetCurTalkKey( kRecv.m_prRoomKey );
            pTalkList->SelectTalkList( kRecv.m_prRoomKey );
            pNateOnChat->RefreshTalkBox( kRecv.m_prRoomKey );
            pNateOnChat->RefreshTalkerList( kRecv.m_prRoomKey );
        }
        pNateOnChat->EnableEditor( true );
    }

    // NateOn을 닫고 있는 상태였다면, 알림 표시를 띄워준다.
    if( false == g_pkUIScene->m_pkNateOn->IsCreate()
        || false == g_pkUIScene->m_pkNateOn->IsRenderOn() )
    {
        g_pkUIScene->m_pkNateOn->SetNew( true );
    }
    else
    {
        GCTalkList* pTalkList = g_pkUIScene->m_pkNateOn->GetTalkListWindow();

        if( pTalkList )
        {
            if( kRecv.m_prRoomKey != pTalkList->GetCurTalkKey() )
                pTalkList->SetNewTalk( kRecv.m_prRoomKey, true );

            //NATE_TALK_BOX* pTalkBox = pNateOnChat->GetTalkBox( kRecv.m_prRoomKey );
            //if( pTalkBox )
            //	pTalkBox->SetNew( true );
        }
    }

    SAFE_DELETE( pkBuff );
}

void On_EMS_S2_START_CHAT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_START_CHAT_ACK );

    //kRecv.m_nOK //성공실패유무
    //kRecv.m_prRoomKey // 채팅방 식별키(서버UID,채팅방UID)
    //kRecv.m_setSuccessUIDs // 채팅방 초대 성공한 UID
    //kRecv.m_setFailedUIDs // 채팅방 초대 실패한 UID

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        break;
    case 28: // 초대가능한 유저 UID가 없음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_FRIEND_CANT_START_TALK ), L""
            , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 29: // 내 모든 채팅방을 사용중임
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_ERROR_TALK_CHAT_COUNT ), L""
            , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    default:
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_ERROR_TALK_DEFAULT ), strTemp
            , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    }

    SAFE_DELETE( pkBuff );
}

void On_EMS_S2_LEAVE_CHAT_MEMBER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_LEAVE_CHAT_MEMBER_ACK );

    //kRecv //std::pair<DWORD,DWORD> // 채팅방 식별키

    GCNateOnChat* pNateOnChat = g_pkUIScene->m_pkNateOn->GetNateOnChatWindow();
    GCTalkList* pTalkList = g_pkUIScene->m_pkNateOn->GetTalkListWindow();
    if( pNateOnChat && pTalkList )
    {
        g_pkUIScene->m_pkNateOn->SetNateonMode( GCNateOn::FRIEND_MODE );
        pNateOnChat->DeleteTalkBox( kRecv );
        pTalkList->DeleteTalkList( kRecv );
        pTalkList->RefreshTalkList();
    }

    SAFE_DELETE( pkBuff );
}

void On_EMS_S2_LEAVE_CHAT_MEMBER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_LEAVE_CHAT_MEMBER_NOT );

    //kRecv.m_prRoomKey // 채팅방 식별키(서버UID,채팅방UID)
    //kRecv.m_dwLeaveUID// 나간 유저UID

    GCNateOnChat* pNateOnChat = g_pkUIScene->m_pkNateOn->GetNateOnChatWindow();
    if( pNateOnChat )
    {
        NATE_TALK_BOX* pNateTalkBox = pNateOnChat->GetTalkBox( kRecv.m_prRoomKey );
        if( pNateTalkBox )
        {
            std::wstring strTemp = pNateTalkBox->GetTalker( kRecv.m_dwLeaveUID );
            std::wstring strTempcolor = pNateTalkBox->GetTalkerColor(kRecv.m_dwLeaveUID);
            pNateTalkBox->DeleteTalker( kRecv.m_dwLeaveUID );
            strTemp = g_pkStrLoader->GetReplacedString( STR_ID_NATEON_OUT_OF_TALKBOX, "s", strTemp.c_str() );
            pNateOnChat->AddChatString( kRecv.m_prRoomKey, L"#c" + strTempcolor + strTemp + L"#cX", 0xffffffff);
            pNateOnChat->RefreshTalkerList( kRecv.m_prRoomKey );

            if( 1 >= pNateTalkBox->GetTalkerCount() )
                pNateOnChat->EnableEditor( false );
        }
    }

    SAFE_DELETE( pkBuff );
}

void On_EMS_S2_SEND_CHAT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KChatMsg );

    //kRecv.m_prRoomKey // 그룹키
    //kRecv.m_setReceiverUIDs // 받는사람들
    //kRecv.m_dwSenderUID //보낸사람UID
    //kRecv.m_strMessage //메세지

    GCNateOnChat* pNateOnChat = g_pkUIScene->m_pkNateOn->GetNateOnChatWindow();

    if( pNateOnChat )
    {
        NATE_TALK_BOX* pTalkBox = pNateOnChat->GetTalkBox( kRecv.m_prRoomKey );

        if( pTalkBox )
        {
            std::wstring wstrMsg
                = g_pkStrLoader->GetReplacedString( STR_ID_CHAT_HEADER, "s", L"#c" + pTalkBox->GetTalkerColor(kRecv.m_dwSenderUID) + pTalkBox->GetTalker(kRecv.m_dwSenderUID).c_str() + L"#cX");
            wstrMsg += kRecv.m_strMessage;

            if ( kRecv.m_dwSenderUID == g_kGlobalValue.m_kUserInfo.dwUID )
                pNateOnChat->AddChatString( kRecv.m_prRoomKey, wstrMsg, 0xFFCDDFF0 );
            else
                pNateOnChat->AddChatString( kRecv.m_prRoomKey, wstrMsg, 0xffffffff );

            if( kRecv.m_prRoomKey != pNateOnChat->GetCurTalkKey() )
                pTalkBox->SetNew( true );
        }
    }

    // NateOn을 닫고 있는 상태였다면, 알림 표시를 띄워준다.
    if( false == g_pkUIScene->m_pkNateOn->IsCreate()
        || false == g_pkUIScene->m_pkNateOn->IsRenderOn() )
    {
        g_pkUIScene->m_pkNateOn->SetNew( true );        
        g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_ALERT_EVENT_UPDATE ) );

    }
    else
    {
        GCTalkList* pTalkList = g_pkUIScene->m_pkNateOn->GetTalkListWindow();

        if( pTalkList )
        {
            if( kRecv.m_prRoomKey != pTalkList->GetCurTalkKey() )
                pTalkList->SetNewTalk( kRecv.m_prRoomKey, true );
        }
    }

    SAFE_DELETE( pkBuff );
}

void On_EMS_S2_INVITE_CHAT_MEMBER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_INVITE_CHAT_MEMBER_ACK );

    //kRecv.m_nOK;
    //kRecv.m_prRoomKey;    // 채팅방Key
    //kRecv.m_setSuccessUIDs;//초대 성공한 유저 UID
    //kRecv.m_setFailedUIDs; //초대 실패한 유저 UID

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        g_pkUIScene->m_pkNateOn->GetNateOnChatWindow()->EnableEditor(true);
        //성공하면 채팅창 재활성화
        break;
    case 28: // 초대가능한 유저 UID가 없음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_SOME_USER_CANT_INVITE ), L""
            , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 30: // 해당하는 채팅방이 없다
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_DONT_EXIST_INVITE_ROOM ), L""
            , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 31: // 최대 대화맴버수가 초과됩니다
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_OVERFLOW_USER ), L""
            , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    default: // 알 수 없는 오류
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NATEON_CANT_INVITE ), strTemp
            , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    }

    SAFE_DELETE( pkBuff );
}

void On_EMS_S2_UPDATE_CHAT_MEMBER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_UPDATE_CHAT_MEMBER_NOT );

    //kRecv.m_prRoomKey    // 채팅방Key
    //kRecv.m_mapMemberInfo// 갱신된 채팅맴버들(UID,NICK)

    GCNateOnChat* pNateOnChat = g_pkUIScene->m_pkNateOn->GetNateOnChatWindow();
    GCTalkList* pTalkList = g_pkUIScene->m_pkNateOn->GetTalkListWindow();

    if( pNateOnChat && pTalkList )
    {
        NATE_TALK_BOX* pTalkBox = pNateOnChat->GetTalkBox( kRecv.m_prRoomKey );
        if( pTalkBox )
        {
            pTalkBox->ClearTalker();

            std::map<DWORD,std::pair<std::wstring,std::wstring>>::iterator itMember = kRecv.m_mapMemberInfo.begin();
            for( ; itMember != kRecv.m_mapMemberInfo.end() ; ++itMember )
            {
                pTalkBox->InsertTalker( itMember->first, itMember->second.first, itMember->second.second);
            }
        }
        pNateOnChat->RefreshTalkerList( kRecv.m_prRoomKey );
    }

    SAFE_DELETE( pkBuff );
}

void On_EMS_S2_SEND_PAPER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_SEND_PAPER_ACK );

    //kRecv.m_nOK;
    //kRecv.m_strRecvNick; //유저가 직접 입력한 받는사람 닉네임(오직하나)
    //kRecv.m_setRecvUIDs; //친구리스트에서 고른 다수쪽지받는 대상들, 혹은 내친구대상의 1:1쪽지보낼때 받는대상도 포함.
    //kRecv.m_strMessage; //내가 작성한 메세지
    //kRecv.m_dwSkinItemID;//내가 고른 스킨아이템

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        break;
    case 1: // 유저가 존재하지 않음
        break;
    case 34: // 쪽지 받을 있는 사람이 없음
        break;
    case 35: // 메세지가 비어있음
        break;
    case 36: // UID파싱에러
        break;
    case 37: // 누군지 모르겠지만 보내는님을 블럭함
        break;
    case 38:// 누군지 모르겠지만 받는님을 블럭함
        break;
    case 39: // 누군지 모르겠지만 50통 넘은 님이 있음
        break;
    case 40: // 한번에 보낼 수 있는 최대 쪽지수 초과
        break;
    default: // 알 수 없는 오류
        break;
    }

    SAFE_DELETE( pkBuff );
}

void On_EMS_S2_NEW_PAPER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_NEW_PAPER_NOT );

    //kRecv.m_dwSenderUID;   //나한테 쪽지 보낸님 UID
    //kRecv.m_strSenderNick; //나한테 쪽지 보낸님 닉네임

    //g_pkUIScene->m_pkNateOnMessage->AddMsg( kRecv.m_dwSenderUID, kRecv.m_strSenderNick );

    SAFE_DELETE( pkBuff );
}

void On_EMS_S2_PAPERBOX_FULL_NOT( WPARAM wParam, LPARAM lParam )
{
    //패킷 없음
    //내 받은쪽지함이 가득찼음을 알림.
}

void On_EMS_S2_UPDATE_SENT_PAPERBOX_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_UPDATE_SENT_PAPERBOX_NOT );

    //kRecv == std::map<DWORD,KPaper> //쪽지UID,쪽지정보

    std::map<DWORD,KPaper>::iterator itSendMsg = kRecv.begin();

    for(;itSendMsg != kRecv.end();++itSendMsg)
        g_pkUIScene->m_pkNateOnMessage->AddSendedMsg( itSendMsg->first, itSendMsg->second );

    SAFE_DELETE( pkBuff );
}

void On_EMS_S2_UPDATE_RECV_PAPERBOX_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_UPDATE_RECV_PAPERBOX_NOT );

    //kRecv == std::map<DWORD,KPaper> //쪽지UID,쪽지정보

    std::map<DWORD,KPaper>::iterator itRecvMsg = kRecv.begin();

    for(;itRecvMsg != kRecv.end();++itRecvMsg )
        g_pkUIScene->m_pkNateOnMessage->AddReciveMsg( itRecvMsg->first, itRecvMsg->second );

    SAFE_DELETE( pkBuff );
}

void On_EMS_S2_NOCHANGE_SENT_PAPERBOX_NOT( WPARAM wParam, LPARAM lParam )
{
    //패킷없음
    //새로보낸쪽지없음
}

void On_EMS_S2_NOCHANGE_RECV_PAPERBOX_NOT( WPARAM wParam, LPARAM lParam )
{
    //패킷없음
    //새로받은쪽지없음
}

void On_EMS_S2_READ_PAPER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_READ_PAPER_ACK );

    //kRecv.m_nOK;          //결과값
    //kRecv.m_setPaperUIDs; //쪽지UID들

    switch( kRecv.m_nOK )
    {
    case 41: //선택한 쪽지가 없음.
        break;
    case 42: //하나라도 없는 쪽지가 있음.
        break;
    default:
        break;
    }

    SAFE_DELETE( pkBuff );
}

void On_EMS_S2_DEL_SENT_PAPER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_DEL_SENT_PAPER_ACK );

    //kRecv.m_nOK;          //결과값
    //kRecv.m_setPaperUIDs; //쪽지UID들

    switch( kRecv.m_nOK )
    {
    case 41: //선택한 쪽지가 없음.
        break;
    case 42: //하나라도 없는 쪽지가 있음.
        break;
    default:
        break;
    }

    SAFE_DELETE( pkBuff );
}

void On_EMS_S2_DEL_RECV_PAPER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_DEL_RECV_PAPER_ACK );

    //kRecv.m_nOK;          //결과값
    //kRecv.m_setPaperUIDs; //쪽지UID들

    switch( kRecv.m_nOK )
    {
    case 41: //선택한 쪽지가 없음.
        break;
    case 42: //하나라도 없는 쪽지가 있음.
        break;
    default:
        break;
    }

    SAFE_DELETE( pkBuff );
}

void On_EMS_S2_SEAL_PAPER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_DEL_RECV_PAPER_ACK );

    //kRecv.m_nOK;          //결과값
    //kRecv.m_setPaperUIDs; //쪽지UID들

    switch( kRecv.m_nOK )
    {
    case 41: //선택한 쪽지가 없음.
        break;
    case 42: //하나라도 없는 쪽지가 있음.
        break;
    case 44:
        break; // 하나라도 이미 영구 쪽지임
    case 45:
        break; // 영구쪽지가 이미 30개가 넘음
    default:
        break;
    }

    SAFE_DELETE( pkBuff );
}

//void On_EVENT_CHAT_EVENT_ENABLE_NOT( WPARAM wParam, LPARAM lParam )
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( bool );
//    SAFE_DELETE( pkBuff );
//
//    if( kRecv == true )
//    {
//        g_kGlobalValue.m_kChattingEvent.SetSuccessEvent ( true );
//        g_pkChatManager->AddSystemMsg( -1, g_pkStrLoader->GetString( STR_ID_CHAT_EVENT_ENABLED ) );
//    }
//}

void On_EVENT_SERVER_TIME_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SERVER_TIME_NOT );
    SAFE_DELETE( pkBuff );

    CTime time = CTime(kRecv.m_nYear,kRecv.m_nMonth,kRecv.m_nDay,kRecv.m_nHour,kRecv.m_nMinute,kRecv.m_nSecond);

    g_kGlobalValue.m_tmServerSyncTime = g_kGlobalValue.TimeToInt(time);

    g_kGlobalValue.m_tmServerSyncTime = g_kGlobalValue.m_tmServerSyncTime - kRecv.m_tCurrentTime;
    g_kGlobalValue.m_tmServerTime = CTime(kRecv.m_tCurrentTime + g_kGlobalValue.m_tmServerSyncTime);

    g_pkUIMgr->SendEvent(KActionEvent( NULL, KGCUIScene::D3DWE_TIME_TICK_ONE_MINUTE) );
	SiKGCFatigueManager()->GetCurrentInfo();

	if ( SiKGCFatigueManager()->IsFatigueSystemApplyUser() && SiKGCFatigueManager()->IsAlarm()) {
		g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_FATIGUE_SYSTEM_MESSAGE, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
	}
}


void On_EVENT_GET_FULL_SP_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KFullSPInfo );
    SAFE_DELETE( pkBuff );

#if defined( SKILL_TREE )
    SiGCSKT()->Server_SetFullSPInfo( kRecv );
#endif
}

void On_EVENT_SKILL_TRAINING_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KOKnValue );
    SAFE_DELETE( pkBuff );

    if( kRecv.m_nOK == 0 )
    {
        if( true == SiGCSKT()->Server_TrainSkill( kRecv.m_nValue ) )
        {
#if !defined( NO_MSG_BOX_SKILL_LEARN_AND_REMOVE )
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_TRAINSKILL_SUCCESS ), L"",
                KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
#endif
            SiGCSKT()->EquipSkill( (EGCSkillTree)kRecv.m_nValue, g_pkUIScene->m_pkSkillTree->GetSetID() );
            
            ///////////////////////////////////////////////////////////////////////////////////
            // 패시브 스킬인 경우 자동장착 상태가 되므로 다른 스킬세트에도 장착시켜줘야 한다.
            const GCSkill* pSkill = SiGCSKT()->GetSkill( static_cast< EGCSkillTree >( kRecv.m_nValue ) );            
            if( pSkill && pSkill->m_bPassive ) {
                for( int i = 0; i < SiGCSKT()->GetCurrentSkillSetSize(); i++ ) {
                    if( i == g_pkUIScene->m_pkSkillTree->GetSetID() ) {
                        continue;
                    }

                    SiGCSKT()->EquipSkill( (EGCSkillTree)kRecv.m_nValue, i );
                }
            }
            ///////////////////////////////////////////////////////////////////////////////////

            g_pkUIScene->m_pkSkillTree->ThreadSafeUpdate();
#if defined( NO_MSG_BOX_SKILL_LEARN_AND_REMOVE )
            if( SiGCSKT()->IsSkillMissionSkillID( static_cast< EGCSkillTree >( kRecv.m_nValue ) ) ) {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_TRAINSKILL_SUCCESS ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );   
            }
#endif
            return;
        }
        else
        {
            kRecv.m_nOK = -1;
        }
    }

    switch( kRecv.m_nOK )
    {
    case -98: // 98      처리가 지연되고 있음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PACKET_DELAY ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 2: // 2   이미 획득한 스킬입니다.
    case 13: // 13  이미 보유하고 있는 스킬이 있음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_ALREADY_EXIST ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 3: // 3   선행 스킬을 완료하지 않았습니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_TRAIN_CONDITION_ERROR1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 5: // 5   해당 전직을 만족하지 못함.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_TRAIN_CONDITION_ERROR2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 6: // 6   레벨을 만족하지 못함.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_TRAIN_CONDITION_ERROR3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 7: // 7   남은 스킬 포인트가 부족함.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NOMORE_SKILL_POINT ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 15: // 15  더 이상 스킬을 배울 수 없습니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_UNTRAIN_CONDITION_ERROR4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case -1:
    case 1: // 1   존재하지 않는 스킬입니다.
    case 4: // 4   해당 캐릭터가 존재하지 않음.
    case 8: // 8   스킬 획득시 DB 처리 완료후 스킬을 찾지 못함.
    case 9: // 9   스킬 획득후 추가에 실패
    case 10: // 10  해당 유저가 존재하지 않음.
    case 11: // 11  데이터 파싱 에러.
    case 12: // 12  유저의 스킬 기본 정보가 존재하지 않음.
    case 14: // 14  삭제해야 할 보유하고 있는 스킬이 없음.
    case 16: // 16  Lock이 해제되지 않은 스킬을 배우려고 함.
    case 31: // 31  미션 보상 스킬인데 미션완료하지 못했음.
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );	
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_TRAINSKILL_ERROR ),
                strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            break;
        }
    }
}

void SetSkill( KChangeSkillSet& kRecv )
{
    for( int i = 0; i < MAX_PLAYER_NUM; ++i )
    {
        if( !g_MyD3D->MyPlayer[i]->m_kUserInfo.bLive ||
            g_MyD3D->MyPlayer[i]->m_kUserInfo.dwUID != kRecv.m_dwUID )
            continue;

        g_MyD3D->MyPlayer[i]->m_kUserInfo.UpdateSkillSet( kRecv.m_mapSetting, kRecv.m_mapSkillSets );
    }

    if( kRecv.m_dwUID == g_kGlobalValue.m_kUserInfo.dwUID )
    {
        SiGCSKT()->Server_SetSkillSetting( kRecv.m_mapSetting );
        SiGCSKT()->Server_SetSkillSet( kRecv.m_mapSkillSets );
        g_kGlobalValue.m_kUserInfo.UpdateSkillSet( kRecv.m_mapSetting, kRecv.m_mapSkillSets );
        g_MyD3D->m_TempPlayer.m_kUserInfo.UpdateSkillSet( kRecv.m_mapSetting, kRecv.m_mapSkillSets );

        if( g_MyD3D->m_pStateMachine->GetState() == GS_SHOP_CASH ) {
            g_pkUIScene->m_pkCashShopScene->UpdateUserPanel();
        }else if( g_MyD3D->m_pStateMachine->GetState() == GS_SHOP_GP ){
            g_pkUIScene->m_pkGPShopScene->UpdateUserPanel();
        } else if( g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO || g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO_FROM_ROOM ) {
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
        } else if ( g_MyD3D->m_pStateMachine->GetState() == GS_MATCH ) {
            g_pkUIScene->m_pkMatchScene->UpdateGameData();
        }
    }
}

void On_EVENT_SET_SKILL_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KChangeSkillSet );
    SAFE_DELETE( pkBuff );

    switch( kRecv.m_nOK )
    {
    case 1: // 1  세트 변경시 캐릭터. 전직 존재하지 않음.. )
    case 2: // 2  세트 변경시 세트 개수 초과. )
    case 3: // 3  존재하지 않는 스킬입니다.
    case 4: // 4  아직 배우지 않은 스킬 입니다.
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );	
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_CHANGE_SKILL_SET_ERROR ),
                strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
            break;
        }
    }
    SetSkill( kRecv );
    SiGCSKT()->CheckNewSkill();
    Result_SkillSet=kRecv.m_nOK;
}

void On_EVENT_SET_SKILL_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KChangeSkillSet );
    SAFE_DELETE( pkBuff );

    SetSkill( kRecv );
    SiGCSKT()->CheckNewSkill();
    Result_SkillSet = 0;
}

void On_EVENT_REMOVE_SKILL_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_REMOVE_SKILL_ACK );
    SAFE_DELETE( pkBuff );

    if( kRecv.m_nOK == 0 )
    {
        g_pItemMgr->m_kInventory.AddItem( kRecv.m_kItem , true);
        g_pkUIScene->m_pkMyInfoScene->UpdateData();

        if( true == SiGCSKT()->Server_UnTrainSkill( kRecv.m_nSkillID ) )
        {
#if !defined( NO_MSG_BOX_SKILL_LEARN_AND_REMOVE )
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_UNTRAINSKILL_SUCCESS ), L"",
                KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true  );
#endif
            g_pkUIScene->m_pkSkillTree->ThreadSafeUpdate();
            return;
        }
            else
        {
            kRecv.m_nOK = -1;
        }
    }

    switch( kRecv.m_nOK )
    {
    case 16: // 16      스킬 삭제시 후행 스킬이 존재함.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_UNTRAIN_CONDITION_ERROR1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 17: // 17      스킬 삭제아이템 개수가 부족.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_UNTRAIN_CONDITION_ERROR2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 15: // 15      아직 배우지 않은 스킬 입니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_UNTRAIN_CONDITION_ERROR3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case -98: // 98      처리가 지연되고 있음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PACKET_DELAY ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case -1:
    case 1: // 1   존재하지 않는 스킬입니다.
    case 2: // 2   이미 획득한 스킬 입니다.
    case 3: // 3   선행 스킬을 완료하지 않았습니다.
    case 4: // 4   해당 캐릭터가 존재하지 않음.
    case 5: // 5   해당 전직을 만족하지 못함.
    case 6: // 6   레벨을 만족하지 못함.
    case 7: // 7   남은 스킬 포인트가 부족함.
    case 8: // 8   스킬 획득시 DB 처리 완료후 스킬을 찾지 못함.
    case 9: // 9   스킬 획득후 추가에 실패
    case 10: // 10  해당 유저가 존재하지 않음.
    case 11: // 11  데이터 파싱 에러.
    case 12: // 12  유저의 스킬 기본 정보가 존재하지 않음.
    case 13: // 13  이미 보유하고 있는 스킬이 있음.
    case 14: // 14  삭제해야 할 보유하고 있는 스킬이 없음.
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );	
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_UNTRAINSKILL_ERROR ),
                strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            break;
        }
    }
}

void On_EVENT_UNLOCK_SKILL_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_UNLOCK_SKILL_ACK );
    SAFE_DELETE( pkBuff );

    if( kRecv.m_nOK == 0 )
    {
        g_pItemMgr->m_kInventory.AddItem( kRecv.m_kItem , true);
        SiGCSKT()->Server_UnlockGroup( kRecv.m_cCharType, kRecv.m_nUnLockGroupID );
        
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_GROUP_OPEN ), L"",
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true  );
        g_pkUIScene->m_pkSkillTree->ThreadSafeUpdate();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        return;
    }

    switch( kRecv.m_nOK )
    {
    case 3: // 3 해당 Lock Group을 해제하기 위한 아이템이 부족
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_GROUP_OPEN_ERROR2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 7: // 7 이미 등록된 그룹ID가 있음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_GROUP_OPEN_ERROR1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 1:// 1 해당 ID는 LockGroupID가 아닙니다.
    case 2:// 2 해당 ID는 이미 UnLock한 Group ID 입니다.
    case 4:// 4 해당 유저 정보가 존재하지 않음
    case 5:// 5 데이터 파싱중 에러1
    case 6:// 6 해당 유저의 스킬트리 정보가 없음
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );	
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_GROUP_OPEN_UNKNOWNERROR ),
                strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            break;
        }
    }

}

void On_EVENT_CHANGE_COUPON_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHANGE_COUPON_ACK );
    SAFE_DELETE( pkBuff );

    //kRecv.m_nOK; // 성공 여부..
    //kRecv.m_kItem; // 삭제될 아이템.
    //kRecv.m_nGP; // 이녀석은 덮어 쓰시오
    switch( kRecv.m_nOK )
    {
    case 0:
        {
            g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGP );
            g_MyD3D->MyPlayer[ g_MyD3D->Get_MyPlayer() ]->m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGP );
            g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGP );

            // m_nItemType		0 영구/기간
            //					1 수량
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecDurationItem , true);
            g_pItemMgr->m_kInventory.RemoveItemList( kRecv.m_vecDelItem );

            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            break;
        }
    case 1:		//해당 아이템은 쿠폰 아이템이 아님
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_USE_COUPON_ITEM_ERROR1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
            break;
    case 2:		//해당 쿠폰을 사용하면 최대 GP 보유량 초과
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_USE_COUPON_ITEM_ERROR2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
            break;
    case 3:		//쿠폰 교환시 해당 아이템이 인벤토리에 없음
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_USE_COUPON_ITEM_ERROR3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
            break;
    case 4:		// 쿠폰 아이템 제거시 실패
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_USE_COUPON_ITEM_ERROR4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
            break;
    case -98: // 처리중
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PACKET_DELAY ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
            break;
    default: //알수 없는 ..
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );	
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_USE_COUPON_ITEM_ERROR ),
                strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
            break;
        }
    }
}

void On_EVENT_GACHA_REWARD_LIST_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KGachaRewardList);
    SAFE_DELETE(pkBuff);

    DWORD dwGachaItem = kRecv.m_dwGachaItemID / 10;

    std::map<int, std::set<GCITEMID>>::iterator itor;
    for (itor = kRecv.m_mapCollectionList.begin(); itor != kRecv.m_mapCollectionList.end(); ++itor)
    {
        std::set<GCITEMID>::iterator sit = itor->second.begin();
        std::set<GCITEMID> val;
        for (; sit != itor->second.end(); ++sit)
        {
            val.insert((*sit) / 10);
        }

        itor->second = val;
    }

    if (g_kGlobalValue.m_iCurrentGachaType == 0) {
        g_pkUIScene->GetNewClearSealDlg()->SetItemLevelList(kRecv.m_mapNeedKeyInfo);
    }

    g_pkUIScene->GetClearSealDlg()->SetMapGachaRewardList(dwGachaItem, kRecv.m_mapCollectionList);
    g_pkUIScene->GetClearSealDlg()->SetRewardItemList(kRecv.m_mapCollectionList);

    if (!g_kGlobalValue.IsSingleGacha())
        g_pkUIScene->m_pkSuperGachaDlg->SetRewardList(kRecv);

    Result_Gacha_Reward_List = 0;
}

void On_EVENT_GACHA_ACTION_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_GACHA_ACTION_ACK);

    SAFE_DELETE(pkBuff);
    switch (kRecv.m_nOK)
    {
    case 0: //¼º°ø
    {
        std::vector<KItem> vecTempItemList;

        vecTempItemList.push_back(kRecv.m_gachaItem);
        vecTempItemList.push_back(kRecv.m_keyItem);

        g_pItemMgr->SetDurationItem(vecTempItemList);

        if (g_kGlobalValue.m_iCurrentGachaType == 0) {
            g_pkUIScene->GetNewClearSealDlg()->SetSuccessGachaAction(kRecv.m_bRewardType);
        }
        else {
            g_pkUIScene->GetClearSealDlg()->SetSuccessGachaAction(kRecv.m_bRewardType);
        }

        std::wstring strMsg;
        if (kRecv.m_vecReward.empty() == false)
        {
            std::vector<KItem> vecTemp = kRecv.m_vecReward;
            g_pItemMgr->GetNewReceiveItemNum(kRecv.m_vecReward, vecTemp);

            for (int i = 0; i < (int)kRecv.m_vecReward.size(); i++)
            {
                GCItem* kItem = g_pItemMgr->GetItemData(kRecv.m_vecReward[i].m_ItemID / 10);
                KItem& kRewardItem = vecTemp[i];
                CONTINUE_NIL(kItem);

                if (kRewardItem.m_nPeriod == KItem::UNLIMITED_ITEM && kRewardItem.m_nCount == KItem::UNLIMITED_ITEM) {
                    strMsg = g_pkStrLoader->GetReplacedString(STR_ID_ITEM_RECEIVE1, "l", kItem->strItemName);
                }
                else if (kRewardItem.m_nCount != KItem::UNLIMITED_ITEM)
                {
                    DWORD dwReceiveCount = kRewardItem.m_nCount;
                    KItem* pkInvenItem = g_pItemMgr->m_kInventory.FindItemByItemID(kRewardItem.m_ItemID / 10);

                    if (pkInvenItem != NULL) // ÀÌ¹Ì Á¸Àç ÇÏ´Â ¾ÆÀÌÅÛÀÌ¸é È¹µæ ·®¸¸ º¸¿© ÁÖ±â À§ÇØ¼­.
                    {
                        int iShortCutNum = g_MyD3D->GetMyShortCutSlot()->GetCurEquipItemNum(kRecv.m_vecReward[i].m_ItemID / 10);
                        dwReceiveCount -= (pkInvenItem->m_nCount + iShortCutNum);
                    }


                    strMsg = g_pkStrLoader->GetReplacedString(STR_ID_ITEM_RECEIVE2, "li", kItem->strItemName, (int)dwReceiveCount);
                }
                else {
                    strMsg = g_pkStrLoader->GetReplacedString(STR_ID_ITEM_RECEIVE3, "li", kItem->strItemName, (int)vecTemp[i].m_nPeriod);
                }

                if (g_kGlobalValue.m_iCurrentGachaType == 0) {
                    g_pkUIScene->GetNewClearSealDlg()->SetStrMessage(strMsg);
                }
                else {
                    g_pkUIScene->GetClearSealDlg()->SetStrMessage(strMsg);
                }

                if (-1 != kItem->dwGoodsID)
                {
                    g_pkUIScene->m_pkTreaureItemBox->SetItem(kItem->dwGoodsID);
                }

                //g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            }

            g_pItemMgr->m_kInventory.AddItemList(kRecv.m_vecReward, true);
        }

        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        if (g_kGlobalValue.m_iCurrentGachaType == 0) {
            g_pkUIScene->GetNewClearSealDlg()->OnRecvGachaAck();
            g_pkUIScene->GetNewClearSealDlg()->SetParticleLife(10);
            g_pkUIScene->GetNewClearSealDlg()->SetBeadSpellItemNum(kRecv.m_gachaItem.m_nCount, kRecv.m_keyItem.m_nCount);
        }
        else {
            g_pkUIScene->GetClearSealDlg()->OnRecvGachaAck();
            g_pkUIScene->GetClearSealDlg()->SetParticleLife(10);
            g_pkUIScene->GetClearSealDlg()->SetBeadSpellItemNum(kRecv.m_gachaItem.m_nCount, kRecv.m_keyItem.m_nCount);
        }

        break;
    }
    case 1:		//²Î ÀÔ´Ï´Ù. ²ÎÀº ¾ÆÀÌÅÛÀ» °¨¼Ò ½ÃÅ²´Ù.
    {
        if (g_kGlobalValue.m_iCurrentGachaType == 0) {
            g_pkUIScene->GetNewClearSealDlg()->SetBeadSpellItemNum(kRecv.m_gachaItem.m_nCount, kRecv.m_keyItem.m_nCount);
        }
        else {
            g_pkUIScene->GetClearSealDlg()->SetBeadSpellItemNum(kRecv.m_gachaItem.m_nCount, kRecv.m_keyItem.m_nCount);
        }

        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_KDSound.Play("GACHA_FAILED");
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_ERROR1), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
    }
    break;
    case 2:		//°¡Â÷ ¾ÆÀÌÅÛÀÎµ¥ ·ÎÅÍ¸®¿¡ µî·Ï µÇÁö ¾ÊÀ½
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_ERROR2), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 3:		//ÇØ´ç ¾ÆÀÌÅÛÀº °¡Â÷ ¾ÆÀÌÅÛÀÌ ¾Æ´Ô
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_ERROR3), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 4:		// ÇØ´ç °¡Â÷ ¾ÆÀÌÅÛÀ» º¸À¯ÇÏ°í ÀÖÁö ¾ÊÀ½
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_ERROR4), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 5:		//ºÀÀÎ ÇØÁ¦¼­°¡ ºÎÁ·ÇÕ´Ï´Ù.
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_ERROR5), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 6:		// Æ®·¢Àè¼Ç ¿¡·¯
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_ERROR6), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 7:		// DB¿¡ ÇØ´ç À¯Àú°¡ Á¸ÀçÇÏÁö ¾ÊÀ½
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_ERROR7), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 8:		// DB¿¡ Á¸ÀçÇÏÁö ¾Ê´Â ¾ÆÀÌÅÛ ÀÔ´Ï´Ù.
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_ERROR8), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 9:		// 12155	ÀÌ¹Ì ¸ðµç ±¸½½ ºÀÀÎ ÇØÁ¦¸¦ ¼º°øÇÏ¿© ´õ ÀÌ»ó ºÀÀÎ ÇØÁ¦¸¦ ÇÒ ¼ö ¾ø½À´Ï´Ù.
        //g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GACHA_ERROR10 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case -98: // Ã³¸®Áß
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_PACKET_DELAY), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    default: //¾Ë¼ö ¾ø´Â ..
    {
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK);
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_ERROR9),
            strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    }
    }
    if (kRecv.m_nOK > 1)
    {
        /*if (g_pkUIScene->m_pkSuperGachaDlg->IsRenderOn())
        {
            g_pkUIScene->GetNewClearSealDlg()->OnStopAuto();
        }*/
    }
}

void On_EVENT_GACHA_OBTAINED_SET_REWARD_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_GACHA_OBTAINED_SET_REWARD_ACK);
    SAFE_DELETE(pkBuff);

    int iGachaVer = 0;

    if (g_kGlobalValue.m_iCurrentGachaType == 0) {
        iGachaVer = g_pkUIScene->GetNewClearSealDlg()->GetCurrentGachaVer();
    }
    else {
        iGachaVer = g_pkUIScene->GetClearSealDlg()->GetCurrentGachaVer();
    }

    KEVENT_GACHA_OBTAINED_SET_REWARD_ACK::iterator it = kRecv.find(iGachaVer);
    if (it == kRecv.end()) {
        return;
    }

    std::set< std::pair< DWORD, DWORD > > setList;
    std::set< std::pair< DWORD, DWORD > >::const_iterator itList = it->second.begin();
    for (; itList != it->second.end(); ++itList) {
        setList.insert(std::make_pair((itList->first) / 10, itList->second));
    }

    if (g_kGlobalValue.m_iCurrentGachaType == 0) {
        g_pkUIScene->GetNewClearSealDlg()->SetObtainedBeadList(setList);
    }
    else {
        g_pkUIScene->GetClearSealDlg()->SetObtainedBeadList(setList);
    }
}

void On_EVENT_GACHA_LEVEL_OBTAINED_SET_REWARD_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_GACHA_LEVEL_OBTAINED_SET_REWARD_ACK);
    SAFE_DELETE(pkBuff);

    int iGachaVer = g_pkUIScene->GetNewClearSealDlg()->GetCurrentGachaVer();

    KEVENT_GACHA_LEVEL_OBTAINED_SET_REWARD_ACK::iterator it = kRecv.find(iGachaVer);
    if (it == kRecv.end())
    {
        return;
    }

    g_pkUIScene->GetNewClearSealDlg()->SetObtainedBeadListForGachaLevel(it->second);
}

void On_EVENT_GACHA_SET_REWARD_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_GACHA_SET_REWARD_ACK);
    SAFE_DELETE(pkBuff);

    //kRecv.m_nOK;
    //kRecv.m_gachaItemID; // È¹µæÇÑ Á¤º¸ Ãß°¡.
    //kRecv.m_vecReward;

    switch (kRecv.m_nOK)
    {
    case 0: //¼º°ø
    {
#if defined(NATION_USA) || defined( NATION_EU )
        for (std::vector<KItem>::iterator kIt = kRecv.m_vecReward.begin(); kIt != kRecv.m_vecReward.end(); ++kIt)
        {
            g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, kIt->m_ItemID / 10, 0, false, true);
            //Àü¿¡ ´ä¾Èµé ÃÊ±âÈ­
        }
        g_pItemMgr->m_kInventory.AddItemList(kRecv.m_vecReward, true);

#else
        OnItemReceive(kRecv.m_vecReward, true, true, KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX);
#endif
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();

        if (g_kGlobalValue.m_iCurrentGachaType == 0) {
            g_pkUIScene->GetNewClearSealDlg()->AddObtainedBeadList(std::make_pair(kRecv.m_gachaItemID / 10, kRecv.m_dwType));
        }
        else {
            g_pkUIScene->GetClearSealDlg()->AddObtainedBeadList(std::make_pair(kRecv.m_gachaItemID / 10, kRecv.m_dwType));
        }
    }
    break;
    case 1: //ÀÌ¹Ì È¹µæÇÑ °¡Â÷ ¼¼Æ® ÀÔ´Ï´Ù.
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_SET_ERROR1), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 2: // °¡Â÷ ¼öÁý ¾ÆÀÌÅÛ ¸®½ºÆ®°¡ ¾ø½À´Ï´Ù.
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_SET_ERROR2), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 3: // °¡Â÷ ¼öÁý ¾ÆÀÌÅÛÀÌ ºÎÁ· ÇÕ´Ï´Ù.
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_SET_ERROR3), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 4: // °¡Â÷ ¼¼Æ® º¸»ó ¸®½ºÆ® Á¤º¸ °¡Á®¿À±â ½ÇÆÐ
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_SET_ERROR4), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 5: // °¡Â÷ ¼¼Æ® º¸»ó ¿Ï·á ±â·Ï ½ÇÆÐ
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_SET_ERROR5), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 6: // °¡Â÷ ¼¼Æ® º¸»ó ¾ÆÀÌÅÛ ¿äÃ»½Ã DB ¿À·ù.
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_SET_ERROR6), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 7: //  È¹µæ °¡´ÉÇÑ ·¹º§ÀÌ ¾Æ´Õ´Ï´Ù.
        break;
    case -98: // Ã³¸® Áö¿¬
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_PACKET_DELAY), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    default: // ¾Ë ¼ö ¾ø´Â ¿À·ù
    {
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK);
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_SET_ERROR7), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
    }
    break;
    }
}

void On_EVENT_GACHA_LEVEL_SET_REWARD_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_GACHA_SET_REWARD_ACK);
    SAFE_DELETE(pkBuff);

    //kRecv.m_nOK;
    //kRecv.m_gachaItemID; // È¹µæÇÑ Á¤º¸ Ãß°¡.
    //kRecv.m_vecReward;

    switch (kRecv.m_nOK)
    {
    case 0: //¼º°ø
    {
        OnItemReceive(kRecv.m_vecReward, true, true, KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX);
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->GetNewClearSealDlg()->AddObtainedBeadListForGachaLevel(std::make_pair(kRecv.m_gachaItemID, kRecv.m_nLevel), kRecv.m_dwType);
    }
    break;
    case 1: //ÀÌ¹Ì È¹µæÇÑ °¡Â÷ ¼¼Æ® ÀÔ´Ï´Ù.
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_SET_ERROR1), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 2: // °¡Â÷ ¼öÁý ¾ÆÀÌÅÛ ¸®½ºÆ®°¡ ¾ø½À´Ï´Ù.
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_SET_ERROR2), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 3: // °¡Â÷ ¼öÁý ¾ÆÀÌÅÛÀÌ ºÎÁ· ÇÕ´Ï´Ù.
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_SET_ERROR3), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 4: // °¡Â÷ ¼¼Æ® º¸»ó ¸®½ºÆ® Á¤º¸ °¡Á®¿À±â ½ÇÆÐ
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_SET_ERROR4), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 5: // °¡Â÷ ¼¼Æ® º¸»ó ¿Ï·á ±â·Ï ½ÇÆÐ
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_SET_ERROR5), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 6: // °¡Â÷ ¼¼Æ® º¸»ó ¾ÆÀÌÅÛ ¿äÃ»½Ã DB ¿À·ù.
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_SET_ERROR6), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    case 7: //  È¹µæ °¡´ÉÇÑ ·¹º§ÀÌ ¾Æ´Õ´Ï´Ù.
        break;
    case -98: // Ã³¸® Áö¿¬
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_PACKET_DELAY), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        break;
    default: // ¾Ë ¼ö ¾ø´Â ¿À·ù
    {
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK);
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_SET_ERROR7), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
    }
    break;
    }
}

void On_EVENT_GACHA_SET_REWARD_LIST_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KGachaRewardList);
    SAFE_DELETE(pkBuff);

    DWORD dwGachaItem = kRecv.m_dwGachaItemID / 10;

    std::map<int, std::vector<GCITEMID>>::iterator itor;
    for (itor = kRecv.m_mapSetRewardList.begin(); itor != kRecv.m_mapSetRewardList.end(); ++itor)
    {
        std::vector<GCITEMID>::iterator vit = itor->second.begin();
        for (; vit != itor->second.end(); ++vit)
        {
            (*vit) /= 10;
        }
    }

    if (g_kGlobalValue.m_iCurrentGachaType == 0) {
        g_pkUIScene->GetNewClearSealDlg()->SetItemLevelList(kRecv.m_mapNeedKeyInfo);
    }

    g_pkUIScene->GetClearSealDlg()->SetMapGachaFinalRewardList(dwGachaItem, kRecv.m_mapSetRewardList);
    g_pkUIScene->GetClearSealDlg()->SetFinalRewardtItemList(kRecv.m_mapSetRewardList);

    if (!g_kGlobalValue.IsSingleGacha())
        g_pkUIScene->m_pkSuperGachaDlg->SetRewardSetList(kRecv);

    Result_Gacha_Reward_List = 0;
}

void On_EVENT_GACHA_KEY_BUY_COUNT_NOT(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(PAIR_INT);
    SAFE_DELETE(pkBuff);

    if (g_kGlobalValue.m_iCurrentGachaType == 0) {
        g_pkUIScene->GetNewClearSealDlg()->SetGachaKeyBuyCount(kRecv.first);
    }
    else {
        g_pkUIScene->GetClearSealDlg()->SetGachaKeyBuyCount(kRecv.first);
    }
}

void On_EVENT_MISSIONSLOT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<KMissionData> );
    SAFE_DELETE( pkBuff );

    // 미니게임 완료 할때 ACK 패킷 받기 전에 도착 할것임..
    // 변경이 없으면 않오니까 도착 하면 처리 할수 있도록 해주세요..
    g_kGlobalValue.m_kUserMission.SetUserMissionList( kRecv);
    g_pkUIScene->m_pkMissionUI_S4->RefreshUI();
}
void On_EVENT_TIME_EVENT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::set<int> );

    //이벤트를 클라이언트에 등록
    SiKGCEventManager()->ClearEvents();
    SiKGCEventManager()->SetEvents( kRecv );

    SAFE_DELETE( pkBuff );
}
void On_EVENT_PERIOD_NOTICE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_PERIOD_NOTICE_NOT );

    g_kGlobalValue.m_mapCommonMsg.clear();
    for(int i=0;i<(int)kRecv.size();++i)
    {
        const int iPeriodMin = kRecv[i].first;
        const std::wstring wstrCommonMsg = kRecv[i].second;

        if( g_kGlobalValue.m_mapCommonMsg.count( iPeriodMin ) > 0 )
        {
            g_kGlobalValue.m_mapCommonMsg[ iPeriodMin ].first = timeGetTime();
            g_kGlobalValue.m_mapCommonMsg[ iPeriodMin ].second.push_back( wstrCommonMsg );
        }
        else
        {
            std::vector<std::wstring> vtString;
            vtString.push_back( wstrCommonMsg );
            g_kGlobalValue.m_mapCommonMsg.insert(std::make_pair( (int)iPeriodMin, std::make_pair( (DWORD)timeGetTime(), vtString ) ));
        }
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_FULL_COUPLE_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KCoupleInfo );
    SAFE_DELETE( pkBuff );

    // 접속시 커플 정보를 받는곳.
    SiKGCCoupleSystem()->SetMyCoupleFullInfo( kRecv );
}

void On_EVENT_MAKE_COUPLE_ACK( WPARAM wParam, LPARAM lParam )
{
/*
    kPacket_.m_nOK, 0 );
    kPacket_.m_nOK, 1 ); // 커플 요청을 할수 있는 상태가 아님.
    kPacket_.m_nOK, 2 ); // 해당 아이템은 반지 아이템이 아님
    kPacket_.m_nOK, 3 ); // 해당 아이템을 보유하고 있지 않습니다.
    kPacket_.m_nOK, 4 ); // 상대 유저가 동일 서버에 존재하지 않음
    kPacket_.m_nOK, 5 ); // 커플 요청 받을수 있는 상태가 아님.
    kPacket_.m_nOK, 6 ); // 자신에게 커플 신청 할수 없음
    kPacket_.m_nOK, 7 ); // 대상 유저에게 신청 패킷을 보내지 못했음.
    kPacket_.m_nOK, 8 ); // 커플 신청 정보가 없음.
    kPacket_.m_nOK, 9 ); // 커플 신청 거부 하였음.
    kPacket_.m_nOK, 10 ); // 커플 거절 상태 입니다.
    kPacket_.m_nOK, 11 ); // DB에 나의 유저 정보가 존재하지 않음.
    kPacket_.m_nOK, 12 ); // DB에 상대방의 유저 정보가 존재하지 않음.
    kPacket_.m_nOK, 13 ); // DB에 내가 이미 커플 상태임 
    kPacket_.m_nOK, 14 ); // DB에 상대방이 이미 커플 상태임
    kPacket_.m_nOK, 15 ); // DB에러
*/
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MAKE_COUPLE_ACK );
    SAFE_DELETE( pkBuff );
    // 커플 맺기 결과
    SiKGCCoupleSystem()->SetState( KGCCoupleSystem::GCCS_SOLO );	//일단 솔로.. 아니면 Wait 상태로 남아버린다.
    switch( kRecv.m_nOK )
    {
    case 0:
        SiKGCCoupleSystem()->SetMyCoupleFullInfo( kRecv.m_kCoupleInfo );
        SiKGCCoupleSystem()->AddCoupleUserInfo( SCoupleInfoSimple(kRecv.m_kCoupleInfo, true ) );
        g_pItemMgr->m_kInventory.RemoveItem(  kRecv.m_kRingItem.m_dwUID );
        if( kRecv.m_kCoupleInfo.m_tmRegDate < kRecv.m_kCoupleInfo.m_tmPartnerRegDate )
        {
            if( KP2P::GetInstance()->m_kMsgServer != NULL )
            {
                KP2P::GetInstance()->m_kMsgServer->Send_ForceMakeFriend( kRecv.m_kCoupleInfo.m_dwUID, g_kGlobalValue.m_kUserInfo.strNickName,
                    kRecv.m_kCoupleInfo.m_dwPartnerUID, kRecv.m_kCoupleInfo.m_strPartnerNick );
            }
        }
        //친구 차단 해제 하고 친구 등록도 해야함..

        break;
    case 2: // 2  해당 아이템은 반지 아이템이 아님
    case 3: // 3  해당 아이템을 보유하고 있지 않습니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetString(STR_ID_COUPLE_SYSTEM13) );
        break;
    case 4: // 4  상대 유저가 동일 서버에 존재하지 않음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetString(STR_ID_COUPLE_SYSTEM14) );
        break;
    case 1: // 1  커플 요청을 할수 있는 상태가 아님.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetString(STR_ID_COUPLE_SYSTE_ERROR_MSG01) );
        break;
    case 5: // 5  커플 요청 받을수 있는 상태가 아님.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetString(STR_ID_COUPLE_SYSTE_ERROR_MSG02) );
        break;
    case 6: // 6  자신에게 커플 신청 할수 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetString(STR_ID_COUPLE_SYSTE_ERROR_MSG03) );
        break;
    case 7: // 7  대상 유저에게 신청 패킷을 보내지 못했음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetString(STR_ID_COUPLE_SYSTE_ERROR_MSG04) );
        break;
    case 8: // 8  커플 신청 정보가 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetString(STR_ID_COUPLE_SYSTE_ERROR_MSG05) );
        break;
    case 9: // 9  커플 신청 거부 하였음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetReplacedString(STR_ID_COUPLE_SYSTEM12, "l", kRecv.m_kCoupleInfo.m_strPartnerNick ) );
        break;
    case 10: // 10 상대방이 오늘 하루 커플 맺기를 거부하였음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetReplacedString(STR_ID_COUPLE_SYSTEM27, "l", kRecv.m_kCoupleInfo.m_strPartnerNick ) );
        break;
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, strTemp );
        }
        break;
    }


}

void On_EVENT_MAKE_COUPLE_ASK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MAKE_COUPLE_REQ );
    SAFE_DELETE( pkBuff );
    // 다른 유저가 커플 맺을건지 물어 보는것.

    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_ACCEPT, kRecv.m_strRequesterNick, kRecv.m_strMsg, KGCUIScene::GC_MBOX_USE_NORMAL, kRecv.m_kRingItem.m_dwID/10, kRecv.m_dwRequester );

}

void On_EVENT_USE_COUPLE_ITEM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KCoupleItemData );
    SAFE_DELETE( pkBuff );
    // 일반 아이템을 커플 인벤으로 집어 넣는 행위

    switch( kRecv.m_nOK )
    {
    case 0:
        SiKGCCoupleSystem()->AddItemToInven( kRecv.m_kItem );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetString( STR_ID_COUPLE_SYSTEM19 ) );
        break;
    case 1: // 1     현재 커플 상태가 아님
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetString( STR_ID_COUPLE_SYSTEM16 ) );
        break;
    case 2: // 2     해당 아이템은 이미 옷장에 있음.
    case 7: // 7     동일한 아이템이 창고에 존재
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetString( STR_ID_COUPLE_SYSTEM17 ) );
        break;
    case 3: // 3     해당 아이템은 커플용 아이템이 아님.
    case 4: // 4     해당 아이템을 보유하고 있지 않습니다.
    case 5: // 5     나의 유저 정보가 존재하지 않음.
    case 6: // 6     상대방의 유저 정보가 존재하지 않음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetReplacedString( STR_ID_COUPLE_SYSTEM18, "i", kRecv.m_nOK ) );
        break;
    }
}

void On_EVENT_USE_COUPLE_ITEM_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KCoupleItemData );
    SAFE_DELETE( pkBuff );
    // 나의 커플이 커플 인벤에 일반 아이템 집어 넣었을때 알려줌.
    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetString( STR_ID_COUPLE_SYSTEM19 ) );
    SiKGCCoupleSystem()->AddItemToInven( kRecv.m_kItem );
}

void On_EVENT_EQUIP_COUPLE_ITEM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_EQUIP_COUPLE_ITEM_ACK );
    SAFE_DELETE( pkBuff );
    // 복장 아이템을 장착 했을때 날아옴.

    switch( kRecv.m_nOK )
    {
    case 0:
        SiKGCCoupleSystem()->ApplyEquipItemChange();
        break;
    case 1: // 1    현재 커플 상태가 아님.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetString( STR_ID_COUPLE_SYSTEM16 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 2: // 2    해당 아이템은 이미 옷장에 있음.
    case 3: // 3    해당 아이템은 커플용 아이템이 아님.
    default:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetReplacedString( STR_ID_COUPLE_SYSTEM20, "i", kRecv ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    }

    if( kRecv.m_nOK != 0 )
    {
        SiKGCCoupleSystem()->FixEquipItemChange(kRecv.m_vecEquip);
    }
    g_pkUIScene->m_pkCoupleViewer->Update();
}

void On_EVENT_EQUIP_COUPLE_ITEM_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<DWORD> );
    SAFE_DELETE( pkBuff );
    // 나의 커플이 복장을 변경 했을때 날아옴.
    SiKGCCoupleSystem()->RecvEquipItemChange( kRecv );
    g_pkUIScene->m_pkCoupleViewer->Update();
}

void On_EVENT_COUPLE_INFORMATION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_COUPLE_INFORMATION_ACK );
    SAFE_DELETE( pkBuff );
    // 룸이나 광장에서 다른 유저의 커플 정보를 받아 올때
    // OK != 0  커플이 아님..

    if( kRecv.m_nOK != 0 )
    {
        return;
    }

    SCoupleInfo sInfo;

    sInfo.dwUID = kRecv.m_dwRequesterUID;
    sInfo.dwPartnerUID = kRecv.m_dwRequesteeUID;
    sInfo.bPosition = false;
    sInfo.bPartnerPosition = true;
    sInfo.iCharType = kRecv.m_cRequesterChar;
    sInfo.iPartnerChar = kRecv.m_cRequesteeChar;
    sInfo.m_tmRegDate = kRecv.m_tmRegDate;
    sInfo.strNickName = kRecv.m_strRequester;
    sInfo.strPartnerNick = kRecv.m_strRequestee;
    sInfo.ConvertItemList( kRecv.m_vecRequesterEquip, false );
    sInfo.ConvertItemList( kRecv.m_vecRequesteeEquip, true );

    SiKGCCoupleSystem()->SetTempCoupleFullInfo( sInfo );

    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_VIEWER, L"", L"", KGCUIScene::GC_MBOX_USE_COUPLE_VIEWER_OTHERS );
}

void On_EVENT_CHANGE_COUPLE_RING_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHANGE_COUPLE_RING_ACK );
    SAFE_DELETE( pkBuff );

    // 커플 링 교체
    switch( kRecv.m_nOK )
    {
    case 0:
        SiKGCCoupleSystem()->RecvChangeCoupleRing( kRecv.m_kItem, !kRecv.m_bInven );

        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetString( STR_ID_COUPLE_SYSTEM32 ) );
        break;
    case 1: // 1    현재 커플 상태가 아님.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetString( STR_ID_COUPLE_SYSTEM16 ) );
        break;
    case 6: // 6    상대 유저가 동일 서버에 존재하지 않음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetString(STR_ID_COUPLE_SYSTEM14) );
        break;
    case 8: // 8    상대방이 거부 함.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetString(STR_ID_COUPLE_SYSTEM12) );
        break;
    case 2: // 2    해당 아이템은 반지 아이템이 아님.
    case 3: // 3    해당 아이템은 이미 옷장에 있음.
    case 4: // 4    해당 아이템을 보유하고 있지 않습니다.
    case 5: // 5    커플 인벤에 없는 아이템입니다.
    case 7: // 7    신청 정보가 없음.
    default:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_MESSAGE_OK, g_pkStrLoader->GetReplacedString( STR_ID_COUPLE_SYSTEM21, "i", kRecv.m_nOK ) );
        break;
    }

}

void On_EVENT_CHANGE_COUPLE_RING_ASK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHANGE_COUPLE_RING_REQ );
    SAFE_DELETE( pkBuff );
    // 커플 링 교체 할건지 물어 보는것.
    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_ACCEPT, L"", kRecv.m_strMsg, KGCUIScene::GC_MBOX_USE_COUPLE_RING_CHANGE, kRecv.m_kItem.m_dwID/10, kRecv.m_kItem.m_dwUID );
}

void On_EVENT_MAKE_COUPLE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MAKE_COUPLE_NOT );
    SAFE_DELETE( pkBuff );

    // 광장에서 누군가가 커플을 맺으면 그 정보를 모두에게 뿌린다.
    SCoupleInfoSimple sInfo;
    sInfo.dwUID = kRecv.m_dwUID1;
    sInfo.dwPartnerUID = kRecv.m_dwUID2;
    sInfo.strCoupleNickName = kRecv.m_strNick1;
    sInfo.vecItemInfo = sInfo.vecItemInfo;
    SiKGCCoupleSystem()->AddCoupleUserInfo(sInfo);

    sInfo.dwUID = kRecv.m_dwUID2;
    sInfo.dwPartnerUID = kRecv.m_dwUID1;
    sInfo.strCoupleNickName = kRecv.m_strNick2;
    sInfo.vecItemInfo = sInfo.vecItemInfo;
    SiKGCCoupleSystem()->AddCoupleUserInfo(sInfo);
}


void On_EVENT_DIVORCE_COUPLE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );

    SiKGCCoupleSystem()->RemoveCoupleUserInfo( SiKGCCoupleSystem()->GetUID_of_my_honey() );
    SiKGCCoupleSystem()->RemoveCoupleUserInfo( g_kGlobalValue.m_kUserInfo.dwUID );
    SiKGCCoupleSystem()->InitMyCoupleInfo();

    // 0이 아니면 커플 상태가 아니라는 것임.
    // 타이밍 차이로 커플이 해제 되었을수 있음.
}

void On_EVENT_DIVORCE_COUPLE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::wstring );
    SAFE_DELETE( pkBuff );

    // 상대방이 커플 해제 했을때 메세지가 옴..
    // 접속시나 게임 접소중일때 전달 받게 됨.
    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_COUPLE_GOODBYE, kRecv, L"", KGCUIScene::GC_MBOX_USE_COUPLE_GOODBYE_NOT );
    SiKGCCoupleSystem()->InitMyCoupleInfo();
}

void On_EVENT_DIVORCE_COUPLE_OTHER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( PAIR_DWORD );
    SAFE_DELETE( pkBuff );
    SiKGCCoupleSystem()->RemoveCoupleUserInfo( kRecv.first);
    SiKGCCoupleSystem()->RemoveCoupleUserInfo( kRecv.second );
}

void On_EVENT_CHANGE_COUPLE_CHAR_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( char );
    SAFE_DELETE( pkBuff );
    SiKGCCoupleSystem()->RecvChangeCharacter( kRecv, false );
    g_pkUIScene->m_pkCoupleViewer->Update();
}

void On_EVENT_CHANGE_COUPLE_CHAR_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( char );
    SAFE_DELETE( pkBuff );
    SiKGCCoupleSystem()->RecvChangeCharacter( kRecv, true );
    g_pkUIScene->m_pkCoupleViewer->Update();
}

void On_EVENT_COUPLEITEM_EXPIRED_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<KSimpleItem> );
    SAFE_DELETE( pkBuff );

    // 파트너의 만료된 커플 아이템.( 인벤, 커플 장착 에서 제거 해주시오. )
    SiKGCCoupleSystem()->RecvExpiredItemList( kRecv );
}

void On_EMS_S2_ADD_FRIEND_FORCE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_S2_ADD_FRIEND_FORCE_ACK );
    SAFE_DELETE( pkBuff );

    if(kRecv.m_nOK != 0) return;

    KBuddy kBuddy;
    if( SiKFriendShip()->GetBlockBuddy( kRecv.m_kFriendInfo.m_dwUserUID, kBuddy ) )
    {
        SiKFriendShip()->UnBlockBuddy( kRecv.m_kFriendInfo.m_dwUserUID );
    }
    SiKFriendShip()->AddBuddy( kRecv );
    g_pkUIScene->m_pkNateOn->SetOnlineCount();
}

void On_EMS_S2_ADD_FRIEND_FORCE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KFriend );
    SAFE_DELETE( pkBuff );

    KBuddy kBuddy;
    if( SiKFriendShip()->GetBlockBuddy( kRecv.m_dwUserUID, kBuddy ) )
    {
        SiKFriendShip()->UnBlockBuddy( kRecv.m_dwUserUID );
    }
    SiKFriendShip()->AddBuddy( kRecv );
    g_pkUIScene->m_pkNateOn->SetOnlineCount();
}

void On_EVENT_COUPLE_CHAT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );
/*
    kPacket: 0  // 성공
    kPacket: 1  // 현재 커플 상태가 아님.
    kPacket: 2  // 상대방의 유저 정보가 존재하지 않음.
    kPacket: 3  // 대상 유저에게 패킷을 보내지 못했음.
    kPacket: 4  // 채팅 블럭 상태임.
*/
}

void On_EVENT_COUPLE_CHAT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KChatData );
    SAFE_DELETE( pkBuff );

    kRecv.m_cChatType; // KChatData::MSG_COUPLE_CHAT
    kRecv.m_dwSenderUID;
    kRecv.m_strSenderNick;
    kRecv.m_dwReceiverUID;
    kRecv.m_strReceiverNick;
    kRecv.m_dwChatColor;
    kRecv.m_strChatMsg;  // 메세지...ㅋㅋ

    SiKGCCoupleSystem()->RecvCoupleChat( kRecv.m_strChatMsg );
}

void On_EVENT_COUPLE_WINDOW_STATE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );

    // 상대방의 상태.
    SiKGCCoupleSystem()->SetPartnerState( (KGCCoupleSystem::GCCoupleState)kRecv );
}

void On_EVENT_PET_COSTUM_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    typedef std::map< std:: pair<DWORD,char>, std::set<DWORD> > MAP_COSTUME;
    KSerializer ks;
    ACK_DESERIALIZE( MAP_COSTUME );
    SAFE_DELETE( pkBuff );

    MAP_COSTUME::iterator mit;
    for( mit = kRecv.begin(); mit != kRecv.end() ; ++mit )
    {
        int iPetID = g_kGlobalValue.GetPetIDFromItemID( mit->first.first / 10 );

		std::set<DWORD> rc;
        //std::for_each( mit->second.begin(), mit->second.end(), GCFUNCTOR::ItemID_S2C() );
		/*for (auto iter = mit->second.begin(); iter != mit->second.end(); ++iter)
		{
			DWORD *item = (DWORD *)&iter;
			*item /= 10;
		}*/

		for (auto iter = mit->second.begin(); iter != mit->second.end(); ++iter)
		{
			rc.insert((DWORD)* iter);
		}

        g_kGlobalValue.UpdatePetCostume( iPetID, mit->first.second, rc /*mit->second*/ );
    }
}

void On_EVENT_GET_USER_DONATION_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GET_USER_DONATION_INFO_ACK );
    SAFE_DELETE( pkBuff );

    // 처음 접속후 EVENT_GET_USER_DONATION_INFO_REQ 패킷을 보내면 응답으로
    // 자신의 기부 정보를 보내 준다.

    // 1 현재 기부 기간이 아님 (기부도, 디스플레이 기간도 아님. )
    //     kRecv.m_nOK;
    //     kRecv.m_nAccDonationPoint; // 자신의 누적 기부 금액
    //     kRecv.m_nDonationState;    // 현재 상태. 0 = 아무 상태 아님., 1 = 기부 가능, 2 = 기부 불가, 정보만 얻을수 있는 기간.

    //SiKGCContributionManager()->SetMyTotalContributionGP( kRecv.m_nAccDonationPoint );
    //SiKGCContributionManager()->SetIsContributionState( kRecv.m_nDonationState );

    //SiKGCContributionManager()->SetMinContributionPoint(kRecv.m_nMinDonationPoint);

    //int iStringNum = STR_ID_DESC_PLAYER_INFO6;
    //if(0 != kRecv.m_dwDonationUnit)
    //{
        //kRecv.m_dwDonationUnit /= 10;
        //iStringNum = STR_ID_COUNT;
    //}

    //SiKGCContributionManager()->SetContributionUnitType(kRecv.m_dwDonationUnit);
    //SiKGCContributionManager()->SetUnitTypeString(g_pkStrLoader->GetString(iStringNum));

    //KP2P::GetInstance()->Send_DonationInfoReq();
}

void On_EVENT_DONATION_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DONATION_INFO_ACK );
    SAFE_DELETE( pkBuff );

    // 광장에서 기부 NPC 클릭 하면 나오는 정보.
    //kRecv.m_nDonationState;         // 현재 상태. 0 = 아무 상태 아님., 1 = 기부 가능, 2 = 기부 불가, 정보만 얻을수 있는 기간.
    //kRecv.m_biTotalDonationPoint;   // 전체 누적 기부 액.
    //kRecv.m_nAccDonationPoint;      // 나의 누적 기부액.
    //kRecv.m_vecDonationRank;        // 현재 상태. 0 = 아무 상태 아님., 1 = 기부 가능, 2 = 기부 불가, 정보만 얻을수 있는 기간.

    //SiKGCContributionManager()->SetMyTotalContributionGP( kRecv.m_nAccDonationPoint );
    //SiKGCContributionManager()->SetTotalContributionGP( kRecv.m_biTotalDonationPoint );
    //SiKGCContributionManager()->SetIsContributionState( kRecv.m_nDonationState );
    //SiKGCContributionManager()->SetContributionRanker( kRecv.m_vecDonationRank );

    //SiKGCContributionManager()->SetContributionEventState();

    //g_pkUIScene->m_pkContributionDlg->Update();
}

void On_EVENT_DONATION_POINT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DONATION_POINT_ACK );
    SAFE_DELETE( pkBuff );

    // 기부를 하면 오는 응답.
    // 1    현재 기부 기간이 아님
    // 2    보유 금액이 기부 금액 보다 적음
    // 3    기부 실패
    // -98  처리중.

    //kRecv.m_nOK;
    //kRecv.m_nDonationState;     // 현재 상태. 0 = 아무 상태 아님., 1 = 기부 가능, 2 = 기부 불가, 정보만 얻을수 있는 기간.
    //kRecv.m_nAccDonationPoint;  // 나의 누적 기부액
    //kRecv.m_nCurrentGP;         // 나의 현재 GP
    //kRecv.m_vecRewardItems;  // 기부 후 받은 보상
    //kRecv.m_biTotalDonationPoint; // 전체 누적 기부액

    //std::wstring strMsg;
    //switch( kRecv.m_nOK )
    //{
    //case 0: //기부 성공

    //    if( kRecv.m_vecRewardItems.size() > 0 )
    //    {
    //        for(int i = 0; i < (int)kRecv.m_vecRewardItems.size(); i++ )
    //        {
    //            KItem& kReward = kRecv.m_vecRewardItems[i];
    //            GCItem* kItem = g_pItemMgr->GetItemData( kReward.m_ItemID / 10 );
    //            CONTINUE_NIL( kItem );
    //            if( kReward.m_nCount != KItem::UNLIMITED_ITEM )
    //            {
    //                int iReceiveCount = kReward.m_nCount;
    //                KItem* pkInvenItem = g_pItemMgr->m_kInventory.FindItemByItemID( kReward.m_ItemID / 10 );
    //                if( pkInvenItem != NULL )
    //                {
    //                    iReceiveCount -= pkInvenItem->m_nCount;
    //                }
    //                strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE2, "li", kItem->strItemName, iReceiveCount );
    //            }
    //            else
    //            {
    //                strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE1, "l", kItem->strItemName );
    //            }
    //            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, L"", KGCUIScene::GC_MBOX_USE_NORMAL,0, 0, false, true );
    //        }

    //        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewardItems , true);
    //    }

    //    g_pItemMgr->m_kInventory.AddItem( kRecv.m_kDonationUnit , true);

    //    g_kGlobalValue.m_kUserInfo.iGP = kRecv.m_nCurrentGP;
    //    g_MyD3D->MyPlayer[ g_MyD3D->Get_MyPlayer() ]->m_kUserInfo.iGP = kRecv.m_nCurrentGP;
    //    g_MyD3D->m_TempPlayer.m_kUserInfo.iGP = kRecv.m_nCurrentGP;

    //    SiKGCContributionManager()->SetTotalContributionGP( kRecv.m_biTotalDonationPoint );
    //    SiKGCContributionManager()->SetIsContributionState( kRecv.m_nDonationState );
    //    SiKGCContributionManager()->SetMyTotalContributionGP( kRecv.m_nAccDonationPoint );
    //    SiKGCContributionManager()->SetContributionEventState();

    //    g_pkUIScene->m_pkContributionDlg->Update();
    //    break;
    //case 1: //현재 기부 기간이 아님
    //    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_CONTRIBUTION_ERROR01), L"", KGCUIScene::GC_MBOX_USE_NORMAL,0, 0, false, true );
    //    break;
    //case 2: //보유 금액이 기부 금액 보다 적음
    //    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_CONTRIBUTION_ERROR02), L"", KGCUIScene::GC_MBOX_USE_NORMAL,0, 0, false, true );
    //    break;
    //case 3: //기부 실패
    //    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_CONTRIBUTION_ERROR03), L"", KGCUIScene::GC_MBOX_USE_NORMAL,0, 0, false, true );
    //    break;
    //case -98: //패킷 처리 지연
    //    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_CONTRIBUTION_ERROR04), L"", KGCUIScene::GC_MBOX_USE_NORMAL,0, 0, false, true );
    //    break;
    //}

    //Result_DonationPoint = kRecv.m_nOK;
    //// 	g_pkUIScene->m_pkMyInfoScene->UpdateData();
    //// 	g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
}

void On_EVENT_ADD_EXP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KAddExpInfo );
    SAFE_DELETE( pkBuff );

    kRecv.m_nOK; // 이녀석이 0이면 적용이 올바르게 된것임.. 0이 아니면 않의 값을쓰면 않됨.
    kRecv.m_cCharType; //적용된 캐릭터 타입;
    kRecv.m_biExp; // 해당 캐릭터의 현재 경험치.

    if(0 == kRecv.m_nOK && -1 != kRecv.m_cCharType)
    {
        for(int i = 0; i < (int)g_kGlobalValue.m_kUserInfo.vecCharInfo.size(); i++ )
        {
            SCharInfo &Info = g_kGlobalValue.m_kUserInfo.vecCharInfo[i];

            if( Info.iCharType == kRecv.m_cCharType )
            {
                Info.biExp = kRecv.m_biExp;
                unsigned char cResultLevel = Exp_2_Level(Info.biExp);
                Info.iLevel = cResultLevel;
                Info.kSkillInfo = kRecv.m_kSkillInfo;
            }
        }
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    }
}

void On_EVENT_VIP_ITEM_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_VIP_ITEM_LIST_NOT );
    SAFE_DELETE( pkBuff );

    // VIP뱃지로 살수 있는 아이템 목록.
    // 1.최초접속시 2.구매실패시(서버와 정보가 다른 경우)
    // kRecv // map< 캐릭터타입, map< ItemID, VIP가격 > >
    g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    g_pkUIScene->m_pkMyInfoScene->UpdateData();


    g_pkUIScene->m_pkVipGachaBox->SetItemList( kRecv );
}

void On_EVENT_BUY_FOR_VIP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BUY_FOR_VIP_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK // VIP아이템 구매시 응답.
    // kRecv.m_nCurrentVipCount // 구매후 남은 로얄VIP뱃지 수
    // kRecv.m_vecItem // 구매한 아이템이 일반 아이템이면 이안에 있음
    // kRecv.m_vecDurationItem // 구매한 아이템이 수량 아이템이면 이안에 있음
    Result_Vip_Gacha_Item = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem );
        g_pItemMgr->m_kInventory.AddItem( kRecv.m_kVipBadge,true);

        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
        g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();
        g_pkUIScene->m_pkVipGachaBox->UpdateBadgeNum();

        g_KDSound.Play( "78" );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BUY_ITEM_SUCCEEDED1 ),
        g_pkStrLoader->GetString( STR_ID_BUY_ITEM_SUCCEEDED2 ), KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );

        // 슬롯 아이템 구입 체크
        if( g_MyD3D->m_pStateMachine->GetState() == GS_CHAR_SELECT )
        {
            g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_BUT_ADD_SLOT_ITEM ) );
        } 

        break;
    case 1: // VIP뱃지 보유량 부족.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_VIP_GACHA_ERROR1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;
    case 2: // 요청한 VIP Item 정보가 서버정보와 다름.
    case 3: // VIP 아이템 얻기 DB 작업 실패 
    case 4: // VIP왕실뱃지 깎기 실패
    case -98: // 아직 진행중인 작업입니다.
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ERROR_BUY_CASH_ITEM ), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;
    }
}

void On_EVENT_LUNA_NEWYEAR_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_LUNA_NEWYEAR_ACK );
    SAFE_DELETE( pkBuff );


    // 0   성공.
    // 1   이벤트 기간이 아님
    // 2   오늘 이미 세배를 했음
    // 3   메니저에 보상 정보가 없음
    // -98 아직 처리중인 작업입니다

    kRecv.m_nOK;
    kRecv.m_nRewardGP;  // 받은 용돈.
    kRecv.m_nCurrentGP; // 용돈 + 기존 보유액 (현재의 전체 GP )
    kRecv.m_vecRewardItems; // 받은 보상 아이템

    switch( kRecv.m_nOK )
    {
    case 0:
        for(int i=0;i<(int)kRecv.m_vecRewardItems.size();++i)
        {
            g_pkUIScene->m_pkHappyNewYearNPCDlg->SetItem( kRecv.m_vecRewardItems[i].m_ItemID/10 );
        }

        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewardItems , true);

        g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nCurrentGP );

        g_pkUIScene->m_pkHappyNewYearNPCDlg->SetGpContent( g_pkStrLoader->GetReplacedString( STR_HAPPY_NEWYEAR_RECIVE_GP, "i", kRecv.m_nRewardGP ) );
        g_pkUIScene->m_pkHappyNewYearNPCDlg->SetTitleContent( g_pkStrLoader->GetString( STR_HAPPY_NEWYEAR_STRING1 + (::rand()+1)%8 ) );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_HAPPYNEWYEAR_NPC_DLG );
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_HAPPY_NEWYEAR_NOT_EVENT_TIME), L"",
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_HAPPY_NEWYEAR_ENOUGH_TODAY), L"",
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 3:
    default:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_COMMON_ERROR_P1_MSG, "i", kRecv.m_nOK), L"",
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    }

}

//void On_EVENT_CHAR_POLL_TERM_ACK( WPARAM wParam, LPARAM lParam )
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( KEVENT_CHAR_POLL_TERM_ACK );
//    SAFE_DELETE( pkBuff );
//
//    // kRecv.m_bIsPollTerm 가 true 이면 투표 시즌..
//    // kRecv.m_dwPollItemID 투표에 사용되는 Item ID 입니다.
//    // 투표 시즌이 아니면... Item ID를 사용하면 않됩니다.
//    SiKGCValentineDayManager()->SetPollState( kRecv.m_bIsPollTerm );
//    SiKGCValentineDayManager()->SetPollItemID( kRecv.m_dwPollItemID / 10 );
//    g_pkUIScene->m_pkValentineDayDlg->SetItemImg(kRecv.m_dwPollItemID / 10 );
//}
//
//void On_EVENT_CHAR_POLL_ACK( WPARAM wParam, LPARAM lParam )
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( KEVENT_CHAR_POLL_ACK );
//    SAFE_DELETE( pkBuff );
//
//    // 1  인기 투표 기간이 아님
//    // 2  적용 되는 캐릭터가 아님
//    // 3  투표용 아이템이 아님
//    // 4  투표용 아이템을 1개 이상 사용해야 함
//    // 5  투표용 아이템을 보유 하고 있지 않음
//    // 6  투표용 아이템의 수량이 부족
//
////     kRecv.m_kItem; // 투표 후 남은 아이템. OK 값이 성공이 아니면 사용하면 않됨.
//    Result_Char_Poll = kRecv.m_nOK;
//
//    DWORD dwMsgID = 0;
//
//    switch(kRecv.m_nOK)
//    {
//    case 0:
//        g_pItemMgr->m_kInventory.AddItem( kRecv.m_kItem , true);
//
//        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
//        g_pkUIScene->m_pkMyInfoScene->UpdateData();
//        SiKGCValentineDayManager()->SetPollItemCurrentCount(kRecv.m_kItem.m_nCount);
//#if defined(NATION_USA)
//        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
//            g_pkStrLoader->GetReplacedString(STR_ID_VALENTINE_DAY_SUCCESS, "i",g_pkUIScene->m_pkValentineDayDlg->GetPollCount()),
//            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//#else
//        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
//            g_pkStrLoader->GetReplacedString(STR_ID_VALENTINE_DAY_SUCCESS, "li", SiKGCValentineDayManager()->GetSelectedCharString(), g_pkUIScene->m_pkValentineDayDlg->GetPollCount()),
//            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//#endif
//        if(g_pkUIScene->m_pkValentineDayDlg->GetPollCount() > static_cast<int>(kRecv.m_kItem.m_nCount))
//            g_pkUIScene->m_pkValentineDayDlg->SetPollCount( static_cast<int>(kRecv.m_kItem.m_nCount) );
//        break;
//    case 1:
//        SiKGCValentineDayManager()->SetPollState(false);
//        g_pkUIScene->m_pkValentineDayDlg->SetOkBtnLock(true);
//
//        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_VALENTINE_DAY_ERROR1), L"",
//            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//        break;
//    case 2:
//        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_VALENTINE_DAY_ERROR2), L"",
//            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//        break;
//    case 3:
//        KP2P::GetInstance()->Send_CheckPollTerm();
//        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_VALENTINE_DAY_ERROR3), L"",
//            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//        break;
//    case 4:
//        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_VALENTINE_DAY_ERROR4), L"",
//            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//        break;
//    case 5:
//        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_VALENTINE_DAY_ERROR5), L"",
//            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//        break;
//    case 6:
//        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_VALENTINE_DAY_ERROR6), L"",
//            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//        break;
//    }
//
//
//}

// 추천
void On_EVENT_CHECK_RECOMMEND_ENABLE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHECK_RECOMMEND_ENABLE_ACK );
    SAFE_DELETE( pkBuff );

    //0 성공
    //1 이벤트 기간이 아님.
    //2 신규 혹은 복귀 유저가 아님.
    //3 DB 처리 오류.
    //4 추천을 할수 없는 상태임.
    // -98 처리중
    //kRecv.m_mapRecomBonus;// 3, 6, 9, 12 보너스..
    Result_RecomEnable = kRecv.m_nOK;

#if defined( WELCOMEBACK_FRIEND_NEW )
    g_pkUIScene->m_pkWelcomeBackNewDlg->SetItemInfo(kRecv);
#else
    g_pkUIScene->m_pkWelcomeBackDlg->SetItemInfo(kRecv);
#endif
    
    
    switch( kRecv.m_nOK )
    {
    case 0:
        g_pkUIScene->m_pkNickNameBox->SetRecommendRegisterComplete( false );
        break;
    case 1:
    case 2:
    case 3:
    case 4:
        g_pkUIScene->m_pkNickNameBox->SetRecommendRegisterComplete( true );
        break;
    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PACKET_DELAY ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
        break;
    }

}

void On_EVENT_RECOMMEND_USER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RECOMMEND_USER_ACK );
    SAFE_DELETE( pkBuff );

    Result_RecommendNickName = kRecv.m_nOK;

    //1   이벤트 기간이 아님.
    //2   신규 혹은 복귀 유저가 아님.
    //3   사용할수 없는 문자. 공백이 포함 되어 있음.
    //4   추천 요청시 잘못된 요청 범위.
    //5   DB 처리 오류.
    //6   추천을 할수 없는 상태임.
    //7   추천 대상 유저가 존재하지 않음.
    //8   더이상 이유저를 추천 할수 없음.(이유저는 추천자들이 만땅이라서..)
    //-98 처리중

    //kRecv.m_nRecomInfo.m_strNick; //내가 추천한 사람 닉네임
    //kRecv.m_nRecomInfo.m_dwLoginUID; //내가 추천한 사람 UID
    //kRecv.m_nRecomInfo.m_nState; // 내가 적어 보낸 상태..( 이 값은 추천 할때만 이렇고... 말로 설명 해주겠음.. )
}

void On_EVENT_RECOMMEND_FULL_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RECOMMEND_FULL_INFO_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK
    //1   이벤트 기간이 아님.
    //2   DB 처리 오류
    // -98 처리중

    //kRecv.m_vecNewAttendance; // 이번에 새롭게 첫 출석한 나를 추천한 사람들..
    //kRecv.m_vecCountReward; // 나를 추천한 사람들이 첫출헛 해서 받은 보상.
    //kRecv.m_vecNormalReward; // 나를 추천한 사람들이 첫출헛 해서 받은 보상.
    //kRecv.m_nRecomBonusState; // 3,6,9

    //          kRecv.m_kMyInfo   내가 추천한 사람 정보.
    //         1 ; 아직 추천인 없음
    //         2 ; 추천 하지 않음
    //         3 ; 추천 승인 대기중
    //         4 ; 추천 거절됨
    //         5 ; 추천 승인됨
    //         6 ; 첫출석 완료

    //          kRecv.m_vecRecommenders     나를 추천한 사람 정보
    //         1 ; 추천 승인 대기중
    //         2 ; 추천 거절됨 - 이건 전송 하지 않음..
    //         3 ; 추천 승인됨
    //         4 ; 첫출석 완료 - 아이템을 받을 수 있는 상태
    //         5 ; 아이템을 받

    switch( kRecv.m_nOK )
    {
    case 0:
        {
            SiKFriendShip()->SetRecommender(kRecv.m_kMyInfo, kRecv.m_vecRecommenders );

#if defined( WELCOMEBACK_FRIEND_NEW )
            g_pkUIScene->m_pkWelcomeBackNewDlg->SetRewardState(kRecv.m_nRecomBonusState);
#else
            g_pkUIScene->m_pkWelcomeBackDlg->SetRewardState(kRecv.m_nRecomBonusState);
#endif

            if( !kRecv.m_vecNormalReward.empty() )
            {
                if( !kRecv.m_vecNewAttendance.empty() )
                {
                    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_REWARD_ATTEND), L"",
                        KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false );
                }
                else
                {
                    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_RECOMMEND_REWARD_MSG), L"",
                        KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false );
                }
            }

            OnItemReceive( kRecv.m_vecNormalReward ,true, false );

            if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
            {
                g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            }
        }
        break;
    case 1:
        g_pNateOn->SetViewRecommendBtn( false );	// 1일때만 안보이게하자.
    default:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_COMMON_ERROR_P1_MSG, "i", kRecv.m_nOK), L"",
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false );
        break;
    }

    Result_recommendFullINfo = kRecv.m_nOK;
}

void On_EVENT_RECOMMENDER_ACCEPT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RECOMMENDER_ACCEPT_ACK );
    SAFE_DELETE( pkBuff );

    switch(kRecv.m_nOK)
    {
    case 0:
        SiKFriendShip()->SetRecommender(kRecv.m_vecRecommenders );
        break;
    case 1: // 그냥 넘어가
    case 2:
    case 4:
    case 5:
    case 3: // 이건 클라이언트에서 막으므로 넘어가자
    default:
        break;
    }
    //kRecv.m_nOK;
    //1   이벤트 기간이 아님.
    //2   대기 리스트에 없는 사람 승인 하려 했음.
    //3   추천 승인 최대숫자 초과.
    //4   추천 승인 패킷이 비어 있음.
    //5   DB 처리 오류.
    // -98 처리중


    // kRecv.m_vecRecommenders; // 나를 추천한 사람 전체 정보.

}
void On_EVENT_ATTENDANCE_BONUS_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ATTENDANCE_BONUS_ACK );
    SAFE_DELETE( pkBuff );
    //1   이벤트 기간이 아님.
    //2   추천 보너스 범위 오류.
    //3   이미 추천 보너스를 받았음.
    //4   DB 처리 오류.

    switch( kRecv.m_nOK )
    {
    case 0:
        {
            OnItemReceive( kRecv.m_vecNormalReward ,true, false );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_REWARD_ATTEND), L"",
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );

            if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
            {
                g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            }

#if defined( WELCOMEBACK_FRIEND_NEW )      
            g_pkUIScene->m_pkWelcomeBackNewDlg->SetRewardState( kRecv.m_nRecomBonus );
#else
            g_pkUIScene->m_pkWelcomeBackDlg->SetRewardState( kRecv.m_nRecomBonus );
#endif
        }
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RECOM_GET_REWARD_ORDER_ERR ), L"",
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 3: // 뭐라고 처리 해줘야 될 거같은데..(이미 보상을 받았음.이란 오류)
        break;
    default:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_COMMON_ERROR_P1_MSG, "i", kRecv.m_nOK), L"",
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    }

}
void On_EVENT_RECOM_DAILY_ATTENDANCE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RECOM_DAILY_ATTENDANCE_ACK );
    SAFE_DELETE( pkBuff );
//     kRecv.m_bFirst; // 첫 출석 인지.
//     kRecv.m_vecCountReward;
//     kRecv.m_vecNormalReward;

    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_REWARD_ATTEND), L"",
        KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
    OnItemReceive( kRecv.m_vecNormalReward ,false, false );

#if defined(WELCOMEBACK_FRIEND)
    g_pkUIScene->m_pkNateOn->SetNew( true );
    g_pkUIScene->m_pkRecommendList->SetNew( true );
#endif

    if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
    {
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    }
}

void On_EVENT_RECOM_CHANGE_STATE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPacketNameOK );
    SAFE_DELETE( pkBuff );

    // 0 : 누군가 나를 추천 했다.
    // 1 : 내가 추천한 사람이 나를 승인 해줬다..
    // 2 : 걔가 나를 거절했다.

    // kRecv.m_strName; // 상대방의 닉네임..
      switch(kRecv.m_nOK)
      {
      case 0:
          g_pkUIScene->m_pkNateOn->SetNew( true );    // 여기서는 버튼에만 표시하자.
          g_pkUIScene->m_pkRecommendList->SetNew( true );
          break;
      case 1:
          g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_START_RECOMMEND_EVENT, "L", kRecv.m_strName ));
          break;
      case 2:
          g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RECOMMEND_REJECT ));// 일단 말로 해놓자.
          g_pkUIScene->m_pkNickNameBox->SetRecommendRegisterComplete( false );
          break;
      }
}

void On_EVENT_RECOMMENDER_DENY_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RECOMMENDER_DENY_ACK );
    SAFE_DELETE( pkBuff );
    //kRecv.m_nOK;
    //1   이벤트 기간이 아님.
    //2   거절 요청 패킷이 비어 있음
    //3   거절 하려는 유저가 대기 리스트에 없음
    //-98  처리중.
    //kRecv.m_vecRecommenders; // 갱신 된 데이터 덮어 써야 함.

    switch(kRecv.m_nOK)
    {
    case 0:
        SiKFriendShip()->SetRecommender(kRecv.m_vecRecommenders );
        break;
    case 1:
    case 2:
    case 3:
    default:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_COMMON_ERROR_P1_MSG, "i", kRecv.m_nOK), L"",
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    }
}

void On_EVENT_GET_GCCLUB_CONNECT_BONUS_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<KItem> );

    // GC클럽유저 접속시 보너스아이템 지급
    for( UINT i = 0; i < kRecv.size(); ++i )
    {
        g_pItemMgr->m_kInventory.AddItem( kRecv[i], true );

        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_REPETITION_EVENT_BOX,
            g_pkStrLoader->GetString(STR_ID_GCCLUB_CONNECT_ITEM),
            g_pkStrLoader->GetString( STR_ID_REPETITION_MESSAGE1 ),
            KGCUIScene::GC_MBOX_USE_NORMAL, kRecv[i].m_ItemID, kRecv[i].m_ItemUID );
    }

    g_pkUIScene->m_pkMyInfoScene->UpdateData();

    SAFE_DELETE( pkBuff );
}

void On_EVENT_RAINBOW_EVENT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KRainBowEvent );
    SAFE_DELETE( pkBuff );

    // 알림 패킷 입니다.
    // 서버 입장시
    // 이벤트 변경시.
    g_kGlobalValue.m_bIsRainbowEvent = true;
    g_kGlobalValue.m_bJackPot = kRecv.m_bJackPot; // 잭팟 여부
    std::vector<KRainBowData> kTempData = kRecv.m_vecEventData;// 적용 되는 이벤트 std::vector<KRainBowData>

    float fTempStrongRatio = 1.0f;
    float fTempEnchantRatio = 1.0f;

    std::vector<KRainBowData>::iterator it = kTempData.begin();
    for( ; it != kTempData.end(); it++)
    {
        switch( it->m_nEventID)
        {
        case 0:
            g_kGlobalValue.m_iRainbowEventID = STR_ID_RAINBOW0;
            break;
        case 1:
            g_kGlobalValue.m_iRainbowEventID = STR_ID_RAINBOW1;
            break;
        case 2:
            g_kGlobalValue.m_iRainbowEventID = STR_ID_RAINBOW2;
            break;
        case 3:
            g_kGlobalValue.m_iRainbowEventID = STR_ID_RAINBOW3;
            fTempStrongRatio = it->m_fSecondaryRatio;
            break;
        case 4:
            g_kGlobalValue.m_iRainbowEventID = STR_ID_RAINBOW4;
            break;
        case 5:
            g_kGlobalValue.m_iRainbowEventID = STR_ID_RAINBOW5;
            break;
        case 6:
            g_kGlobalValue.m_iRainbowEventID = STR_ID_RAINBOW6;
            fTempEnchantRatio = it->m_fSecondaryRatio;
            break;
        case -1:
            g_kGlobalValue.m_bIsRainbowEvent = false;
            g_kGlobalValue.m_bJackPot = false; // 잭팟 여부
            kTempData.clear();
            return;
        }
    }

    KSingleton<KEnchantStrong>::GetInstance()->SetSecondaryRatio( fTempStrongRatio );

    g_pkUIScene->m_pkNewNecklaceEnchantDlg->SetSecondaryRatio( fTempEnchantRatio );		

    if( g_kGlobalValue.m_bJackPot == true )
    {
        KSignBoardData kTempSignboard;
        kTempSignboard.m_eType = KSignBoardData::SBT_SERVER_ADMIN;
#if defined(FULLMOON_EVENT)
        kTempSignboard.m_strMsg = g_pkStrLoader->GetString( STR_ID_FULLMOON_JACKPOT );
#else
        kTempSignboard.m_strMsg = g_pkStrLoader->GetString( STR_ID_RAINBOW_JACKPOT );
#endif
        SiKGCAnnounceMgr()->ReserveAnnounce( kTempSignboard );

        g_KDSound.Play( "RainbowEventSound" );

    }

    //KRainBowData 설명.
    //KRainBowData::m_nEventID; -> EventID  실재로 이녀석만 사용하게 될것 입니다.
    //KRainBowData::m_fPrimaryRatio; -> 배율  -> 적용 배율 EXP, GP, 강호 확률
    //KRainBowData::m_fSecondaryRatio; -> 보조 배율 -> 강화시 사용되는 젬, 비쥬 소비 배율
}

void On_EVENT_RAINBOW_JACKPOT_ITEM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RAINBOW_JACKPOT_ITEM_ACK );
    SAFE_DELETE( pkBuff );

    //     kRecv.m_nOK; // OK 값
    //     kRecv.m_vecItem; // 획득한 영구/기간 아이템
    //     kRecv.m_vecDurationItem; // 획득한 수량 아이템.

    switch( kRecv.m_nOK )
    {
    case 0:
        if ( kRecv.m_vecItem.empty() == false )
        {
            std::vector<KItem>::iterator it;
            for( it = kRecv.m_vecItem.begin() ; it != kRecv.m_vecItem.end(); it++)
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_LUCKY_DAY_RECEIVE_BOX, L"", L"",
                KGCUIScene::GC_MBOX_USE_NORMAL, it->m_ItemID / 10, 0, true, false );
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);
        }
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_HAPPY_NEWYEAR_NOT_EVENT_TIME) );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_NOT_EXIST_USER_INFO) );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_RAINBOW_ERROR_3) );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_RAINBOW_ERROR_4) );
        break;
    case 5:
#if defined(FULLMOON_EVENT)
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_FULLMOON_SQUARE) );
#else
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_RAINBOW_SQUARE) );
#endif
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_RAINBOW_ERROR_4) );
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_RAINBOW_ERROR_5) );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
#if defined(FULLMOON_EVENT)
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_FULLMOON_SQUARE), strTemp );
#else
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_RAINBOW_SQUARE), strTemp );
#endif
        }
        break;
    }

    g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    g_pkUIScene->m_pkMyInfoScene->UpdateData();


    //  OK 값 설명
    // 0   성공
    // 1   이벤트 기간이 아님.
    // 2   유저 정보가 없음.
    // 3   잭팟 아이템을 이미 받아 갔음.
    // 4   등록된지 않은 이벤트.
    // 5   무지개 DB처리 오류.
    // 6   잭팟 기간이 아님.
    // 7   잭팟 보상 리스트가 존재하지 않음.
    // 99  알수 없는 오류
    // 98  DB 처리중
}


void On_EVENT_MISSION_DATE_CHANGE_NOT( WPARAM wParam, LPARAM lParam )
{
    // 알림 패킷입니다.
    // 하루가 지났을 경우 해당 패킷을 받아서 클라이언트에게 알려줍니다.
    // 금일 생길 아이템.
    //NOT(지정한 시간 경과시) 을 부를때와 접속 및 NOT에서 Req를 날려답신으로 ACK 호출 됨으로....
    //메시지 박스의 두번 호출이 우려됨 ㅠ,.ㅠ 으로 인해 부울...... 사용.....
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );
    g_bViewMsgBox  = true;
    g_pkUIScene->m_pkTreaureItemBox->SetItem( kRecv / 10 );
    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, kRecv / 10, REQ_MSG_NONE, false, false );
}

void On_EVENT_MISSION_DATE_CHANGE_ACK( WPARAM wParam, LPARAM lParam )
{
    //로그인 시...
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MISSION_DATE_CHANGE_ACK );
    SAFE_DELETE( pkBuff );
    std::wstring str;
    bool bDelItem = false; //지워진 아이템이나 미션이 있는지 검사.

    switch( kRecv.m_nOK )
    {
    case 0:
        if(kRecv.m_vecItemDel.size() > 0)
        {
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItemDel, true );
            bDelItem = true;
        }
        if(kRecv.m_setMissionList.size() != 0)
        {
            std::set<int>::iterator it = kRecv.m_setMissionList.begin();
            for(;it != kRecv.m_setMissionList.end();it++)
            {
                if(g_kGlobalValue.m_kUserMission.IsUserMission(*it)) continue;
                g_kGlobalValue.m_kUserMission.DeleteMission( *it );
                g_kGlobalValue.m_kUserCollectionMission.DeleteCollectionMission( *it );
                g_kGlobalValue.m_kUserMission.RefreshUserMission();
                bDelItem = true;
            }
        }
        if(bDelItem)
        {
            str	 =	g_pkStrLoader->GetString( STR_ID_DELETE_CASH_MISSION );			
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,str, L"", KGCUIScene::GC_MBOX_USE_NORMAL, REQ_MSG_NONE, 0, false, true );
        }
        if ( kRecv.m_vecItemAdd.size() != 0)
        {
            std::vector<KItem>::iterator kIt = kRecv.m_vecItemAdd.begin();
            if(! g_bViewMsgBox)
            {
                for(;kIt != kRecv.m_vecItemAdd.end();kIt++)
                {
                    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, kIt->m_ItemID/10, REQ_MSG_NONE, false, false );
                }
            }
            g_bViewMsgBox = false;
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItemAdd, true );
        }
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->m_pkMissionUI_S4->RefreshUI();

        //  룸안이면
        if ( g_MyD3D->m_pStateMachine->IsStateRoom() ) 
        {
            g_pkUIScene->m_pkRoomSceneS6->UpdateMissionData();
        }

        break;
    case 3 :
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, L"", L"체험 아이디는 지급을 하지 않습니다.", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    default:
        //	g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, L"", L"일일 미션 메시지 에러.", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    }
    //     kRecv.m_nOK; // OK 값.
    //     kRecv.m_vecDurationItemDel; // 삭제된 아이템 리스트. 
    //     kRecv.m_vecDurationItemIns; // 획득한 수량 아이템 리스트.
    //     kRecv.m_setMissionList;     // 삭제된 미션 리스트

    // ok값 설명
    // 0 : 성공
    // 1 : 이미 금일 아이템 지급
    // 2 : DB에 지급한 아이템 로그 기록 실패
    //3
}


void On_EVENT_ITEM_TRADE_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ITEM_TRADE_LIST_NOT );
    SAFE_DELETE( pkBuff );

    g_MyD3D->m_kItemMgr.SetTradeItem( kRecv.m_mapTradeList, kRecv.m_mapTradeAllList );
}

void On_EVENT_ITEM_TRADE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ITEM_TRADE_ACK );
    SAFE_DELETE( pkBuff );

    //  OK 값 설명
    // 0   성공
    // 1   해당 아이템 가져오기 실패.
    // 2   해당 아이템 갯수가 부족하다.
    // 3   서버 보상 교환 아이템 가져오기 실패.
    // 4   해당 아이템 DB처리 오류.
    // 5   교환 아이템 타입 설정 오류
    // 99  알수 없는 오류
    // 98  DB 처리중

    switch(kRecv.m_nOK)
    {
    case 0:
        {
            std::wstring strMsg;

            if( kRecv.m_vecItem.size() > 0 )
            {
                for(int i = 0; i < (int)kRecv.m_vecItem.size(); i++ )
                {
                    KItem& kReward = kRecv.m_vecItem[i];
                    GCItem* kItem = g_pItemMgr->GetItemData( kReward.m_ItemID / 10 );
                    CONTINUE_NIL( kItem );
                    if( kReward.m_nCount != KItem::UNLIMITED_ITEM )
                    {
                        int iReceiveCount = kReward.m_nCount;
                        KItem* pkInvenItem = g_pItemMgr->m_kInventory.FindItemByItemID( kReward.m_ItemID/10 );
                        if( pkInvenItem != NULL )
                        {
                            iReceiveCount -= pkInvenItem->m_nCount;
                        }

                        int iUseCount = 0;
                        KItem* pkUseItem = g_pItemMgr->m_kInventory.FindItemByItemID( kRecv.m_kUseItem.m_ItemID/10 );
                        if( pkUseItem != NULL )
                        {
                            iUseCount = pkUseItem->m_nCount;
                        }
                        iUseCount -= kRecv.m_kUseItem.m_nCount;

                        strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_TRADE_DURATION_ITEM, "lili", g_pItemMgr->GetItemName((DWORD)kReward.m_ItemID/10), iReceiveCount, 
                            g_pItemMgr->GetItemName((DWORD)kRecv.m_kUseItem.m_ItemID/10), iUseCount );	// @4 개 @3을 @2개 @1로 바꾸다
                    }
                    else
                    {
                        strMsg = g_pkStrLoader->GetString(STR_ID_ITEM_TRADE_NORMAL_ITEM);
                    }
                    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, L"",
                        KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
                }
                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);
            }

            g_pItemMgr->m_kInventory.AddItem( kRecv.m_kUseItem , true);

            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
#if	defined(NATION_USA) || defined(NATION_EU)
            g_pkUIScene->m_pkVipGachaBox->UpdateBadgeNum();
#endif
        }
        break;
    default:
        break;
    }
}


void On_EVENT_GET_GCCLUB_ATTEND_BONUS_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<KItem> );

    // GC클럽유저 출석시 보너스아이템 지급
    // kRecv.m_vecItem;          // 획득한 일반 아이템(std::vector<KItemInfo>)
    // kRecv.m_vecDurationItem;  // 획득한 수량성 아이템(std::vector<KDurationItemInfo>)

    if( kRecv.empty() == false )
    {
        g_pItemMgr->m_kInventory.AddItemList( kRecv , true);
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"",KGCUIScene::GC_MBOX_USE_NORMAL, kRecv[0].m_ItemID,0 ,true, false);
    }

    if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
    {
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_CAPSULE_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CAPSULE_LIST_NOT );
    SAFE_DELETE( pkBuff );

    // 광장 입장 or 캡슐구매시 가격이 서버와 다를때, 보냄.
    // map< pair<캐릭터ID,아이템종류>,vector<캡슐정보> >
    // std::map< std::pair<int,int>, std::vector<KCapsule> >
    g_pkUIScene->m_pkGPCapsuleDlg->SetCapsuleInfo(kRecv);
}

void On_EVENT_OPEN_CAPSULE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_OPEN_CAPSULE_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK
    // 0 : 성공
    // 1 : 해당하는 GP 캡슐 정보가 없음.
    // 2 : GP가 부족함.
    // 3 : 가격 정보가 다르다.(EVENT_CAPSULE_LIST_NOT 다시 보냄)
    // 4 : 아이템 등급 확률 이상.
    // 5 : 캡슐 뽑기 꽝. 100퍼센트를 보장하면 나오면 안됨.
    // 6 : 캡슐 아이템인데, Lottry에 등록되지 않음.
    // 7 ; 없는 캡슐 아이템 등급입니다.
    // 8 : GP캡슐 아이템 얻기 DB 작업 실패
    // 9 ; 크리스탈 아이템 가져오기 실패
    // 10; 크리스탈 보유량이 부족함
    // -98 : 아직 처리중인 작업입니다

    // kRecv.m_nRemain         : GP 잔액, 크리스탈 남은 갯수
    // kRecv.m_vecItem         : 획득한 일반 아이템
    // kRecv.m_vecDurationItem : 획득한 수량성 아이템

    switch(kRecv.m_nOK)
    {
    case 0:
        {
            std::wstring strMsg;
            g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nRemain );
            g_pkUIScene->m_pkGPCapsuleDlg->UpdateGP();
            if( kRecv.m_vecItem.size() > 0 )
            {

                for(int i = 0; i < (int)kRecv.m_vecItem.size(); i++ )
                {
                    GCItem* kItem = g_pItemMgr->GetItemData( kRecv.m_vecItem[i].m_ItemID / 10 );
                    CONTINUE_NIL( kItem );
                    g_pkUIScene->m_pkGPCapsuleObtainWnd->SetItem( kItem );
                    g_pkUIScene->m_pkGPCapsuleDlg->m_pkGPCapsuleItemListDlg->SetObtainItemID( kRecv.m_vecItem[i].m_ItemID / 10 );
                    //g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GP_CAPSULE_OBTAIN_DLG, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
                }

                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);
            }
            g_pkUIScene->m_pkGPCapsuleDlg->SetCapsuleBtnToolTipOff(false);
            g_pkUIScene->m_pkGPCapsuleDlg->SetParticleTime( 200 );
            g_pkUIScene->m_pkGPCapsuleDlg->m_pkGPCapsuleItemListDlg->UpdatePage();
        }
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GP_CAPSULE_MESSAGE_OK, L"해당캡슐정보없음", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GP_CAPSULE_MESSAGE_OK, g_pkStrLoader->GetString(STR_ID_GP_CAPSULE_NOT_ENOUGH_GP), L"",
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GP_CAPSULE_MESSAGE_OK, L"가격정보다름", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GP_CAPSULE_MESSAGE_OK, L"아이템등급확률이상", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GP_CAPSULE_MESSAGE_OK, L"꽝!!!", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GP_CAPSULE_MESSAGE_OK, L"잘못된 레이턴시", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GP_CAPSULE_MESSAGE_OK, L"없는 캡슐 아이템 등급", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 8:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GP_CAPSULE_MESSAGE_OK, L"캡슐아이템 얻기 DB작업실패", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 9:
        // 크리스탈 아이템 가져오기 실패
        break;
    case 10:
        // 크리스탈 보유량이 부족함
        break;
    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GP_CAPSULE_MESSAGE_OK, L"처리지연", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    default: // 알수 없는 오류
        break;
    }

    // 에러값을 받더라도 락을 걸어버린 버튼들은 다시 살려주자. 아니면 아무것도 할 수가 없다...
    if( kRecv.m_nOK != 0 )
    {
        g_pkUIScene->m_pkGPCapsuleDlg->LockAll(false);
        g_pkUIScene->m_pkGPCapsuleDlg->m_pkGPCapsuleItemListDlg->LockAll(false);
        g_pkUIScene->m_pkGPCapsuleDlg->SetCapsuleBtnToolTipOff(true);
    }
}

void On_EVENT_CAPSULE_RESULT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CAPSULE_RESULT_NOT );
    SAFE_DELETE( pkBuff );

    // 레어,이벤트 등급의 아이템 뽑았을때 광장내 유저 전체에게 보냄.
    // kRecv.m_dwUserUID;   // 유저UID
    // kRecv.m_nItemGrade;  // 아이템 등급
    // kRecv.m_dwItemID;    // 아이템ID

    std::vector< DWORD >& vecUsers = SiGCSquare()->GetUIDVector();

    ////아이템 뿌려줄곳...
    for( int i = 0 ; i < (int)vecUsers.size() ; i++ )
    {
        if( vecUsers[i] == kRecv.m_dwUserUID && vecUsers[i] != g_kGlobalValue.m_kUserInfo.dwUID )
        {
            SiGCSquare()->SetGPCItemID(kRecv.m_dwItemID, kRecv.m_dwUserUID, (int)(GC_FPS_LIMIT * 3.0f) );
        }
    }
}

void On_EVENT_XTRAP_AUTH_REQ( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSerBuffer );
    SAFE_DELETE( pkBuff );
    // Erase Buffer
}

void On_EVENT_SET_EXP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KAddExpInfo );
    SAFE_DELETE( pkBuff );

    kRecv.m_nOK; // 이녀석이 0이면 적용이 올바르게 된것임.. 0이 아니면 않의 값을쓰면 않됨.
    kRecv.m_cCharType; //적용된 캐릭터 타입;
    kRecv.m_biExp; // 해당 캐릭터의 현재 경험치.

    if(0 == kRecv.m_nOK && -1 != kRecv.m_cCharType)
    {
        for(int i = 0; i < (int)g_kGlobalValue.m_kUserInfo.vecCharInfo.size(); i++ )
        {
            SCharInfo &Info = g_kGlobalValue.m_kUserInfo.vecCharInfo[i];

            if( Info.iCharType == kRecv.m_cCharType )
            {
                Info.biExp = kRecv.m_biExp;
                unsigned char cResultLevel = Exp_2_Level(Info.biExp);
                Info.iLevel = cResultLevel;
                Info.kSkillInfo = kRecv.m_kSkillInfo;
            }
        }
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    }
}

void On_EVENT_DUNGEON_HACKING_USER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DUNGEON_HACKING_USER_NOT );
    SAFE_DELETE( pkBuff );

    // 던전해킹감지 알림.
    //
    // MINIGAME_TIME_SCORE   = 1,    // 미니게임 시간대비 점수대 이상
    // DUNGEON_STAGE_COUNT   = 2,    // 던전 최소 스테이지수보다 적음
    // DUNGEON_CLEAR_TIME    = 3,    // 던전 최단 클리어시간보다 ?음
    // ATK_HACK              = 4,    // 공격력 해킹
    // INC_ATK_RATE_HACK     = 5,    // 공격력증가율 해킹
    // CLIENT_ALL_KILL       = 6,    // 클라이언트 올킬(방장이 범인)
    // CLIENT_MON_HP         = 7,    // 클라이언트 몬스터HP해킹(방장이 범인)
    // CLIENT_PARTY_USER	 = 8,    // 클라이언트 해킹 플레이랑 같이 플레이한 파티원
    //
    // kRecv.m_setHackType;  // 이번에 걸린 해킹타입
    // kRecv.m_nHackCount;   // 누적 해킹 횟수

    std::set<int>::iterator itorParty = kRecv.m_setHackType.find(KEVENT_DUNGEON_HACKING_USER_NOT::CLIENT_PARTY_USER);

    if( itorParty != kRecv.m_setHackType.end() )
    {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK2, g_pkStrLoader->GetString(STR_ID_DUGEON_HACKING_CHECK_PARTNER), L"",
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
    }
    else
    {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DUGEON_HACKING_CHECK), L"",
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
    }


    g_pkQuestManager->InitHackingCheckData();
}

void On_EVENT_CHANGE_VIRTUAL_CASH_COUPON_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHANGE_VIRTUAL_CASH_COUPON_ACK );
    SAFE_DELETE( pkBuff );

    //kRecv.m_nOK; // 성공 여부..
    //kRecv.m_kItem; // 삭제될 아이템.
    //kRecv.m_nVirtualCashPoint; // 이녀석은 덮어 쓰시오

    // On_EVENT_CHANGE_COUPON_REQ  를 참고해주세요. 동일한 방식...
    if( kRecv.m_nOK == 0 )
    {
        g_kGlobalValue.m_dwVirtualCash = kRecv.m_nVirtualCashPoint;

        // m_nItemType		0 영구/기간
        //					1 수량
        g_pItemMgr->m_kInventory.RemoveItem( kRecv.m_kItem.m_dwUID );
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);

        switch( g_MyD3D->m_pStateMachine->GetState() )
        {
        case GS_SHOP_CASH:
            g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
            break;
        case GS_SHOP_GP:
            g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();
            break;

        case GS_MY_INFO:
        case GS_MY_INFO_FROM_ROOM:
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            break;
        }
    }
    else
    {

    }
}

void On_EVENT_MISSION_PACK_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MISSION_PACK_LIST_NOT  );
    SAFE_DELETE( pkBuff );

    g_kGlobalValue.m_kUserMission.SetPackageMission(kRecv);
}

void On_EVENT_MISSION_PACK_REGIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MISSION_PACK_REGIST_ACK );
    SAFE_DELETE( pkBuff );

// 	0     // 성공
// 	1     //미션 패키지 등록시 해당 아이템이 미션패키지 아이템 아님. )
// 	2     //미션 패키지 등록요청시 해당 아이템이 인벤토리에 없음. )
// 	3     //미션 패키지를 통한 미션 등록 실패 - 이미 등록된 미션 입니다.
// 	4     //미션 패키지를 통한 미션 등록 실패 - 이미 완료한 미션 입니다.
// 	-98  // 미션팩 등록 요청 중이다.
    std::wstring strMsg = L"";

    switch(kRecv.m_nOK)
    {
    case 0: //성공
        {
            if( GCIT_PERIOD == kRecv.m_kItem.m_cItemType)
            {
                GCITEMUID dwPeriodItemUID =   kRecv.m_kItem.m_dwUID;
                g_pItemMgr->m_kInventory.RemoveItem(dwPeriodItemUID );
            }
            else
            {
                std::vector<GCITEMUID> vecDecItemUID;
                GCITEMUID dwDurationItemUID =  kRecv.m_kItem.m_dwUID;
                g_pItemMgr->DecDurationItem( dwDurationItemUID, &vecDecItemUID );
            }

            //패키지 미션 자동 등록 - 자동등록된 미션은 안 보여주고 그냥 등록하고, 그 다음 느낌표 띄워서 표시!
            std::vector< KMissionData >::iterator vit = kRecv.m_vecAutoMission.begin();

            for (; vit != kRecv.m_vecAutoMission.end(); ++vit )
            {
                g_kGlobalValue.m_kUserMission.AddMission( vit->m_dwMissionID );
                g_kGlobalValue.m_kUserCollectionMission.AddCollectionMission( vit->m_dwMissionID );
            }

            g_kGlobalValue.m_kUserMission.SetAutoMission( kRecv.m_vecAutoMission );
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
        }

        strMsg = g_pkStrLoader->GetString(STR_ID_REGISTER_MISSION_ERROR0);
        break;
    case 1: // 미션 패키지 등록시 해당 아이템이 미션패키지 아이템 아님
        strMsg = g_pkStrLoader->GetString(STR_ID_REGISTER_MISSION_ERROR5);
        break;
    case 2: // 미션 패키지 등록요청시 해당 아이템이 인벤토리에 없음.
        strMsg = g_pkStrLoader->GetString(STR_ID_GACHA_ERROR8);
        break;
    case 3: //미션 패키지를 통한 미션 등록 실패 ) 이미 등록된 미션
        strMsg = g_pkStrLoader->GetString(STR_ID_REGISTER_MISSION_ERROR6);
        break;
    case 4: //미션 패키지를 통한 미션 등록 실패 ) 이미 완료한 미션
        strMsg = g_pkStrLoader->GetString(STR_ID_REGISTER_MISSION_ERROR7);
        break;
    case -98: // 미션팩 등록 요청 중이다.
        strMsg = g_pkStrLoader->GetString(STR_ID_PACKET_DELAY);
        break;
    default: // 알 수 없는 오류
        strMsg = g_pkStrLoader->GetReplacedString( STR_ID_REGISTER_MISSION_ERROR11 , "i", kRecv.m_nOK);
        break;
    }

    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg );

    Result_RegistMissionPackage = kRecv.m_nOK;
}

void On_EVENT_HELL_TICKET_FREE_MODE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::set<int> );
    SAFE_DELETE( pkBuff );

    g_kGlobalValue.SetFreeDungeonInHellMode(kRecv);
    g_kGlobalValue.AddFreeWorldMapInHellMode();
}

void On_EVENT_GAME_COUPON_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GAME_COUPON_LIST_ACK );
    SAFE_DELETE( pkBuff );

    // 쿠폰NPC 클릭시 게임쿠폰이벤트 리스트 전달.
    // map<이벤트UID, 게임쿠폰정보>
    // std::vector< KGameCouponInfo >
    g_pkUIScene->m_pkCouponNPCDlg->SetCouponInfo(kRecv);
}

void On_EVENT_USE_GAME_COUPON_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_USE_GAME_COUPON_ACK );
    SAFE_DELETE( pkBuff );

    // 게임쿠폰 사용결과
    // kRecv.m_nOK;              // 쿠폰입력 결과
    // kRecv.m_vecItem;          // 획득한 일반 아이템
    // kRecv.m_vecDurationItem;  // 획득한 수량성 아이템

    //0   성공
    //1   유저 정보가 없음.
    //2   해당 이벤트가 없거나 이벤트 기간이 아님.
    //3   입력할 수 없는 문자가 포함되어 있습니다.
    //4   쿠폰 번호가 이미 사용되었음.
    //5   게임쿠폰 아이템넣기 DB작업 실패
    //6   쿠폰이 존재하지 않음
    //7   쿠폰 체크 조건이 다름_패스워드
    //8   쿠폰 체크 조건이 다름_이벤트
    //9   패스워드가 틀림
    //11  쿠폰과 이벤트 정보가 연결되어 있지 않음
    //12  쿠폰과 아이템 정보가 연결되어 있지 않음
    //14  트랜잭션 에러
    //-98 아직 처리중인 작업입니다.

    switch( kRecv.m_nOK )
    {
    case 0:
        {
            g_pkUIScene->m_pkCouponNPCDlg->m_iCountInput = 0;
            std::wstring strMsg;
            if( kRecv.m_vecItem.size() > 0 )
            {
                GCItem* kItem;
                for(int i = 0; i < (int)kRecv.m_vecItem.size(); i++ )
                {
                    KItem& kReward = kRecv.m_vecItem[i];
                    kItem = g_pItemMgr->GetItemData( kReward.m_ItemID / 10 );
                    CONTINUE_NIL( kItem );

                    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, kItem->dwGoodsID, 0, false, true );
                }
                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);
            }

            //g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_COUPON_NPC_INPUT_SUCCESS), L"",
            //	KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );

            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();

        }
        break;
    case 1:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NOT_EXIST_USER_INFO ) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            break;
        }
    case 2:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_COUPON_NPC_EVENT_END), L"",
                KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            break;
        }
    case 3:
    case 4:
        {
            g_pkUIScene->m_pkCouponNPCDlg->m_iCountInput++;

            if( g_pkUIScene->m_pkCouponNPCDlg->m_iCountInput > 5 )
            {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_COUPON_NP_OVER_INCORRECT_INPUT), L"",
                    KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
                g_pkUIScene->m_pkCouponNPCDlg->m_iCountInput = 0;

                KP2P::GetInstance()->Send_GameCouponFailNot();
            }
            else
            {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_COUPON_NPC_INCORRECT_COUPON), L"",
                    KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            }
            break;
        }
    case 5:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_ALREADY_USED_COUPON), L"",
                KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
    case 6: // 6 : 게임쿠폰 아이템넣기 DB작업 실패
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_COUPON_NPC_INCORRECT_COUPON), L"",
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 7: // 7 : 일일 입력 한도 횟수 초과
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_EVENT_COUPOON_INPUT_ERROR), L"",
                KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
    case -98:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_PACKET_DELAY), L"",
                KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            break;
        }
        break;
    default: // 알수없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_COUPON_NPC_INCORRECT_COUPON), strTemp,
                KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
    }

    g_pkUIScene->m_pkCouponNPCDlg->m_bClickedInputBtn = false;
    Result_CouponCode_Input = kRecv.m_nOK;
}
void On_EVENT_WEB_GACHA_COIN_TRADE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_WEB_GACHA_COIN_TRADE_ACK );
    SAFE_DELETE( pkBuff );
    //  OK 값 설명
    // 0    성공
    // 1    해당 아이템 가져오기 실패.
    // 2    웹 가챠 교환권의 아이템 번호가 서버랑 틀리다
    // 3    웹 가챠 교환권의 아이템갯수가 서버랑 틀리다
    // 4    존재하지 않는 유저이다.
    // 5    유저의 가챠코인이 존재하지 않는다.
    // 6    해당 아이템 DB처리 오류.
    // 99  알수 없는 오류
    // 98  DB 처리중

    switch(kRecv.m_nOK)
    {
    case 0:
        {
            std::wstring strMsg;
            int iExchageCoinNum = kRecv.m_nWebGachaCoin - g_kGlobalValue.m_dwGachaCoin;
            g_kGlobalValue.m_dwGachaCoin = kRecv.m_nWebGachaCoin;

            if( kRecv.m_vecUseItem.size() > 0 )
            {				
                for(int i = 0; i < (int)kRecv.m_vecUseItem.size(); i++ )
                {
                    DWORD dwReceiveCount = kRecv.m_vecUseItem[i].m_nCount;
                    KItem* kInventoryItem = NULL;
                    if( g_pItemMgr->FindInventoryForItemID( kRecv.m_vecUseItem[i].m_ItemID / 10, &kInventoryItem ) )
                    {
                        dwReceiveCount -= kInventoryItem->m_nInitCount;
                    }
                    GCItem* kItem = g_pItemMgr->GetItemData( kRecv.m_vecUseItem[i].m_ItemID / 10);
                    CONTINUE_NIL(kItem);								
                }								
                g_MyD3D->m_kItemMgr.SetDurationItem( kRecv.m_vecUseItem );
            }			

            strMsg = g_pkStrLoader->GetReplacedString( STR_ID_EXCHANGE_GACHA_COIN, "i", iExchageCoinNum );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, L"" );

            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
            g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();

            break;
        }
    default:
        {
            break;
        }
    }
}
void On_ENU_ITEM_BUY_INFO_NOT( WPARAM wParam, LPARAM lParam ) // 로긴 서버에서 보내줌..
{
    KSerializer ks;
    ACK_DESERIALIZE( KItemBuyInfo );
    SAFE_DELETE( pkBuff );

    kRecv.m_bBuyEnable;     //구매 가능 한가?
    kRecv.m_vecItemRange;   // 해당 아이템의 Range 정보. std::vector<std::pair<DWORD,DWORD> >
    kRecv.m_mapRecommInfo; // Recomm 정보..< ItemID, Recomm Level >

    if ( false == g_pItemMgr->GetItemBuyInfo() )
    {//소트에서 아이템 데이터를 읽기 전에 이 패킷이 도착하였을때 데이터를 저장해놓는다
        g_pItemMgr->KeepItemBuyInfoData( kRecv );
        g_pItemMgr->SetItemBuyInfo( true );
    }
    else
    {//소트에서 이미 아이템데이터를 읽고난 다음 이 패킷이 왔다는 것
        g_pItemMgr->SetItemBuyInfoData( kRecv );
    }
}


void On_EVENT_INVITE_FRIEND_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<KInviteUserInfo> );
    SAFE_DELETE( pkBuff );
    // 이거는 작성 하시오..

    kRecv; // 아래는 구조체 멤버..
    //KInviteUserInfo::m_dwUserUID;
    //KInviteUserInfo::m_strNickName;
    //KInviteUserInfo::m_cGrade;
    //KInviteUserInfo::m_cBestCharGrade;

    SiKGCInviteManager()->SetInviteFriendUserList( kRecv, GCNateOn::FRIEND_MODE);
    SiKGCInviteManager()->SetCurrentPage(0);


    if (g_pkUIScene->m_pkInviteRequestBox){
        g_pkUIScene->m_pkInviteRequestBox->UpdateFriendUserList();
        g_pkUIScene->m_pkInviteRequestBox->SetUserListTitle( g_pkStrLoader->GetString( STR_ID_INVITING ) );
    }
    

}


void On_EVENT_CO_OP_EVENT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CO_OP_EVENT_NOT );
    SAFE_DELETE( pkBuff );

    //kRecv.m_nEventID; // 제휴 이벤트 ID
    //kRecv.m_dwMoneyItemID; // 화폐로 사용할 Item ID
    //kRecv.m_mapEventItems; // 판매 하는 아이템 리스트.std::map<DWORD,KCoopEventItem>
        //KCoopEventItem::m_nSlotID; // 슬롯 아이디
        //KCoopEventItem::m_dwItemID; // 판매 되는 아이템 ID
        //KCoopEventItem::m_nFactor; // 판매 하는 수량/기간. -1이면 영구
        //KCoopEventItem::m_nPrice; // 가격

    g_pkUIScene->m_pkCooperationEventDlg->SetEventID( kRecv.m_nEventID );
    g_pkUIScene->m_pkCooperationEventDlg->SetMoneyItemID( kRecv.m_dwMoneyItemID / 10);

    std::map< int, KCoopEventItem>::iterator mit = kRecv.m_mapEventItems.begin();
    for(; mit != kRecv.m_mapEventItems.end(); ++mit)
    {
        mit->second.m_dwItemID /= 10;
    }

    g_pkUIScene->m_pkCooperationEventDlg->SetCoopEventItemInfo( kRecv.m_mapEventItems );
}

void On_EVENT_CO_OP_ITEM_BUY_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CO_OP_ITEM_BUY_ACK );
    SAFE_DELETE( pkBuff );
    kRecv.m_nOK;
    kRecv.m_kMoneyItem;         // 남은 화폐 아이템 정보.
    kRecv.m_vecItem;            // 구매한 아이템이 들어 있음.

    //OK 값 설명..
    // 0     성공
    // 1     제휴 이벤트 기간이 아님.
    // 2     요청한 아이템은 이벤트 아이템이아님.(판매 하는 아이템이 아님.)
    // 3     충분한 화폐아이템이 없음.
    // 4     제휴 아이템 얻기 실패_쿼리 실패.
    // 5     제휴 아이템 얻기 실패_없는 아이템.
    // -98   DB 처리중

    std::wstring strMsg;
    std::wstring strTemp;

    switch( kRecv.m_nOK)
    {
    case 0:
        {
            g_pItemMgr->m_kInventory.AddItem( kRecv.m_kMoneyItem , true);

            if( false == kRecv.m_vecItem.empty())
            {
                std::vector<KItem> vecTemp = kRecv.m_vecItem;
                g_pItemMgr->GetNewReceiveItemNum(kRecv.m_vecItem, vecTemp);

                for(int i = 0; i < (int)kRecv.m_vecItem.size(); i++ )
                {
                    GCItem* kItem = g_pItemMgr->GetItemData( kRecv.m_vecItem[i].m_ItemID / 10 );
                    KItem& kReward = vecTemp[i];
                    CONTINUE_NIL( kItem );

                    if( kReward.m_nPeriod == KItem::UNLIMITED_ITEM && kReward.m_nCount == KItem::UNLIMITED_ITEM ) {
                        strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE1, "l", kItem->strItemName );
                    }
                    else if( kReward.m_nCount != KItem::UNLIMITED_ITEM ) {
                        DWORD dwReceiveCount = kReward.m_nCount;
                        KItem* kInventoryItem = g_pItemMgr->m_kInventory.FindItemByItemID( kReward.m_ItemID / 10 );
                        if( kInventoryItem != NULL )
                        {
                            dwReceiveCount -= kInventoryItem->m_nCount;
                        }
                        CONTINUE_NIL(kItem);
                        strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE2, "li", kItem->strItemName, (int)dwReceiveCount );
                    }
                    else {
                        strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE3, "li", kItem->strItemName, (int) vecTemp[i].m_nPeriod );
                    }
                }

                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);
            }

            g_pkUIScene->m_pkMyInfoScene->UpdateData();
        }

        break;
    case 1:// 1     제휴 이벤트 기간이 아님.
        strMsg = g_pkStrLoader->GetString(STR_ID_COOPERATION_EVENT_ERROR1);
        break;
    case 2:// 2     요청한 아이템은 이벤트 아이템이아님.(판매 하는 아이템이 아님.)
        strMsg = g_pkStrLoader->GetString(STR_ID_COOPERATION_EVENT_ERROR2);
        break;
    case 3:// 3     충분한 화폐아이템이 없음.
        strMsg = g_pkStrLoader->GetString(STR_ID_COOPERATION_EVENT_ERROR3);
        break;
    case 4:// 4     제휴 아이템 얻기 실패_쿼리 실패.
        strMsg = g_pkStrLoader->GetString(STR_ID_COOPERATION_EVENT_ERROR4);
        break;
    case 5:// 5     제휴 아이템 얻기 실패_없는 아이템.
        strMsg = g_pkStrLoader->GetString(STR_ID_COOPERATION_EVENT_ERROR5);
        break;
    case -98:// -98   DB 처리중
        strMsg = g_pkStrLoader->GetString( STR_ID_PACKET_DELAY );
        break;
    default://알 수 없는 오류
        {
            strMsg = g_pkStrLoader->GetString( STR_ID_ENCHANT_RESULT9 );
            strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        }
        break;
    }

    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
    Result_Buy_CooperationItem = kRecv.m_nOK;
}

void On_EVENT_SUBSCRIPTION_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    // 응모이벤트 전체 정보 전달
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SUBSCRIPTION_INFO_NOT );
    SAFE_DELETE( pkBuff );

    // kRecv
    // map< 이벤트UID, pair< 이벤트정보, 나의 획득 쿠폰 개수 > >
    // std::map<int, std::pair<KSubscription,DWORD> >
    g_kGlobalValue.m_mapSubscriptionEvent.clear();
    g_kGlobalValue.m_mapSubscriptionEvent = kRecv;
    g_pkUIScene->m_pkSubscriptionDlg->SaveEventID();

}

void On_EVENT_CURRENT_SUBSCRIPTION_GIFT_NUM_ACK( WPARAM wParam, LPARAM lParam )
{
    // 현재 진행중인 응모이벤트의 남은 경품 수량 정보
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CURRENT_SUBSCRIPTION_GIFT_NUM_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv
    // map< 응모이벤트UID, prir< 현재 남은 경품개수, 내가 응모한 횟수 > >
    // std::map<int, std::pair<DWORD,DWORD> >  KEVENT_CURRENT_SUBSCRIPTION_GIFT_NUM_ACK

    std::map<int, std::pair<DWORD,DWORD> >::iterator mit = kRecv.begin();

    if( mit != kRecv.end() )
    {
        g_pkUIScene->m_pkSubscriptionDlg->SetCurrentAmount( (int)mit->second.first );
    }
    else
    {
        g_pkUIScene->m_pkSubscriptionDlg->SetCurrentAmount(0);
    }    
    
    g_pkUIScene->m_pkSubscriptionDlg->Update();


}


void On_EVENT_SUBSCRIPT_ACK( WPARAM wParam, LPARAM lParam )
{
    // 응모하기 결과
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SUBSCRIPT_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK;              // 응모하기 결과값
    // kRecv.m_nEventUID;        // 이벤트UID
    // kRecv.m_dwCurrentGiftNum; // 현재 남은 경품 개수
    // kRecv.m_dwMySubscriptionGiftCout; // 내가 응모한 총 횟수
    // kRecv.m_kTicketItem;      // 사용한 응모권 정보
    // kRecv.m_vecItem;          // 받은 경품
    // kRecv.m_vecDurationItem;  // 받은 경품

    // kRecv.m_nOK
    // 0 ; // 성공
    // 1 ; // 해당 이벤트가 없음
    // 2 ; // 1회 응모시 필요한 응모권 개수보다 적음
    // 3 ; // 요청한 응모권 수량보다 인벤 수량이 적다.
    // 4 ; // 남은 경품수량보다 많이 요청했다.
    // 5 ; // 응모하기 DB작업 실패.
    // -98 ; // 처리중.

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        {
            g_pkUIScene->m_pkSubscriptionDlg->SetCurrentAmount( kRecv.m_nCurrentGiftNum );
            g_pkUIScene->m_pkSubscriptionDlg->SetHoldingAmount( kRecv.m_kTicketItem.m_nCount );
            g_pkUIScene->m_pkSubscriptionBox->SetHoldingAmount( kRecv.m_kTicketItem.m_nCount );

            g_pItemMgr->m_kInventory.AddItem( kRecv.m_kTicketItem , true);

            std::wstring strMsg;
            if( kRecv.m_vecItem.size() > 0 )
            {

                for(int i = 0; i < (int)kRecv.m_vecItem.size(); i++ )
                {
                    std::wstring strItemName;
                    KItem& kReward = kRecv.m_vecItem[i];
                    GCItem* kItem = g_pItemMgr->GetItemData( kReward.m_ItemID / 10 );
                    CONTINUE_NIL( kItem );

                    int nReceiveCount = 0;
                    if( kReward.m_nCount != KItem::UNLIMITED_ITEM )
                    {
                        nReceiveCount = kReward.m_nCount;
                        const KItem* pkInvenItem = g_pItemMgr->m_kInventory.FindItem(kReward.m_ItemID/10,kReward.m_ItemUID);
                        if( pkInvenItem != NULL )
                            nReceiveCount -= pkInvenItem->m_nCount;

                        g_pkUIScene->m_pkSubscriptionDlg->SetAcquiredAmount(kReward.m_nCount);

                        strItemName  = kItem->strItemName;
                        strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE2, "li", strItemName,nReceiveCount);
                    }
                }
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);
            }
        }
        break;
    case 1: // 해당 이벤트가 없음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_SUBSCRIPTION_ERROR_MSG5),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 2: // 1회 응모시 필요한 응모권 개수보다 적음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_SUBSCRIPTION_ERROR_MSG1, "i", g_pkUIScene->m_pkSubscriptionDlg->GetNeedAmount()), 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 3: // 요청한 응모권 수량보다 인벤 수량이 적다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_SUBSCRIPTION_ERROR_MSG2),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 4: // 남은 경품수량보다 많이 요청했다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_SUBSCRIPTION_ERROR_MSG3),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 5: // 응모하기 DB작업 실패.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case -98: // 이미 처리 중인 작업입니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_SUBSCRIPTION_ERROR_MSG4),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    default: // 알수없는오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_BINDING_PET_ERROR1),
                strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        }
        break;
    }
    g_pkUIScene->m_pkSubscriptionBox->StopAll(false);
}
void On_EVENT_NPC_GIFTS_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::set<int> );
    SAFE_DELETE( pkBuff );

    // 이벤트 알림(최초,갱신)
    // std::set<int> kRecv; // 활성화된 이벤트ID 리스트만 보냄.

    g_kGlobalValue.m_setGiftsEvent = kRecv;
}
void On_EVENT_NPC_GIFTS_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_NPC_GIFTS_ACK );
    SAFE_DELETE( pkBuff );

    // 광장 NPC클릭시 아이템받음
    // kRecv.m_nOK;             // OK 값(성공여부)
    // kRecv.m_nEventID;        // 해당 EventID
    // kRecv.m_vecItem;         // 획득한 영구/기간 아이템
    // kRecv.m_vecDurationItem; // 획득한 수량 아이템.

    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        {
            if( kRecv.m_vecItem.size() > 0 )
            {
                GCItem* kItem;
                for(int i = 0; i < (int)kRecv.m_vecItem.size(); i++ )
                {
                    KItem& kReward = kRecv.m_vecItem[i];
                    int nReceiveCount = 0;

                    if( kReward.m_nCount != KItem::UNLIMITED_ITEM )
                    {
                        nReceiveCount = kReward.m_nCount;
                        KItem* kInventoryItem = g_pItemMgr->m_kInventory.FindItemByItemID( kReward.m_ItemID/10);
                        if( kInventoryItem != NULL )
                        {
                            nReceiveCount -= kInventoryItem->m_nCount;
                        }
                    }
                    kItem = g_pItemMgr->GetItemData( kReward.m_ItemID / 10);
                    CONTINUE_NIL(kItem);
                    g_pkUIScene->m_pkItemReceiveBox->AddItem( kReward.m_ItemUID, nReceiveCount);
                }
                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);
            }

            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GITFS_MESSAGE), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_ITEM_RECEIVE, L"", L"", KGCUIScene::GC_MBOX_GIFTS_OK, 0, 0, false, false);
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();

            break;
        }
    case 3: // 1일1회 보상 아이템이 이미 받았음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GITFS_MESSAGE_ALREADY_RECEIVED), L"",
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 1: // 해당 이벤트가 없음
    case 2: // 보상 아이템이 비어있음
    case 4: // 아이템넣기 DB작업 실패.
    case -98: // 아직 처리중인 작업입니다.
    default: // 알수 없는 오류(실패)
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_COMMON_ERROR_P1_MSG, "i", kRecv.m_nOK), L"",
                KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        }
        break;
    }
}

void On_EVENT_CENTER_ROOM_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CENTER_ROOM_LIST_ACK );
    SAFE_DELETE( pkBuff );
    // 0 - 정상
    // 1 - 목록이 비어 있습니다.
    // 2 - 해당 카테고리 모드 목록이 없습니다.
    // 3 - 해당 페이지가 존재하지 않습니다. (사용안함)
    // 4 - 목록 전송 주기가 짧습니다.
    switch( kRecv.m_nOK )
    {
    case 0: // 성공
        {
            SiKGCRoomListManager()->UpdateRoomList( kRecv.m_vecRoomList, kRecv.m_nCurrentPage, kRecv.m_nMaxPage );
            break;
        }
    case 1: // 목록이 비어 있습니다.
    case 2: // 해당 카테고리 모드 목록이 없습니다.
        {
            // 룸 리스트를 지워준다
            SiKGCRoomListManager()->ClearRoomList();
            break;
        }
    }

    // UI 업데이트..
    if( g_MyD3D->m_pStateMachine != NULL )
    {
         g_pkUIScene->m_pkGuildLobbyDlg->m_pkGuildRoomList->UpdateRoomList();

         //SiKGCRoomManager()->ClearRoomFilter();
         //for( int i = 0 ; i < GC_GMC_COUNT ; ++i )
         //{
         //    if( SiKGCRoomManager()->IsAvailableCategory( EChannelType::CT_GUILD, static_cast<EGCGameModeCategory>(i) ) == false )
         //        continue;

         //    KGCRoomListManager::EFILTER_CATEGORY eCategory;
         //    eCategory = SiKGCRoomManager()->GetFilterEnumFromCategory( (EGCGameModeCategory)i );
         //    SiKGCRoomManager()->SetFilterEnable( eCategory );
         //}
    }
}

//void On_EVENT_GUILD_UPDATE_NOTICE_BROAD( WPARAM wParam, LPARAM lParam )
//{
//    //KSerializer ks;
//    //ACK_DESERIALIZE( KGuildNoticeList );
//    //SAFE_DELETE( pkBuff );
//
//    //m_iMsgId 가 다음과 같음
//    //GN_NOTICE       = 0,  공지
//    //GN_RULE         = 1,  규칙
//    //GN_GUILDWAR     = 2,  길드전 공지
//}

// New Guild
void On_EVENT_GUILD_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GUILD_LIST_NOT );
    SAFE_DELETE( pkBuff );
    // kRecv.m_iOK;              // 페이지 정보 요청 결과
    // kRecv.m_iPageNum;         // 현재 페이지
    // kRecv.m_iTotalPageNum;    // 총 페이지
    // kRecv.m_kCompBuff;        // 길드리스트
    std::vector<KNGuildInfo> kSimpleGuildInfoList;

    switch ( kRecv.m_nOK )
    {
    case 0: // 성공
        kRecv.m_kCompBuff.UnCompress();
        ks.BeginReading( &kRecv.m_kCompBuff );
        ks.Get( kSimpleGuildInfoList );
        ks.EndReading();

        g_pkUIScene->m_pkGuildListDlg->SetDetailGuildInfo(kSimpleGuildInfoList, kRecv.m_nPageNum, kRecv.m_nTotalPageNum);
        break;
    case 1: // 정의되지 않은 정렬타입
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_NO_DEFINED_SORT), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 2: // 길드목록 검색 갱신주기가 ?음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_LIST_UPDATE_ERROR), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 3: // 길드검색 DB처리 실패
    case 7: // 페이지 빌드 처리 중 데이터가 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 4: // 검색어가 다르니 검색 초기화함.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_SEARCH_ERROR), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );

            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
                g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9) + strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        break;
    }
    //중복입력 막기위해서 버튼 락 걸어둔거 풀어준다
    g_pkUIScene->m_pkGuildListDlg->SetPressBtn(false);
}
void On_EVENT_JOIN_GUILD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_JOIN_GUILD_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK;              // 길드가입 결과
    // kRecv.m_kGuildUserInfo;   // 내 길드원 정보(가입성공시 전달)
    // kRecv.m_kGuildInfo;		 // 내 길드정보
    // kRecv.m_mapGuildUserList
    switch (kRecv.m_nOK )
    {
    case 0: // 성공 (가입취소요청 완료)
        g_kGlobalValue.m_kGuildUserInfo = kRecv.m_kGuildUserInfo;
        g_kGlobalValue.m_kGuildInfo = kRecv.m_kGuildInfo;
        g_kGlobalValue.m_mapNGuildUserInfo = kRecv.m_mapGuildUserList;

        if( kRecv.m_kGuildUserInfo.m_cMemberLevel == KNGuildUserInfo::GL_JOINER)
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX,
                g_pkStrLoader->GetString(STR_ID_NEW_GUILD_JOIN_REQ_TITLE), g_pkStrLoader->GetString(STR_ID_NEW_GUILD_JOIN_ALLOW_REQ),
                KGCUIScene::GC_MBOX_GUILD_JOIN_RESULT, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        else
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX,
                g_pkStrLoader->GetString(STR_ID_NEW_GUILD_JOINER_ALLOW_TITLE), g_pkStrLoader->GetString(STR_ID_NEW_GUILD_JOINER_ALLOW_RESULT),
                KGCUIScene::GC_MBOX_GUILD_JOIN_RESULT, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
            KP2P::GetInstance()->m_kMsgServer->Send_GuildAllMemberListReq(g_kGlobalValue.m_kGuildUserInfo.m_dwUserUID, g_kGlobalValue.m_kGuildInfo.m_dwUID);
        }
        g_pkUIScene->m_pkGuildListDlg->UpdateWaitingJoinerState();
        break;
    case 1: // 이미 길드 가입 신청중인 상태
    case 2: // 이미 길드 가입상태.
    case 6: // 길드가입시 이미 가임유저임.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_ALREADY_JOIN_STATE), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 3: // 길드가입시 유저정보 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NOT_EXIST_USER_INFO), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 4: // 길드가입시 길드정보 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR03), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 5: // 길드가입시 가입중지상태임.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_CONNECTION_MSG_TITLE),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_JOIN_STOP_STATE), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 7: // 길드가입시 DB처리 에러
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 9: // 인원 초과로 가입할 수 없음 
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_CONNECTION_MSG_TITLE),
            g_pkStrLoader->GetString(STR_ID_JOIN_GUILD_MAX_NUM), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
                g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9)+strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        break;
    }
}

// 여기까지 했음
void On_EVENT_CANCEL_JOIN_GUILD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CANCEL_JOIN_GUILD_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK;        // 길드가입취소 결과
    // kRecv.m_dwGuildUID; // 탈퇴신청한 길드UID

    switch (kRecv.m_nOK )
    {
    case 0: // 성공 (가입취소요청 완료)
        g_kGlobalValue.m_kGuildInfo.m_dwUID = 0;
        g_kGlobalValue.m_mapNGuildUserInfo.clear();
        g_kGlobalValue.m_kGuildUserInfo.Init();
        break;
    case 1: // 유저정보 없음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NOT_EXIST_USER_INFO), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 2: // 길드정보 없음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR03), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 3: // 탈퇴 등급 아님(길마 혹은 DB에 등록되지 않은 등급)
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR03), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 4: // DB처리 에러
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
                g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9) + strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        break;
    }
}
void On_EVENT_CREATE_GUILD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CREATE_GUILD_ACK );
    SAFE_DELETE( pkBuff );
//     kRecv.m_nOK               // 생성결과
//     kRecv.m_kGuildInfo;       // 길드정보(생성 성공시 전달)
//     kRecv.m_vecGuildNotice;   // 길드공지(생성 성공시 전달)
//     kRecv.m_mapGuildUserList; // 길드맴버정보(생성 성공시 전달)
    std::map<DWORD, KNGuildUserInfo>::iterator mit;
    switch (kRecv.m_nOK )
    {
    case 0: // 성공 (길드생성요청 완료)
        g_kGlobalValue.m_kGuildInfo = kRecv.m_kGuildInfo;
        g_kGlobalValue.m_mapNGuildUserInfo.clear();
        g_kGlobalValue.m_mapNGuildUserInfo = kRecv.m_mapGuildUserList;
        g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_iGamePoint );

        mit = g_kGlobalValue.m_mapNGuildUserInfo.find(g_kGlobalValue.m_kUserInfo.dwUID);
        if( mit != g_kGlobalValue.m_mapNGuildUserInfo.end() )
            g_kGlobalValue.m_kGuildUserInfo = mit->second;

        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CREATE_SUCCESS_TITLE),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CREATE_SUCCESS_DESC), KGCUIScene::GC_MBOX_USE_CREATE_GUILD_UPDATE, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 1: // 길드생성시 길드명이 길이 조건이 안맞음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CREATE_ERROR1), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 2: // 길드생성시 조건레벨 이상의 캐릭터가 없다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CREATE_ERROR2), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 3: // 길드생성시 필요GP량 부족.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CREATE_ERROR3), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 4: // 유저정보 없음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NOT_EXIST_USER_INFO), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 5: // 길드이름 중에 특수문자가 있음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CREATE_ERROR4), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 6: // 길드이름 중복
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CREATE_ERROR5), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 7: // URL 중복
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CREATE_ERROR6), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 8: // 이미 가입유저임
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CREATE_ERROR7), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 9: // DB처리 에러
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4 ), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 10: // 길드생성시 길드이름 중에 금지어 있음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CREATE_ERROR8), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 11: // 길드생성시 URL 중에 특수문자가 있음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CREATE_ERROR9), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case -98: // 아직 처리중인 작업
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_PLANT_TREE_10), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );

        break;
    }
}

void On_EVENT_EDIT_GUILD_NOTICE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KNGuildNoticeList );
    SAFE_DELETE( pkBuff );

    switch ( kRecv.m_nOK )
    {
    case 0: // 성공
        for( int i = 0; i < static_cast<int>(kRecv.m_vecNotice.size()); i++ )
        {
            switch( kRecv.m_vecNotice[i].m_nMsgID)
            {
            case KNGuildNotice::GN_COMMENT:
                g_kGlobalValue.m_kGuildInfo.m_strComment = kRecv.m_vecNotice[i].m_strMsg;
                g_pkUIScene->m_pkGuildDlg->SetGuildNotice(kRecv.m_vecNotice[i].m_strMsg, KNGuildNotice::GN_COMMENT);
                break;
            case KNGuildNotice::GN_NOTICE_1:
                g_pkUIScene->m_pkGuildDlg->SetGuildNotice(kRecv.m_vecNotice[i].m_strMsg, KNGuildNotice::GN_NOTICE_1);
                break;
            case KNGuildNotice::GN_NOTICE_2:
                g_pkUIScene->m_pkGuildDlg->SetGuildNotice(kRecv.m_vecNotice[i].m_strMsg, KNGuildNotice::GN_NOTICE_2);
                break;
            }
        }
        break;
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
                g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9 ) + strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        break;
    }
}
void On_EVENT_EDIT_GUILD_NAME_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_EDIT_GUILD_NAME_ACK );
    SAFE_DELETE( pkBuff );

    //0   성공.
    //1   길드명변경시 유저 정보 없음.
    //2   길드명변경시 길드원이 아님.
    //3   길드명변경시 길드마스터가 아님.
    //4   길드명변경시 금지어 포함.
    //5   길드명변경시 DB금지문자 포함.
    //6   길드명변경시 길드정보 없음.
    //7   길드명변경시 DB처리 에러.
    //8   길드명변경시 필요 아이템 없음.
    //9   길드명변경시 길드명이 길이 조건이 안맞음.
    //10  길드명 변경시 길드가 존재하지 않음.	
    //11  길드명 변경시 중복된 길드이름.
    switch ( kRecv.m_nOK )
    {
    case 0: // 성공
        g_kGlobalValue.m_kGuildInfo.m_strName = kRecv.m_strGuildName;
        //사용한 아이템을 갱신한다. 아이템 표시창에 갱신도 필요하겠지...
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CHANGE_COMPLETE),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_NAME_CHANGE_SUCCESS), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NOT_EXIST_USER_INFO), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR01), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR04), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_INCLUDE_SLANG), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_DB_NO_USE_CHARACTER), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR03), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 8:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_NO_NAME_CHANGE_ITEM), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 9:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CREATE_ERROR1), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 10:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_NO_EXIST_GUILD), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 11:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5), 
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_OVERLAP_GUILD_NAME), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
                g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9 ) + strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        break;
    }
}
void On_EVENT_CHANGE_GUILD_JOIN_SETTING_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KNGuildJoinPolicy );
    SAFE_DELETE( pkBuff );

    switch ( kRecv.m_nOK )
    {
    case 0: // 성공
        g_kGlobalValue.m_kGuildInfo.m_ucJoinSetting = kRecv.m_ucMethod;
        g_pkUIScene->m_pkGuildListDlg->UpdateGuildList();
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CHANGE_COMPLETE),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CHANGE_JOIN_USAGE), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 9: // 인원 초과로 실패 
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_CONNECTION_MSG_TITLE),
            g_pkStrLoader->GetString(STR_ID_GUILD_JOIN_SETTING_MAX_NUM), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
                g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9 )+strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        break;
    }
}

void On_EVENT_EDIT_GUILD_URL_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KNGuildURL );
    SAFE_DELETE( pkBuff );

//1  길드 URL 변경시 길드가 존재하지 않음
//2  길드 URL 변경시 URL 길이 에러
//3  길드 URL 변경시 길드원이 아님
//4  길드 URL 변경시 길드마스터가 아님
//5  길드 URL 변경시 유저 정보 없음
//6  길드 URL 변경시 길드 정보 없음
//7  길드 URL 변경시 DB처리 에러.
//8  길드 URL 변경시 특수문자 포함됨.

    switch ( kRecv.m_nOK )
    {
    case 0: // 성공
        g_kGlobalValue.m_kGuildInfo.m_strURL = kRecv.m_strURL;
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_CONNECTION_MSG_TITLE),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CHANGE_COMPLETE), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9 ), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_URL_LENGTH_ERROR), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR01), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR04), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NOT_EXIST_USER_INFO), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR03), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 7:
        // 길드 URL 변경시 DB처리 에러.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 8:
        // 길드 URL 변경시 특수문자 포함됨.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CREATE_ERROR9), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
                g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9 ) + strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        break;
    }
}
void On_EVENT_BREAKUP_GUILD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BREAKUP_GUILD_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK : 길드해산 결과
    // kRecv.m_dwGuildUID : 해체된 길드UID

    switch (kRecv.m_nOK )
    {
    case 0: // 성공
        g_kGlobalValue.m_kGuildInfo.m_dwUID = 0;
        g_kGlobalValue.m_mapNGuildUserInfo.clear();
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_NEW_GUILD_DESTROY_ALERT_TITLE),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_DESTROY_RESULT_MSG), KGCUIScene::GC_MBOX_GUILD_SQUARE_OUT, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0);
        break;
    case 1: // 길드해산시 길드원이 아님.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR01), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 2: // 길드해산시 길드마스터가 아님.
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR04), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 3: // 길드해산시 유저정보 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NOT_EXIST_USER_INFO), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 4: // 길드해산시 길드정보 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR03), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 6: // 길드해산시 DB처리 에러.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
                g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9 )+strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        break;
    }
}
void On_EVENT_UPDATE_GUILD_STATE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( PAIR_UCHAR );
    SAFE_DELETE( pkBuff );
    // kRecv.first : 이전상태
    // kRecv.second : 현재상태

    switch (kRecv.second )
    {
    case KNGuildInfo::GG_BREAKUP: // 길드 해산(삭제)
        g_kGlobalValue.m_kGuildInfo.Init();
        g_kGlobalValue.m_kGuildUserInfo.Init();
        g_kGlobalValue.m_mapNGuildUserInfo.clear();

        //추방된 길드원들은 게임중이거나 룸에 있을 때는 전부 강제퇴장 시키겠다. 그리고 남아 있는 유저들에게는 메시지를 쏴준다.
        if( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_GUILD_BATTLE && kRecv.second == KNGuildUserInfo::OT_DRUMOUT)
        {
            if( g_MyD3D->m_pStateMachine->GetState() == GS_GAME )
                g_pStateGame->OnExitGame();
            else
                g_MyD3D->m_pStateMachine->ExitRoom(false);

            g_pkChatManager->AddChatMsg( g_pkStrLoader->GetReplacedString(STR_ID_NEW_GUILD_OUT_MESSAGE_IN_GAME, "l", g_kGlobalValue.m_kGuildUserInfo.m_strNickName),
                KGCChatManager::CHAT_TYPE_ADMIN );
        }
        else if( SiGCSquare()->GetSquareType() == KSquareInfo::ST_GUILD )
        {
            g_pkSquareOverlayUI->ExitSquare();
        }
        else if( SiKGCRoomManager()->IsChannelRoomList() )
        {
            g_MyD3D->m_pStateMachine->ExitRoom(false);
        }

        //게임 스테이트에 따라서 해당 씬을 업데이트 해주자!
        switch( g_MyD3D->m_pStateMachine->GetState() )
        {
        case GS_WORLDMAP:
            g_pkUIScene->m_pkWorldMapScene->Initialize();
            g_pkUIScene->m_pkWorldMapContainer->Initialize();
            break;
        case GS_MY_INFO:
        case GS_MY_INFO_FROM_ROOM:
            g_pkUIScene->m_pkMyInfoScene->Initialize();
            break;
        case GS_SHOP_CASH:
            g_pkUIScene->m_pkCashShopScene->Initialize();
        case GS_SHOP_GP:
            g_pkUIScene->m_pkGPShopScene->Initialize();
            break;
        case GS_MATCH:
            g_pkUIScene->m_pkMatchScene->Initialize();
            break;
        }
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_NEW_GUILD_DESTROY_ALERT_TITLE),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_DESTROY_RESULT_MSG ), KGCUIScene::GC_MBOX_GUILD_JOIN_RESULT, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case KNGuildInfo::GG_NEWBIE: // 신생 길드
        g_kGlobalValue.m_kGuildInfo.m_ucGrade = kRecv.second;
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_CONNECTION_MSG_TITLE),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_GRADE_DOWN_MESSAGE ), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case KNGuildInfo::GG_OFFICIAL: // 정규 길드
        g_kGlobalValue.m_kGuildInfo.m_ucGrade = kRecv.second;
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_CONNECTION_MSG_TITLE),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_GRADE_UP_MESSAGE ), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.second );	
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
                g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9 )+strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        break;
    }
}

void On_EVENT_CHANGE_GUILD_MEMBER_LEVEL_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KChangeGuildMemberInfo );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK;                  // 결과
    // kRecv.m_dwGuildUID;           // 길드UID
    // kRecv.m_vecChangeMemberLevel; // pair<UserUID,MemberLevel>

    switch (kRecv.m_nOK )
    {
    case 0: // 성공
        for( int i =0; i < static_cast<int>(kRecv.m_vecChangeMemberLevel.size()); i++ )
        {
            std::map< DWORD, KNGuildUserInfo >::iterator mit = g_kGlobalValue.m_mapNGuildUserInfo.find(kRecv.m_vecChangeMemberLevel[i].first);
            if( mit != g_kGlobalValue.m_mapNGuildUserInfo.end() )
            {
                mit->second.m_cMemberLevel = kRecv.m_vecChangeMemberLevel[i].second;
                //자기 정보는 바로 갱신하자
                if( mit->second.m_dwUserUID == g_kGlobalValue.m_kGuildUserInfo.m_dwUserUID )
                {
                    if( g_kGlobalValue.m_kGuildUserInfo.m_cMemberLevel == KNGuildUserInfo::GL_MASTER )
                        g_pkUIScene->m_pkGuildDlg->OnClose();
                    g_kGlobalValue.m_kGuildUserInfo.m_cMemberLevel = mit->second.m_cMemberLevel;
                }
            }
        }
        g_pkUIScene->m_pkGuildDlg->UpdateAll();
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CHANGE_COMPLETE),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_GRADE_CHANGE), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 1: // 길드맴버레벨 변경요청시 정보가 비어있음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR08), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 2: // 길드맴버레벨 변경요청시 길드원이 아니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR01), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 3: // 길드맴버레벨 변경요청시 길드마스터 위임은 한번에 한명씩만 가능.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR02), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 4: // 길드맴버레벨 변경요청시 유저정보 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NOT_EXIST_USER_INFO), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 5: // 길드맴버레벨 변경요청시 길드정보 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR03), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 6: // 길드맴버레벨 변경요청시 길드마스터가 아님.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR04), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 7: // 길드맴버레벨 변경요청시 변경대상이 일반길드원이나 제너럴이 아님.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR05), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 8: // 길드맴버레벨 변경요청시 입력인자의 등급이 잘못되었음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR06), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 9: // 길드맴버레벨 변경요청시 DB처리 오류.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 10:// 길드맴버레벨 변경요청시 길드마스터를 탈퇴시킬수 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR07), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
                g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9)+strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        break;
    }
}
void On_EVENT_SELF_DRUMOUT_GUILD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SELF_DRUMOUT_GUILD_ACK );
    SAFE_DELETE( pkBuff );

    switch ( kRecv.m_nOK )
    {
    case 0: // 성공
        //길드탈퇴가 이뤄졌다면 길드정보의 길드UID를 0으로 셋팅한다. 0이어여야 길드가 없는 상태이다.
        //g_kGlobalValue.m_kGuildInfo.m_dwUID = 0;
        g_kGlobalValue.m_kGuildInfo.Init();
        g_kGlobalValue.m_mapNGuildUserInfo.clear();
        g_kGlobalValue.m_kGuildUserInfo.m_cMemberLevel = -1;
        break;
    case 1: // 유저정보 없음
        break;
    case 2: // 길드정보 없음
        break;
    case 3: // 탈퇴 등급 아님(길마 혹은 DB에 등록되지 않은 등급)
        break;
    case 4: // DB처리 에러
        break;
    case 5: // 길드마스터는 탈퇴할 수 없습니다.
        break;
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
                g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9 )+strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        break;
    }
}

void On_EVENT_ACCEPT_GUILD_JOINER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ACCEPT_GUILD_JOINER_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK;              // 승인결과
    // kRecv.m_dwGuildUID;       // GuildUID
    // kRecv.m_setUserUID;       // 처리된 유저UID
    std::set<DWORD>::iterator sit;

    //ERR_CASE( ERR_GUILD_ACCEPT_JOINER_00, kPacket.m_nOK, 1 ); // 길드가입승인시 정보가 비어있음.
    //ERR_CASE( ERR_GUILD_ACCEPT_JOINER_01, kPacket.m_nOK, 2 ); // 길드가입승인시 길드원이 아님.
    //ERR_CASE( ERR_GUILD_ACCEPT_JOINER_02, kPacket.m_nOK, 3 ); // 길드가입승인시 유저정보 없음.
    //ERR_CASE( ERR_GUILD_ACCEPT_JOINER_03, kPacket.m_nOK, 4 ); // 길드가입승인시 길드정보 없음.
    //ERR_CASE( ERR_GUILD_ACCEPT_JOINER_04, kPacket.m_nOK, 5 ); // 길드가입승인시 길드마스터나 제너럴이 아님.
    //ERR_CASE( ERR_GUILD_ACCEPT_JOINER_05, kPacket.m_nOK, 6 ); // 길드가입승인시 가입대기길드원이 아님.
    //ERR_CASE( ERR_GUILD_ACCEPT_JOINER_06, kPacket.m_nOK, 7 ); // 길드가입승인시 DB처리 에러.
    //ERR_CASE( ERR_GUILD_ACCEPT_JOINER_07, kPacket.m_nOK, 8 ); // 길드가입승인시 가입중지 상태.
    //ERR_CASE( ERR_GUILD_ACCEPT_JOINER_08, kPacket.m_nOK, 9 ); // 길드가입승인시 최대 맴버수를 넘게된다.

    switch (kRecv.m_nOK )
    {
    case 0: // 성공
        if( g_kGlobalValue.m_kGuildInfo.m_dwUID == kRecv.m_dwGuildUID )
        {
            for( sit = kRecv.m_setUserUID.begin(); sit != kRecv.m_setUserUID.end(); ++sit )
            {
                std::map< DWORD, KNGuildUserInfo >::iterator mit = g_kGlobalValue.m_mapNGuildUserInfo.find(*sit);

                if( mit != g_kGlobalValue.m_mapNGuildUserInfo.end() )
                {
                    // 승인된 가입대기자들은 길드멤버 등급을 일반으로 바꿔주자.
                    mit->second.m_cMemberLevel = KNGuildUserInfo::GL_NORMAL;
                }
            }
            g_pkUIScene->m_pkGuildDlg->UpdateGuildMangeDlg(KGCGuildManageDlg::BTN_JOIN_MANAGE);
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_NEW_GUILD_JOINER_ALLOW_TITLE),
                g_pkStrLoader->GetString(STR_ID_NEW_GUILD_JOINER_ALLOW_MSG), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );

        }
        break;
    case 1: // 길드가입승인시 정보가 비어있음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5 ),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR08), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 2: // 길드가입승인시 길드원이 아님.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5 ),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR01), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 3: // 길드가입승인시 유저정보 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5 ),
            g_pkStrLoader->GetString(STR_ID_NOT_EXIST_USER_INFO), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 4: // 길드가입승인시 길드정보 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5 ),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR03), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 5: // 길드가입승인시 길드마스터나 제너럴이 아님.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5 ),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_NO_MASTER_OR_GENERAL), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 6: // 길드가입승인시 가입대기길드원이 아님.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5 ),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_NO_WAITING_JOINER), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 7: // 길드가입승인시 DB처리 에러.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5 ),
            g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 8: // 길드가입승인시 가입중지 상태.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5 ),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_JOIN_STOP_STATE), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 9: // 길드가입승인시 최대 맴버수를 넘게된다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5 ),
            g_pkStrLoader->GetString(STR_ID_ACCEPT_GUILD_MAX_NUM), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5 ),
                g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9)+strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        break;
    }
}

void On_EVENT_REJECT_GUILD_JOINER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_REJECT_GUILD_JOINER_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK;              // 거절결과
    // kRecv.m_dwGuildUID;       // GuildUID
    // kRecv.m_setUserUID;       // 처리된 유저UID
    std::set<DWORD>::iterator sit;

    switch (kRecv.m_nOK )
    {
    case 0: // 성공
        if( g_kGlobalValue.m_kGuildInfo.m_dwUID == kRecv.m_dwGuildUID )
        {
            for( sit = kRecv.m_setUserUID.begin(); sit != kRecv.m_setUserUID.end(); ++sit )
            {
                g_kGlobalValue.m_mapNGuildUserInfo.erase(*sit);
            }
            g_pkUIScene->m_pkGuildDlg->UpdateGuildMangeDlg(KGCGuildManageDlg::BTN_JOIN_MANAGE);
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_NEW_GUILD_JOINER_ALLOW_TITLE),
                g_pkStrLoader->GetString(STR_ID_NEW_GUILD_JOINER_CANCEL_MSG), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        break;
    case 1: // 길드가입거절시 정보가 비어있음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5 ),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR08), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 2: // 길드가입거절시 길드원이 아님.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5 ),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR01), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 3: // 길드가입거절시 유저정보 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5 ),
            g_pkStrLoader->GetString(STR_ID_NOT_EXIST_USER_INFO), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 4: // 길드가입거절시 길드정보 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5 ),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR03), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 5: // 길드가입거절시 길드마스터가 아님.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR04), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 6: // 길드가입거절시 가입대기 또는 일반길드원이나 제너럴이 아님.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_NO_VERIFY_INFO), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 7: // 길드가입거절시 DB처리 에러.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 8: // 길드가입승인시 최대 맴버수를 넘게된다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_RECOMMEND_REWARD_MSG), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
                g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9)+strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        break;
    }
}

void On_EVENT_EDIT_GUILD_MY_COMMENT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_EDIT_GUILD_MY_COMMENT_ACK );
    SAFE_DELETE( pkBuff );
    // 길드원이 자기소개를 바꾼 결과.
    // kRecv.m_nOK;              // 소갯말 변경 결과
    // kRecv.m_dwGuildUID;       // GuildUID
    // kRecv.m_strMyComment;     // 바꿀 내 소갯말

    g_pkUIScene->m_pkGuildIntroduceEdit->OnClose();

    std::map<DWORD, KNGuildUserInfo>::iterator mit = g_kGlobalValue.m_mapNGuildUserInfo.find(g_kGlobalValue.m_kGuildUserInfo.m_dwUserUID);
    switch ( kRecv.m_nOK )
    {
    case 0: // 성공
        g_kGlobalValue.m_kGuildUserInfo.m_strMyComment = kRecv.m_strMyComment;
        if( mit != g_kGlobalValue.m_mapNGuildUserInfo.end() )
            mit->second.m_strMyComment = kRecv.m_strMyComment;

        g_pkUIScene->m_pkGuildDlg->UpdateMemberList();
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CHANGE_COMPLETE),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CHANGE_MY_COMMENT_MSG), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    // 에러값 추가 작성중.
    default: // 알수 없는 로규
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
                g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9 )+strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        break;
    }
}

void On_ENU_CLIENT_SCRIPT_INFO_NOT( WPARAM wParam, LPARAM lParam )
{   
    KSerializer ks;
    ACK_DESERIALIZE( KENU_CLIENT_SCRIPT_INFO_NOT );

    // kRecv.m_mapMonsterInfo : 몬스터정보 리스트
    // std::map< int, KSimpleMonsterInfo >
}

void On_EVENT_CHARACTER_STAT_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSimpleCharacterStat );
    SAFE_DELETE( pkBuff );
    // 현재 캐릭터 스텟 정보를 알려준다.
    // kRecv.m_fIncHP
    // kRecv.m_fDamagefactor
    // kRecv.m_fWalkSpeed
    // kRecv.m_fRunSpeed

    std::vector< EGCSkillTree > setSkill;
    PLAYER_TEMPLATE sPlayerTemplate;
    sPlayerTemplate.Init();

    SetPlayerTemplate(setSkill, g_MyD3D->m_TempPlayer.Extra_Char_Num, sPlayerTemplate );

    // 앞뒤 10%의 오차범위는 허용하겠다.
    if( !(kRecv.m_fIncHP * 0.9f <= sPlayerTemplate.fIncHP&& sPlayerTemplate.fIncHP <= kRecv.m_fIncHP * 1.1f) ||
        !(kRecv.m_fDamagefactor * 0.9f <= sPlayerTemplate.fDamagefactor && sPlayerTemplate.fDamagefactor <= kRecv.m_fDamagefactor * 1.1f) ||
        !(kRecv.m_fWalkSpeed * 0.9f <= sPlayerTemplate.fWalkSpeed && sPlayerTemplate.fWalkSpeed <= kRecv.m_fWalkSpeed * 1.1f) ||
        !(kRecv.m_fRunSpeed * 0.9f <= sPlayerTemplate.fRunSpeed && sPlayerTemplate.fRunSpeed <= kRecv.m_fRunSpeed * 1.1f) )
    {

        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_DETECT_CHANGED_KOM_FILE ),
            L"", KGCUIScene::GC_MBOX_DETECT_CHANGED_KOM_OK, 0, 0, true, true );

        // 기록요청은 최초 걸렸을 때만 하겠다.
        if( !g_kGlobalValue.m_bCheckChangedKOM )
            KP2P::GetInstance()->Send_ClientHackingUserNot(KEVENT_DUNGEON_HACKING_USER_NOT::CHARACTER_STAT);

        g_kGlobalValue.m_bCheckChangedKOM = TRUE;
    }
}
// 보드게임 말판의 기본 정보.
void On_EVENT_BOARD_GAME_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BOARD_GAME_INFO_NOT );
    SAFE_DELETE( pkBuff );

    g_pkUIScene->m_pkDicePlay->SetBoardItemInfo( kRecv.m_mapBoardInfo , kRecv.m_mapBoardReward );
    g_pkUIScene->m_pkDicePlay->SetFreeDiceTick( kRecv.m_dwFreeDiceTick );
}

// 보드게임 말판 기존 정보 요청에 대한 응답.
// 주사위 아이템 요청에 대한 응답.
void On_EVENT_BOARD_GAME_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    //  OK 값 설명
    /*
    0 : 성공
    1 : 이벤트 기간이 아님
    2 : 주사위 돌릴 수 있는 기회 없음.
    3 : 무료 주사위 기회 지급 금일 완료.
    -99: 알수 없는 오류
    -98: DB 처리중
    */
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BOARD_GAME_INFO_ACK );
    SAFE_DELETE( pkBuff );

    switch( kRecv.m_nOK )
    {
        case 1:
           if (g_pkUIScene->m_pkDicePlay)
                g_pkUIScene->m_pkDicePlay->OnExit();
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_GAWIBAWIBO_ERR_10 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
           break;
       case 0:
            g_pkUIScene->m_pkDicePlay->m_bNoFreeDice = false;
            g_pkUIScene->m_pkDicePlay->m_bRcvDice = false;
       case 2:
            g_pkUIScene->m_pkDicePlay->m_bNoFreeDice = false;
            g_pkUIScene->m_pkDicePlay->m_bRcvDice = false;
            g_pkUIScene->m_pkDicePlay->SetMyBoardInfo( kRecv.m_kMyBoardInfo );
            g_pkUIScene->m_pkDicePlay->SetRanker( kRecv.m_vecDicePlayRank );
            g_pkUIScene->m_pkDicePlay->SetState( KGCDicePlay::REFRESH );            
            break;
        case 3: //무료 주사위 기회 지급 금일 완료.
            g_pkUIScene->m_pkDicePlay->m_bNoFreeDice = true;
            g_pkUIScene->m_pkDicePlay->m_bRcvDice = false;
            g_pkUIScene->m_pkDicePlay->SetMyBoardInfo( kRecv.m_kMyBoardInfo );
            g_pkUIScene->m_pkDicePlay->SetRanker( kRecv.m_vecDicePlayRank );
            if(g_pkUIScene->m_pkDicePlay->GetState() ==  KGCDicePlay::DEFAULT)
                g_pkUIScene->m_pkDicePlay->SetState( KGCDicePlay::REFRESH );            
            break;
        default:
            break;
    }
    Result_HalloweenBoardGame = kRecv.m_nOK;
}

// 주사위 굴리기를 했을 경우.
void On_EVENT_DICE_PLAY_ACK ( WPARAM wParam, LPARAM lParam )
{
    //  OK 값 설명
    /*
        0 : 주사위 처리도 성공하고 아이템 지급되었음.
        1 : 해당 칸에 보상 리스트가 존재하지 않음.
        2 : 이벤트 기간이 아님.
        3 : 주사위 돌릴 수 있는 기회 없음
        4 : 오늘 주사위 굴릴수 있는 횟수 다 굴렸음.
        5 : 보상 아이템이 없으므로 DB거치지 않고 전송.
        6 : 존재하지 않는 유저이다.
        7 : 해당 아이템 DB처리 오류.
        -99: 알수 없는 오류
        -98: DB 처리중
    */
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DICE_PLAY_ACK );
    SAFE_DELETE( pkBuff );

    switch(kRecv.m_nOK)
    {
        case 0:
        case 5:
        case 8:
            {
                g_pkUIScene->m_pkDicePlay->PlayResult( kRecv );
            }
            break;
        case 2:
            g_pkUIScene->m_pkDicePlay->OnExit();
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_DICE_ERROR_01 ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            
            break;
        case 3:
            g_pkUIScene->m_pkDicePlay->OnExit();
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_DICE_ERROR_02 ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            
            break;
        case 4:
            g_pkUIScene->m_pkDicePlay->OnExit();
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_DICE_ERROR_03 ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            
            break;
        case 6:
            g_pkUIScene->m_pkDicePlay->OnExit();
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_DICE_ERROR_04 ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            
            break;
        case 7:
            g_pkUIScene->m_pkDicePlay->OnExit();
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_DICE_ERROR_05 ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            
            break;
        default:
            g_pkUIScene->m_pkDicePlay->OnExit();
            break;
    }
}

// 주사위 교환.
void On_EVENT_DICE_ITEM_TRADE_ACK ( WPARAM wParam, LPARAM lParam )
{

    //  OK 값 설명
    /*
    0    성공
    1    주사위 아이템 가져오기 실패
    2    주사위 아이템 번호가 서버랑 틀리다
    3    존재하지 않는 유저이다.
    4    이벤트 기간이 아님.
    -99  알수 없는 오류
    -98  DB 처리중
    */
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DICE_ITEM_TRADE_ACK );
    SAFE_DELETE( pkBuff );

    DWORD			dwDiceCount = 0;
    std::wstring	strMsg;
    KItem* kInventoryItem = NULL;

    switch( kRecv.m_nOK )
    {
    case 0:
        if( g_pItemMgr->FindInventoryForItemID( (DWORD)KGCItemManager::ITEM_HALLOWEEN_DICE, &kInventoryItem ) )
        {
            dwDiceCount = kInventoryItem->m_nCount;
        }
        strMsg = g_pkStrLoader->GetReplacedString( STR_ID_DICE_EXCHANGED_COUNT_MSG, "i", (int)dwDiceCount);
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,strMsg, L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        g_pkUIScene->m_pkDicePlay->SetDiceCount( kRecv.m_dwDiceCount );
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecUseItem , true);
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_DICE_ERROR_01 ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;

    default:
        break;
    }
}


// 주사위 교환.
void On_EVENT_DICE_ITME_BUY_CHECK_ACK ( WPARAM wParam, LPARAM lParam )
{
    // (성공) 해당 요청에 대한 성공.
    // (에러) 해당 요청에 대한 에러처리 부탁.
    //  OK 값 설명
    /*
    0    성공( 성공 )
    1    주사위 아이템 번호가 서버랑 틀리다.( 에러 )
    2    해당 아이템은 최대 구매횟수 제한이 없음.( 성공 )
    3    구매 제한 횟수를 초과하였음.( 에러 )
    -99  알수 없는 오류
    */
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DICE_ITEM_TRADE_ACK );
    SAFE_DELETE( pkBuff );

    Result_BuyHalloweenDice = kRecv.m_nOK;
}

//void On_EVENT_GWC_EVENT_INFO_ACK( WPARAM wParam, LPARAM lParam )
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( KEVENT_GWC_EVENT_INFO_ACK );
//    SAFE_DELETE( pkBuff );
//    // 0      성공.
//    // 1      이벤트 기간이 아님
//    // -98    아직 처리중인 작업입니다.
//
//    switch( kRecv.m_nOK )
//    {
//    case 0:
//        g_pkUIScene->m_pkGWCDonationDlg->SetItem( kRecv.m_dwEventItemID/10, kRecv.m_nAccCount );
//        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GWC_DONATION_DLG, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//        break;
//    case 1:
//        {
//            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_HAPPY_NEWYEAR_NOT_EVENT_TIME), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//        }
//        break;
//    default:
//        break;
//    }
//    //     kRecv.m_dwEventItemID; // 기부 할때 쓰이는 Item ID
//    //     kRecv.m_nAccCount; // 현재까지 나의 누적 기부 수량.
//}
//
//void On_EVENT_GWC_EVENT_DONATION_ACK( WPARAM wParam, LPARAM lParam )
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( KEVENT_GWC_EVENT_DONATION_ACK );
//    SAFE_DELETE( pkBuff );
//    //kRecv.m_nOK;
//    // 0     성공.
//    // 1     GWC 이벤트 기간이 아님. 
//    // 2     GWC 유저 정보가 로드 되지 않았음. 
//    // 3     GWC 이벤트 아이템이 존재 하지 않음. 
//    // 4     GWC 이벤트 아이템의 보유 수량이 요청 수량 보다 적음. 
//    // 5     GWC 기부 수량을 음수개 요청. 
//    // -98   아직 처리중인 작업입니다.
//    switch( kRecv.m_nOK )
//    {
//    case 0:
//        {
//            if( !kRecv.m_vecInv.empty() )
//            {
//                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecInv, true);
//                g_pkUIScene->m_pkGWCDonationDlg->SetItem( kRecv.m_vecInv[0].m_ItemID, kRecv.m_nAccCount );
//                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_ITEM_RECEIVE1, "l", g_pItemMgr->GetItemName( kRecv.m_vecInv[0].m_ItemID)), L"", 
//                    KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false);
//            }
//            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_GWC_DONATION_COMPLETE, "i", kRecv.m_nUseCount), L"", 
//                KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false);
//            g_pkUIScene->m_pkGWCDonationDlg->OnCancle();
//
//            g_pkUIScene->m_pkMyInfoScene->UpdateData();
//        }
//        break;
//    case 1:
//        {
//            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_HAPPY_NEWYEAR_NOT_EVENT_TIME), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//        }
//        break;
//    case 3:
//    default:	// 에러처리는 나중에..
//        break;
//    }
//    //     kRecv.m_nUseCount;      // 이번에 기부한수량. ( 아래 값이 이미 포함된 상태 )
//    //     kRecv.m_nAccCount;      // 현재까지 기부한 누적 수량.
//    //     kRecv.m_vecItemInfo;    // 기부한 Item의 현재 정보.
//}
//
//void On_EVENT_GWC_EVENT_RESULT_ACK( WPARAM wParam, LPARAM lParam )
//{
//    KSerializer ks;
//    ACK_DESERIALIZE( KEVENT_GWC_EVENT_RESULT_ACK );
//    SAFE_DELETE( pkBuff );
//
//    // 0      성공.
//    // 1      이벤트 기간이 아님.
//    switch( kRecv.m_nOK )
//    {
//    case 0:
//        g_pkUIScene->m_pkGWCShowStateDlg->SetState( kRecv.m_vecNationData );
//        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_GWC_STATE_DLG);
//        break;
//    case 1:
//        {
//            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_HAPPY_NEWYEAR_NOT_EVENT_TIME), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
//        }
//        break;
//    default:
//        break;
//    }
//
//    //     kRecv.m_nAccCount;      // 현재까지 내가 기부한 누적 수량.
//    //     kRecv.m_vecNationData;  // 전국가 기부 상태.
//}

void On_EVENT_JOIN_ROOM_OTHER_CHANNEL_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KJoinRoomAckInfo );
    SAFE_DELETE( pkBuff );

    // 0 성공
    // 1  초대 요청한 유저가 존재하지 안음. )
    // 2  해당 채널과 요청 채널이 맞지 않음. )
    // 3  해당 Room과 요청 Room이 맞지 않음. )
    // 4  초대 요청자가 이미 방장이 아님. )
    // 5  상태 전이중 문제 발생 채널 로비로 강제 퇴장 )
    // 6  방 참여 실패. 잘못된 정보로 접속을 시도함.
    // 7  방 참여 실패. P2P 버전이 맞지 않음. )
    // 8  방 참여 실패. 현재 방이 대기상태가 아님. )
    // 9  방 참여 실패. 비밀번호가 다름. )
    // 10 방 접속 불가능. 방장 부재중 )
    // 11 방 참여 실패. 방장에게 접속 알림 패킷을 보내지 못함. )
    // 12 존재하지 않는 캐릭터가 선택되었습니다. )
    // 13 입장할수 있는 올바른 레벨이 아닙니다. )
    // 14 방 접속 불가능. 정원이 모두 찾습니다. )   // 접속자가 운영자 권한이 없음)
    // 15 방 참여 실패. 운영자 이벤트 기간중 이벤트 아이템을 이미 가지고 있음. )
    // 16 옵저버가 이미 존재하는 방에 옵저버가 들어갈려고 했다. )
    // 17 더이상 다른 길드는 입장할수 없습니다. )
    // 18 이미 동일한 길드원이 3명 있습니다. )
    // 19 방 접속 불가능. 현재 방에 동시에 다른 사용자가 접속중 임.)  // 현재 방에 똑같은 UID를 가진 사용자가 접속중임
    // 20 채널 입장 등급이 맞지 않아서 들어 갈 수 없음
    // 99 알수 없는 오류..

    Result_Join_Other_Channel = kRecv.m_nOK;
    switch( Result_Join_Other_Channel )
    {
    case 0: // OK
        {
//#ifdef __PATH__
//			if(g_pGCDeviceManager2->GetMassFileManager()->IsDuplicateExist() ||
//				g_pGCDeviceManager2->GetMassFileManager()->GetDuplicatedHackCheck() != (957452)){
//				g_MyD3D->m_pStateMachine->GoServer();
//				return;
//			}
//#endif
            const KInviteInfo& kInfo = SiKGCInviteManager()->GetCurrentInviteInfo();
            g_MyD3D->m_pStateMachine->SetJoinChannel( true );
            SiKGCChannelManager()->SetCurrentChannel( kInfo.m_dwChannelUID );
            SiKGCRoomManager()->UpdateShowGameModeCategory( false, SiKGCChannelManager()->GetCurrentChannelType() );
            if( true == SiKGCChannelManager()->CheckChannel( CT_GUILD ) )
            {
                g_MyD3D->m_pStateMachine->SetJoinGuild( true );
            }

            // 가상으로 JoinRoom
            SiKGCRoomManager()->JoinRoom( KJoinRoomReqInfo::JOIN_NORMAL, kInfo.m_usRoomID, kInfo.m_strRoomPasswd, false, false );
            EnterRoom( kRecv );

            g_MyD3D->m_pStateMachine->Clear_SavedState();

            if( true == SiKGCChannelManager()->CheckChannel( CT_DUNGEON ) )
            {
                g_MyD3D->m_pStateMachine->SavePrevState( GS_WORLDMAP );
            }
            else
            {
                g_MyD3D->m_pStateMachine->SavePrevState( GS_MATCH );
            }
            Result_Join_Other_Channel = INT_MAX;
            break;
        }
    case 5: // 상태 전이중 문제 발생 채널 로비로 강제 퇴장
        {
            g_MyD3D->m_pStateMachine->GoServer();
            break;
        }
    default:
        {
            //기타 문제 있는 경우..
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, Result_Join_Other_Channel );	
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_INVITE_ACK_ERROR ),
                strTemp );
            break;
        }
    }

}

void On_ENU_CLIENT_CONTENTS_OPEN_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KENU_CLIENT_CONTENTS_OPEN_NOT );
    SAFE_DELETE( pkBuff );

    //	사내에서만 동작, 게임모드 스크립트에서 가져올수 있다.
#if !defined( __PATH__ ) 
    if ( GC_GLOBAL_DEFINE::bLoadGameModeScript ) 
    {
        Result_CharOpen = 0;
        return;
    }
#endif 

    SiKGCRoomManager()->LoadGameModeFromPacket( kRecv );
    g_kGlobalValue.SetOpenedCharacterInfo( kRecv.m_mapCharactes );
    g_kGlobalValue.SetCharOpenType(kRecv.m_mapCharOpenType);
    g_kGlobalValue.SetCharSp4OpenInfo( kRecv.m_vecCharSP4OpenInfo );
    g_kGlobalValue.SetMaxLevel(kRecv.m_nMaxLevel);
    g_kGlobalValue.SetEventMonsterList(kRecv.m_mapMonsterAbilityList);
    g_kGlobalValue.SetDisableUIBtnList( kRecv.m_vecDisableMenuList );
	g_kGlobalValue.m_CharSoltAddItem = kRecv.m_SlotItem;

    Result_CharOpen = 0;
}

void On_ENU_NEW_CLIENT_CONTENTS_OPEN_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CLIENT_CONTENTS_OPEN_INFO_NOT );                    
    SAFE_DELETE( pkBuff );

#if !defined( __PATH__ ) 
    if ( GC_GLOBAL_DEFINE::bLoadGameModeScript ) 
    {
        Result_CharOpen = 0;
        return;
    }
#endif 

    SiKGCRoomManager()->LoadGameModeFromPacket( kRecv );
    
    g_kGlobalValue.SetOpenedEventDungeonInfo( kRecv.m_prGameCategoryInfo.second.m_vecCategoryModes);
    g_kGlobalValue.SetOpenedCharacterInfo( kRecv.m_prGameCharInfo.second.m_mapCharactes );
    g_kGlobalValue.SetCharOpenType(kRecv.m_prGameCharInfo.second.m_mapCharOpenType);
    g_kGlobalValue.SetCharSp4OpenInfo( kRecv.m_prGameCharInfo.second.m_vecCharSP4OpenInfo );
    g_kGlobalValue.SetMaxLevel(kRecv.m_prGameCharInfo.second.m_nMaxLevel);
    g_kGlobalValue.m_mapCharCashGoods = kRecv.m_prGameCharInfo.second.m_mapCharCashGoods;
    g_kGlobalValue.SetCharSkillEnable(kRecv.m_prGameCharInfo.second.m_setCharSkillEnable);

    g_kGlobalValue.SetChampionAbility(kRecv.m_prMonsterInfo.second.m_mapChampionRatio);
    g_kGlobalValue.SetEventMonsterList(kRecv.m_prMonsterInfo.second.m_mapMonsterAbility);
    
    g_kGlobalValue.m_vecEventOpenInfo = kRecv.m_prMiniEventInfo.second.m_vecEventOpenInfo;
    g_kGlobalValue.SetDisableUIBtnList( kRecv.m_prMiniEventInfo.second.m_vecDisableMenuList );

    Result_CharOpen = 0;
}

void On_EVENT_VIRTUAL_CASH_LIMIT_RATIO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );

    g_kGlobalValue.m_ivurcashper = kRecv;
}

// 트래픽 공격 유저의 처리에 대한 부분.
void On_EVENT_TRAFFIC_USER_NOT( WPARAM wParam, LPARAM lParam )
{
    exit(0);
}

void On_EVENT_RECOMMEND_LEVELUP_NOT( WPARAM wParam, LPARAM lParam )
{
        //int                             m_nCount;               // 레벨업한 신규유저 숫자.
        //std::vector<KItemInfo>          m_vecItem;              // 지급할 보상 아이템.리스트.
        //std::vector<KDurationItemInfo>  m_vecDurationItem;
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RECOMMEND_LEVELUP_NOT );
    SAFE_DELETE( pkBuff );

//	g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_RECOMUSER_LEVELUP), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
    g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);
//	g_MyD3D->m_kItemMgr.AddInventory( kRecv.m_vecItem );
//	g_MyD3D->m_kItemMgr.AddInventory( kRecv.m_vecDurationItem );
    g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    g_pkUIScene->m_pkMyInfoScene->UpdateData();
}

void On_EVENT_EDIT_GUILD_NAME_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_EDIT_GUILD_NAME_NOT );
    SAFE_DELETE( pkBuff );

    g_kGlobalValue.m_kGuildInfo.m_dwUID = kRecv.m_dwGuildUID;
    g_kGlobalValue.m_kGuildInfo.m_strName = kRecv.m_strGuildName;;
}

void On_EVENT_UPDATE_GUILD_URL_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KNGuildURL );
    SAFE_DELETE( pkBuff );

    kRecv.m_strURL;
    kRecv.m_dwUID; // guild uid

}

void On_EVENT_MARK_UPLOAD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MARK_UPLOAD_ACK );
    SAFE_DELETE( pkBuff );

    // 길드 마크 등록 요청 의 결과
    //kRecv.m_dwGuildUID;  // 나의 길드 UID
    //kRecv.m_kItem; // 사용한 아이템 정보 이녀석이 바뀌었습니다.
    //kRecv.m_nOK;         // 결과


// 0      성공.
// 1      해당 유저는 길드에 가입 되어 있지 않습니다.
// 2      해당 유저는 길드 마크를 변경할 권한이 없습니다.
// 3      길드가 존재하지 않습니다.
// 4      해당 길드는 정규 길드가 아닙니다.
// 5      길드 마크로 사용 할수 있는 이미지가 아닙니다.
// 6      길드 마크 이미지 용량에 이상이 있습니다.
// 7      길드 마크 업로드 아이템을 보유하고 있지 않습니다.
// 8      길드 마크 정보 가져 오기 실패.
// 9      FTP 연결 실패.
// 10     FTP 업로드 실패.
// -98      처리 중.

    switch( kRecv.m_nOK )
    {
    case 0:
        //g_kGlobalValue.m_kGuildInfo.m_ucMarkStatus = kRecv.m_ucMarkStatus;
        g_pItemMgr->m_kInventory.RemoveItem( kRecv.m_kItem.m_ItemUID );
        //사용한 아이템 수량의 정보를 업데이트 하자.
        g_pkUIScene->m_pkGuildDlg->UpdateGuildMangeDlg(KGCGuildManageDlg::BTN_SETTING_MANAGE);
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_CONNECTION_MSG_TITLE),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MARK_CHANGE_REQ_MSG), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR03), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MARK_CHANGE_FAIL1), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MARK_CHANGE_FAIL2), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MARK_CHANGE_FAIL3), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MARK_CHANGE_FAIL4), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 8:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MARK_CHANGE_FAIL5), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 9:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MARK_CHANGE_FAIL6), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 10:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MARK_CHANGE_FAIL7), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 11:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_GUILDMARK_REGISTANCE_ERROR_MSG), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
            g_pkStrLoader->GetString(STR_ID_SUBSCRIPTION_ERROR_MSG4), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    case 1:
    case 2:
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_ENCHANT_FAIL5),
                g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9)+strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        }
        break;
    }

    if( kRecv.m_nOK != 0 )
        g_kGlobalValue.m_kGuildInfo.m_ucMarkStatus = KNGuildInfo::MS_NORMAL;

}

void On_EVENT_GUILD_MARK_STATUS_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KNGuildMarkInfo );
    SAFE_DELETE( pkBuff );

    // 길드 마크의 상태 변화가 있을때 전달 됩니다.

    kRecv.m_dwGuildUID;     // 나의 길드 UID.
    kRecv.m_ucMarkStatus;   // 길드마크 등록시 상태.
    kRecv.m_nMarkRevision;  // 길드 마크 리비젼.
    kRecv.m_strFileName;    // 길드 마크 파일 이름.
    //kRecv.m_strURL; 이녀석은 제거 될 예정.
    
    g_kGlobalValue.m_kGuildInfo.m_ucMarkStatus = kRecv.m_ucMarkStatus;
    if(kRecv.m_strFileName == L"")
        g_kGlobalValue.m_kGuildInfo.m_strFileName = L"defaultmark.dds";
    else
        g_kGlobalValue.m_kGuildInfo.m_strFileName = kRecv.m_strFileName;

    g_kGlobalValue.m_kGuildInfo.m_ucMarkStatus = kRecv.m_ucMarkStatus;
    g_kGlobalValue.m_kGuildInfo.m_strFileName = kRecv.m_strFileName;

    //길마이면 해당 스테이터스 변화에 따른 메시지 박스를 바꿔주자.
    if( g_kGlobalValue.m_kGuildUserInfo.m_cMemberLevel == KNGuildUserInfo::GL_MASTER )
    {
        switch( g_kGlobalValue.m_kGuildInfo.m_ucMarkStatus )
        {
            //MS_NORMAL           = 1,  // 정상상태
            //	MS_REQUEST_CHANGE   = 2,  // 마크변경신청상태
            //	MS_ACCEPT_CHANGE    = 3,  // 승인성공
            //	MS_REJECT_CHANGE    = 4,  // 승인실패
        case KNGuildInfo::MS_NORMAL:
        case KNGuildInfo::MS_REQUEST_CHANGE:
            break;
        case KNGuildInfo::MS_ACCEPT_CHANGE:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_NEW_GUILD_CHANGE_TITLE),
                g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MARK_CHAGE_COMPLETE), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
            break;
        case KNGuildInfo::MS_REJECT_CHANGE:
        default:
            {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_CONNECTION_MSG_TITLE),
                    g_pkStrLoader->GetString(STR_ID_NEW_GUILD_MARK_CHANGE_FAIL_MSG), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
            }
            break;
        }
    }

    g_pkUIScene->m_pkGuildDlg->UpdateAll();

}

void On_EVENT_GUILD_RANK_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GUILD_RANK_ACK );
    SAFE_DELETE( pkBuff );
    kRecv.m_nOK; // 0 성공, 1 : 없는 랭크 타입 요청.
    kRecv.m_nType; // 요청한 타입..
    kRecv.m_buffRank; // 압축 된 녀석..ㅋㅋ
    kRecv.m_buffRank.UnCompress();	//	압축이 풀렸다.

    std::vector<KNGuildRankInfo> vecRank;
    ks.BeginReading( &kRecv.m_buffRank );
    ks.Get( vecRank );
    ks.EndReading();

    // 랭크 타입.
    //KNGuildRankInfo::DAILY_RANK,     // 일일
    //KNGuildRankInfo::WEEKLY_RANK,    // 주간
    //KNGuildRankInfo::MONTHLY_RANK,   // 월간
    //KNGuildRankInfo::TOTAL_RANK,     // 전체

    // KNGuildRankInfo 구조체 설명.
    //KNGuildRankInfo::m_nRankType;// 랭크타입
    //KNGuildRankInfo::m_nRank;    // 길드랭크
    //KNGuildRankInfo::m_dwGuildUID; // 길드ID
    //KNGuildRankInfo::m_strMarkName; // 길드 마크 파일명
    //KNGuildRankInfo::m_strName;  // 길드명
    //KNGuildRankInfo::m_dwPoint;  // 길드포인트
    //KNGuildRankInfo::m_nWin;     // 승리횟수
    //KNGuildRankInfo::m_nLose;    // 패배횟수
    //KNGuildRankInfo::m_fRatio;   // 승율

    //-----------------------------------------//
    // 여기서 부터 vecRank 사용 가능.

    //////////////////////////////////////////////////////////////////////////
    //	더미 데이터
    /*KNGuildRankInfo	tempInfo;
    if( kRecv.m_nType == KNGuildRankInfo::DAILY_RANK ){
        tempInfo.m_strName		=	std::wstring( L"Test Daily" );

        for( size_t i=0; i<88; ++i ){

            tempInfo.m_dwGuildUID	=	rand() % 100;
            tempInfo.m_dwPoint		=	rand() % 20;
            tempInfo.m_fRatio		=	(float)( rand()%100 );
            tempInfo.m_nLose		=	rand() % 100;
            tempInfo.m_nRank		=	vecRank.size()+1;
            tempInfo.m_nRankType	=	kRecv.m_nType;
            tempInfo.m_nWin			=	rand() % 100;
            vecRank.push_back( tempInfo );
        }
    }

    if( kRecv.m_nType == KNGuildRankInfo::TOTAL_RANK ){
        tempInfo.m_strName		=	std::wstring( L"Test Total" );

        for( size_t i=0; i<25; ++i ){

            tempInfo.m_dwGuildUID	=	rand() % 100;
            tempInfo.m_dwPoint		=	100000 - i*2300;
            tempInfo.m_fRatio		=	(float)( rand()%100 );
            tempInfo.m_nLose		=	rand() % 100;
            tempInfo.m_nRank		=	vecRank.size()+1;
            tempInfo.m_nRankType	=	kRecv.m_nType;
            tempInfo.m_nWin			=	rand() % 100;
            vecRank.push_back( tempInfo );
        }
    }*/
    //////////////////////////////////////////////////////////////////////////

    Result_GuildRankingInfo_Req = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0:
        g_pkUIScene->m_pkRanking->SetGuildRankingInfo( KNGuildRankInfo::RANK_TYPE( kRecv.m_nType ), vecRank );
        Result_RecomEnable	=	0;
        break;

    default:
        ASSERT( !"Invalid rank type" );
        break;
    }
}

void On_EVENT_GUILD_NOTICE_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KNGuildNoticeList );
    SAFE_DELETE( pkBuff );
    // 길드공지사항 전달
    // kRecv.m_nOK;        // 결과값
    // kRecv.m_dwGuildUID; // 내길드UID
    // kRecv.m_vecNotice;  // 내길드공지사항

    switch ( kRecv.m_nOK )
    {
    case 0: // 성공
        for( int i = 0; i < static_cast<int>(kRecv.m_vecNotice.size()); i++ )
        {
            switch( kRecv.m_vecNotice[i].m_nMsgID)
            {
            case KNGuildNotice::GN_COMMENT:
                g_kGlobalValue.m_kGuildInfo.m_strComment = kRecv.m_vecNotice[i].m_strMsg;
                g_pkUIScene->m_pkGuildDlg->SetGuildNotice(kRecv.m_vecNotice[i].m_strMsg, KNGuildNotice::GN_COMMENT);
                break;
            case KNGuildNotice::GN_NOTICE_1:
                g_pkUIScene->m_pkGuildDlg->SetGuildNotice(kRecv.m_vecNotice[i].m_strMsg, KNGuildNotice::GN_NOTICE_1);
                break;
            case KNGuildNotice::GN_NOTICE_2:
                g_pkUIScene->m_pkGuildDlg->SetGuildNotice(kRecv.m_vecNotice[i].m_strMsg, KNGuildNotice::GN_NOTICE_2);
                break;
            }
        }
        break;
    case 1: // 길드원이 아님.
        break;
    case 2: // 해당 길드가 없음.
        break;
    default: // 알수없는 오류
        break;
    }
}

void On_EVENT_CHANGE_GUILD_MEMBER_LEVEL_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHANGE_GUILD_MEMBER_LEVEL_NOT );
    SAFE_DELETE( pkBuff );
    // 길드원 맴버레벨 변경알림.
    // kRecv.m_dwGuildUID; // 내길드UID
    // kRecv.m_mapGuildMemberLevelInfo;  // 길드원 맴버레벨 변경사항<UserUID,KGuildMemberLevelInfo>

    // KGuildMemberLevelInfo
    // m_strNickName;      // 닉네임
    // m_prMemberLevel;    // 맴버레벨 pair<이전레벨,현재레벨>

    //갱신되어야 할 값
    //g_kGlobalValue.m_kGuildInfo
    std::map<DWORD,KGuildMemberLevelInfo>::iterator mit;
    for( mit = kRecv.m_mapGuildMemberLevelInfo.begin(); mit != kRecv.m_mapGuildMemberLevelInfo.end(); ++mit )
    {
        std::map<DWORD, KNGuildUserInfo>::iterator mitUser = g_kGlobalValue.m_mapNGuildUserInfo.find(mit->first);
        if( mitUser != g_kGlobalValue.m_mapNGuildUserInfo.end() )
        {
            mitUser->second.m_cMemberLevel = mit->second.m_prMemberLevel.second;

            if( g_kGlobalValue.m_kGuildUserInfo.m_dwUserUID == mit->first )                
            {
                g_kGlobalValue.m_kGuildUserInfo.m_cMemberLevel = mit->second.m_prMemberLevel.second;
                if( mit->second.m_prMemberLevel.first == KNGuildUserInfo::GL_JOINER &&
                    mit->second.m_prMemberLevel.second != KNGuildUserInfo::GL_JOINER )
                {
                    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_NEW_GUILD_JOINER_ALLOW_TITLE),
                        g_pkStrLoader->GetString(STR_ID_NEW_GUILD_JOINER_ALLOW_RESULT), KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );                    
                    g_pkUIScene->m_pkGuildListDlg->UpdateWaitingJoinerState();
                    KP2P::GetInstance()->m_kMsgServer->Send_GuildAllMemberListReq(g_kGlobalValue.m_kGuildUserInfo.m_dwUserUID, g_kGlobalValue.m_kGuildInfo.m_dwUID);                
                }                
            }
        }
    }

    //현재 씬의 상태에 따라서 해당 씬을 업데이트 한다.
    switch( g_MyD3D->m_pStateMachine->GetState() )
    {
    case GS_WORLDMAP:
        g_pkUIScene->m_pkWorldMapScene->Initialize();
        g_pkUIScene->m_pkWorldMapContainer->Initialize();
        break;
    case GS_MY_INFO:
    case GS_MY_INFO_FROM_ROOM:
        g_pkUIScene->m_pkMyInfoScene->Initialize();
        break;
    case GS_SHOP_CASH:
        g_pkUIScene->m_pkCashShopScene->Initialize();
    case GS_SHOP_GP:
        g_pkUIScene->m_pkGPShopScene->Initialize();
        break;
    case GS_MATCH:
        g_pkUIScene->m_pkMatchScene->Initialize();
        break;
    case GS_ROOM:
        g_pkUIScene->m_pkRoomSceneS6->Initialize();
        break;
    }

    //길드창을 열고 있는 상태라면 ui를 갱신해줄 필요가 있다.
    if( g_pkUIScene->m_pkGuildDlg->IsRenderOn() )
    {
        g_pkUIScene->m_pkGuildDlg->UpdateAll();
    }
}

void On_EVENT_ADD_GUILD_USER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KNGuildUserInfo );
    SAFE_DELETE( pkBuff );
    // 길드원 추가 알림.
    // 패킷 세부내역은 CommonPacket.h 참고바람.

    g_kGlobalValue.m_mapNGuildUserInfo.insert(std::make_pair(kRecv.m_dwUserUID, kRecv));

    g_kGlobalValue.m_setAddGuildMemberData.insert(kRecv.m_dwUserUID);

    if( g_pkUIScene->m_pkGuildDlg->IsRenderOn() )
        g_pkUIScene->m_pkGuildDlg->UpdateAll();
}

void On_EVENT_DEL_GUILD_USER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KNGuildUserInfo );
    SAFE_DELETE( pkBuff );
    // 길드원 삭제 알림
    // 패킷 세부내역은 CommonPacket.h 참고바람.

    g_kGlobalValue.m_mapNGuildUserInfo.erase(kRecv.m_dwUserUID);

    g_kGlobalValue.m_setDelGuildMemberData.insert(kRecv.m_dwUserUID);

    if( g_pkUIScene->m_pkGuildDlg->IsRenderOn() )
        g_pkUIScene->m_pkGuildDlg->UpdateAll();
}

// 길드에서 추방, 길드에서 가입거절, 가입신청자가 가입취소, 자진탈퇴 했을 때 받음
void On_EVENT_GUILD_DRUMOUT_USER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GUILD_DRUMOUT_USER_NOT );
    SAFE_DELETE( pkBuff );
    // 탈퇴되거나 가입거절된 길드원에게만 보내는 알림 패킷
    // enum OUT_TYPE {
    //     OT_REJECT_JOIN  = 0, // 가입거절
    //     OT_CANCEL_JOIN  = 1, // 가입취소
    //     OT_SELF_OUT     = 2, // 자진탈퇴
    //     OT_DRUMOUT      = 3, // 강퇴(추방)
    //     OT_NUM,
    // };
    // kRecv.m_cOutType     : 탈퇴경위
    // kRecv.m_kOutUserInfo ; 탈퇴유저정보

    //길드의 정보를 지운다.
    g_kGlobalValue.m_kGuildInfo.m_dwUID = 0;
    g_kGlobalValue.m_mapNGuildUserInfo.clear();
    g_kGlobalValue.m_kGuildUserInfo.m_cMemberLevel = -1;

    //길드메신저의 정보를 지운다.
    SiKFriendShip()->ClearGuildMemberData();
    //메신저 창을 열어두고 있었다면 닫아주자 - 정보갱신을 위해
    if( g_pkUIScene->m_pkNateOn->IsRenderOn() )
        g_pkUIScene->m_pkNateOn->Destroy();
    //메신저의 상태도 바꿔주자



    //추방된 길드원들은 게임중이거나 룸에 있을 때는 전부 강제퇴장 시키겠다. 그리고 남아 있는 유저들에게는 메시지를 쏴준다.
    if( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_GUILD_BATTLE && kRecv.m_cOutType == KNGuildUserInfo::OT_DRUMOUT)
    {
        if( g_MyD3D->m_pStateMachine->GetState() == GS_GAME )
            g_pStateGame->OnExitGame();
        else
            g_MyD3D->m_pStateMachine->ExitRoom(true);

        g_pkChatManager->AddChatMsg( g_pkStrLoader->GetReplacedString(STR_ID_NEW_GUILD_OUT_MESSAGE_IN_GAME, "l", g_kGlobalValue.m_kGuildUserInfo.m_strNickName),
            KGCChatManager::CHAT_TYPE_ADMIN );
    }
    else if( SiGCSquare()->GetSquareType() == KSquareInfo::ST_GUILD )
    {
        g_pkSquareOverlayUI->ExitSquare();
        if( g_pkUIScene->m_pkGuildLobbyDlg->IsRenderOn() )
            g_pkUIScene->m_pkGuildLobbyDlg->Destroy();
    }
    else if( SiKGCRoomManager()->IsChannelRoomList() )
    {
        g_pkUIScene->m_pkGuildLobbyDlg->Destroy();
    }


    switch( kRecv.m_cOutType )
    {
    case KNGuildUserInfo::OT_REJECT_JOIN:
        //길드가 가입거부
        if( g_MyD3D->m_pStateMachine->GetState() != GS_GAME )
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_NEW_GUILD_JOINER_CANCEL_TITLE),
                g_pkStrLoader->GetString(STR_ID_NEW_GUILD_JOINER_CANCEL_RESULT), KGCUIScene::GC_MBOX_GUILD_SQUARE_OUT, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, false );
        }        
        break;
    case KNGuildUserInfo::OT_DRUMOUT:
        //길드가 추방
        if( g_MyD3D->m_pStateMachine->GetState() != GS_GAME )
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_NEW_GUILD_DRUM_OUT),
                g_pkStrLoader->GetString(STR_ID_NEW_GUILD_BANISHMENT_MESSAGE), KGCUIScene::GC_MBOX_GUILD_SQUARE_OUT, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, false );
        }
        break;
    case KNGuildUserInfo::OT_CANCEL_JOIN:
        //자진가입취소
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX,
        g_pkStrLoader->GetString(STR_ID_NEW_GUILD_JOIN_CANCEL_REQ), g_pkStrLoader->GetString(STR_ID_NEW_GUILD_JOIN_CANCEL_SUCCESS),
        KGCUIScene::GC_MBOX_GUILD_JOIN_RESULT, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, true, true );
        break;
    case KNGuildUserInfo::OT_SELF_OUT:
        //자진탈퇴
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_NEW_GUILD_DRUM_OUT_COMPLETE),
            g_pkStrLoader->GetString(STR_ID_NEW_GUILD_DRUM_OUT_COMPLETE_MSG), KGCUIScene::GC_MBOX_GUILD_SQUARE_OUT, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );
        break;
    }

    //현재 씬의 상태에 따라서 해당 씬을 업데이트 해준다.
    switch( g_MyD3D->m_pStateMachine->GetState() )
    {
    case GS_WORLDMAP:
        g_pkUIScene->m_pkWorldMapScene->Initialize();
        g_pkUIScene->m_pkWorldMapContainer->Initialize();
        break;
    case GS_MY_INFO:
    case GS_MY_INFO_FROM_ROOM:
        g_pkUIScene->m_pkMyInfoScene->Initialize();
        break;
    case GS_SHOP_CASH:
        g_pkUIScene->m_pkCashShopScene->Initialize();
    case GS_SHOP_GP:
        g_pkUIScene->m_pkGPShopScene->Initialize();
        break;
    case GS_MATCH:
        g_pkUIScene->m_pkMatchScene->Initialize();
        break;
    }
}

void On_EVENT_UPGRADE_GUILD_GRADE_GIFT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_UPGRADE_GUILD_GRADE_GIFT_NOT );
    SAFE_DELETE( pkBuff );
    // 신생길드가 정식길드로 승격시에 길드마스터에게 길드마크업로드 아이템이 지급된다.
    // 이 패킷은 길마가 정식길드로 승격시에 접속해있을때만 보내는 패킷으로
    // 받은 아이템에 대해서 인벤토리 갱신을 해주면 된다.
    // kRecv.m_dwGuildUID;       // 길드UID
    // kRecv.m_vecItem;          // 획득한 일반 아이템 std::vector<KItemInfo>
    // kRecv.m_vecDurationItem;  // 획득한 수량성 아이템 std::vector<KDurationItemInfo>

    std::wstring strMsg;

    strMsg.clear();
    strMsg = g_pkStrLoader->GetString(STR_ID_NEW_GUILD_GRADE_UP_MESSAGE) + g_pkStrLoader->GetReplacedString(STR_ID_GUILDMARK_CHANGEITEM_NOTICE, "l", g_kGlobalValue.GetCharName(kRecv.m_nCharType));

    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GUILD_PUBLIC_MBOX, g_pkStrLoader->GetString(STR_ID_CONNECTION_MSG_TITLE),
        strMsg, KGCUIScene::GC_MBOX_USE_NORMAL, KGCGuildPublicMbox::MBR_CONFIRM_ONLY, 0, false, true );

    if( !kRecv.m_vecItem.empty())
    {
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);
    }

    g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    g_pkUIScene->m_pkMyInfoScene->UpdateData();

}

void On_EMS_ADD_GUILD_MEMBER_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KUpdateGuildMemberAck );
    SAFE_DELETE( pkBuff );

    SiKFriendShip()->ModifyGuildMemberData(kRecv.m_mapFriendGroup, (int)KGroup::GUILD_BASE, true);
    g_pkUIScene->m_pkNateOn->UpdateTreeData();
    g_pkUIScene->m_pkNateOn->SetOnlineCount();
    g_kGlobalValue.m_setAddGuildMemberData.clear();
}

void On_EMS_DEL_GUILD_MEMBER_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KUpdateGuildMemberAck );
    SAFE_DELETE( pkBuff );

    SiKFriendShip()->ModifyGuildMemberData(kRecv.m_mapFriendGroup, (int)KGroup::GUILD_BASE, false);
    g_pkUIScene->m_pkNateOn->UpdateTreeData();
    g_pkUIScene->m_pkNateOn->SetOnlineCount();
    g_kGlobalValue.m_setDelGuildMemberData.clear();
}

void On_EMS_GUILD_ALL_MEMBER_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEMS_GUILD_ALL_MEMBER_LIST_ACK );
    SAFE_DELETE( pkBuff );

    std::map<int,KGroup>::iterator mit = kRecv.m_mapFriendGroup.find((int)KGroup::GUILD_BASE);

    if( mit != kRecv.m_mapFriendGroup.end())
        SiKFriendShip()->SetAllGuildMemberData(mit->second);
}

void On_EVENT_GUILD_TOTAL_POINT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GUILD_TOTAL_POINT_ACK );
    SAFE_DELETE( pkBuff );

    kRecv; // 길드포인트(해당 길드의 총포인트)

    g_kGlobalValue.m_kGuildInfo.m_dwPoint = kRecv.m_dwGuildPoint;    
    g_kGlobalValue.m_kGuildInfo.m_GuildBattlePoint = kRecv.m_dwBattlePoint;
    g_kGlobalValue.m_kGuildUserInfo.m_dwContributePoint = kRecv.m_dwContributePoint;

    g_pkUIScene->m_pkGuildDlg->UpdateAll();
}

void On_EVENT_GUILD_MEMBER_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GUILD_MEMBER_LIST_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK;                  // 결과
    // kRecv.m_dwGuildUID;           // 길드UID
    // kRecv.m_nPageNum;             // 페이지 번호
    // kRecv.m_mapNGuildMemberList;  // 길드원리스트

    switch ( kRecv.m_nOK )
    {
    case 0: // 성공
        g_kGlobalValue.m_mapNGuildUserInfo = kRecv.m_mapNGuildMemberList;
        break;
    case 1: // 길드원 아님
        break;
    case 2: // 없는 길드
        break;
    case 3: // DB처리 실패
        break;
    case -98: // 아직 처리중인 작업
        break;
    default: // 알수 없는 오류
        break;
    }
}

void On_EVENT_UPDATE_GUILD_MEMBER_NICK_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KGuildUserName );
    SAFE_DELETE( pkBuff );
    // S->C. 길드맴버 닉네임 변경 알림
    // kRecv.m_dwGuildUID;  // 길드UID
    // kRecv.m_dwUserUID;   // 유저UID
    // kRecv.m_strNickName; // 유저닉네임
    // 클라이언트내 길드원 목록 변경 필요

    //std::map< DWORD, KNGuildUserInfo >::iterator mit = g_kGlobalValue.m_mapNGuildUserInfo.find(kRecv.m_dwUserUID);

    //if( mit != )
}

void On_EVENT_GUILD_MEMBER_CHARACTER_LEVELUP_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KGuildUserCharacter );
    SAFE_DELETE( pkBuff );
    // S->C. 길드원 레벨업 알림
    // kRecv.m_dwGuildUID;  // 길드UID
    // kRecv.m_dwUserUID;   // 유저UID
    // kRecv.m_cCharType;   // 레벨업한 캐릭터타입
    // kRecv.m_cLevel;      // 레벨업한 캐릭터의 레벨
    // 클라이언트내 레벨업한 유저정보 채팅창에 텍스트로 표시 필요

    std::map< DWORD, KNGuildUserInfo >::iterator mit = g_kGlobalValue.m_mapNGuildUserInfo.find(kRecv.m_dwUserUID);

    if( mit != g_kGlobalValue.m_mapNGuildUserInfo.end() )
    {
        g_pkChatManager->AddChatMsg( g_pkStrLoader->GetReplacedString( STR_ID_GUILD_MEMBER_LEVEL_UP_NOTICE, "li", mit->second.m_strNickName, kRecv.m_cLevel ),
            KGCChatManager::CHAT_TYPE_COLORCHAT, D3DCOLOR_RGBA( 255, 0, 255, 255 ), false );// [**] 길드원님이 [**}으로 레벨업 하였습니다.
    }    
}


void On_EVENT_USER_BINGO_DATA_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_USER_BINGO_DATA_ACK );
    SAFE_DELETE( pkBuff );
    // 0      성공
    // 1      퀴즈 빙고 이벤트 기간이 아님.
    // 2      퀴즈 빙고 정보를 이미 로드 하였음.
    // -98    아직 처리중인 작업입니다.

    kRecv.m_nOK;
    kRecv.m_nAccPlayTime;           // 누적 플레이 시간 (분) 0 ~ 59 분.
    kRecv.m_nTotalBingoCoinCount;   // 지금까지 받았던 빙고 코인 ( 지급/전환 포함)
    kRecv.m_nUseBingoCoinCount;     // 지금까지 사용한 빙고 코인.
    kRecv.m_nBingoCoinCount;        // 현재 사용 가능한 빙고 코인
    kRecv.m_vecCorrectQuestions;    // 정답을 맞춘 문제 리스트.
    kRecv.m_vecBingoData;           // 정답을 맞춘 빙고 좌표
    kRecv.m_bFinishToday;           // 오늘은 더이상 빙고 코인을 지급 받을수 없으면 true
    kRecv.m_dwBingoBoardID;         // 보드 아이템
    kRecv.m_dwBingoCoinID;          // 코인 아이템
    kRecv.m_dwBingoResurrectionID;  // 부활 아이템

    Result_BingoBoardGame = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0:
        if( kRecv.m_bFinishToday ) {
            g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_NOT_ACQUIRE_COIN),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
            g_pkUIScene->m_pkBingo->SetAccPlayerTime( 0 );
        }
        else 
            g_pkUIScene->m_pkBingo->SetAccPlayerTime(kRecv.m_nAccPlayTime);

        g_pkUIScene->m_pkBingo->SetTotalBingoCoinCount(kRecv.m_nTotalBingoCoinCount);
        g_pkUIScene->m_pkBingo->SetCorrectQuestions(kRecv.m_vecCorrectQuestions);       
        g_pkUIScene->m_pkBingo->SetBingoData(kRecv.m_vecBingoData);
        g_pkUIScene->m_pkBingo->SetFinishToday(kRecv.m_bFinishToday);
        
        g_pkUIScene->m_pkQuiz->SetResurrectionBonus(g_pItemMgr->GetInventoryItemDuration(kRecv.m_dwBingoResurrectionID / 10));
        g_pkUIScene->m_pkBingo->SetBingoCoinCount(kRecv.m_nBingoCoinCount);
       
        break;
    case 1: //퀴즈 빙고 이벤트 기간이 아님.
       // g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR1),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case 2: //퀴즈 빙고 정보를 이미 로드 하였음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR2),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR7),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,true,true);
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR8),strTemp,KGCUIScene::GC_MBOX_USE_NORMAL,0,0,true,true);
        }
        break;
    }
}

void On_EVENT_CHANGE_BINGO_COIN_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHANGE_BINGO_COIN_ACK );
    SAFE_DELETE( pkBuff );


    //   0     성공
    //   1     퀴즈 빙고 이벤트 기간이 아님.
    //   2     퀴즈 빙고 정보정보가 로드 되지 않았음
    //   3     빙고 보드 아이템을 가지고 있지 않음.
    //   4     빙고 코인 아이템을 가지고 있지 않음.
    //   -98   아직 처리중인 작업입니다.

    kRecv.m_nOK;
    kRecv.m_nTotalBingoCoinCount;   // 지금까지 받았던 빙고 코인 ( 지급/전환 포함)
    kRecv.m_nUseBingoCoinCount;     // 지금까지 사용한 빙고 코인.
    kRecv.m_nRequestCount;          // 교환한 코인 개수.
    kRecv.m_nBingoCoinCount;        // 현재 사용 가능한 코인 개수.
    kRecv.m_vecCoinItem;

    switch(kRecv.m_nOK)
    {
    case 0:
        {
            std::wstring	strMsg;
            g_pkUIScene->m_pkBingo->SetBingoCoinCount( kRecv.m_nBingoCoinCount);
            //해당 아이템을 인벤토리에서 빼주는 부분이 필요할 듯
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecCoinItem , true);
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_TRADE_COIN),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
            break;
        }
    case 1: //퀴즈 빙고 이벤트 기간이 아님.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR1),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case 2: //퀴즈 빙고 정보를 이미 로드 하였음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR2),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR4),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR3),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR7),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR8),strTemp,KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        }
        break;
    }
    Result_BingoChangeCoin = kRecv.m_nOK;
}

void On_EVENT_BINGO_QUESTION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BINGO_QUESTION_ACK );
    SAFE_DELETE( pkBuff );

    // 0     성공
    // 1     퀴즈 빙고 이벤트 기간이 아님.
    // 2     퀴즈 빙고 정보정보가 로드 되지 않았음
    // 3     빙고 보드 아이템을 가지고 있지 않음.
    // 4     빙고 코인이 부족함.
    // 5     질문을 가져 오지 못함.
    // 6     이미 문제를 풀은 칸 입니다.
    // -98    아직 처리중인 작업입니다.


    kRecv.m_nOK;

    //kRecv.m_nTotalBingoCoinCount;
    //kRecv.m_nUseBingoCoinCount;
    kRecv.m_nBingoCoinCount;
    //kRecv.m_nQuestionID;

    KBingoQuestionInfo kQuestion;
    {
        kRecv.m_kQuestionBuff.UnCompress();
        KSerializer ks;
        ks.BeginReading( &kRecv.m_kQuestionBuff );
        ks.Get( kQuestion );
        ks.EndReading();

    }

    switch(kRecv.m_nOK)
    {
    case 0:
        g_pkUIScene->m_pkQuiz->SetRemainDrawAnswerResult(-1);
        g_pkUIScene->m_pkQuiz->SetResurrectionBonus(g_pItemMgr->GetInventoryItemDuration(KGCItemManager::ITEM_BINGO_BONUS));
        g_pkUIScene->m_pkQuiz->GetPreAnswerVectorclear();
        g_pkUIScene->m_pkQuiz->SetQuizInfo(kQuestion);
        g_pkUIScene->m_pkBingo->SetBingoCoinCount(kRecv.m_nBingoCoinCount);
        g_pkUIScene->m_pkQuiz->SetRemainTime(30);
        g_pkUIScene->m_pkQuiz->LockQuestionList(false);

        g_pkUIScene->m_pkQuiz->SetWindowZOrder( KD3DWnd::D3DWZ_TOPMOST );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_QUIZ_DLG,L"",L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR1),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR2),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR4),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR3),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR5),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR6),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR7),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR8),strTemp,KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        }
        break;
    }

    Result_BingoRequestQuestion = kRecv.m_nOK;
}

void On_EVENT_BINGO_ANSWER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KBingoAnswerAckData );
    SAFE_DELETE( pkBuff );


    //  0      성공
    //  1      퀴즈 빙고 이벤트 기간이 아님.
    //  2      퀴즈 빙고 정보정보가 로드 되지 않았음
    //  3      빙고 보드 아이템을 가지고 있지 않음.
    //  4      존재하지 않는 문제.
    //  5      이미 정답을 맞춘 칸 입니다.
    //  6      직전에 틀리지 않았는데 부활을 쓰려고함.
    //  6      부활을 썼지만 이전에 틀린 문제 또는 위치가 다름.
    //  7      부활 아이템을 보유 하고 있지 않음.
    //  -98    아직 처리중인 작업입니다.

    kRecv.m_nOK;
    kRecv.m_bCorrect; 
    kRecv.m_prPos;                  // 빙고판 좌표.
    kRecv.m_vecResItem;             // 부활 아이템남은 정보.
    kRecv.m_vecItem;                // 빙고시/ 문제 정답시 받는 보상.        

    switch(kRecv.m_nOK)
    {
    case 0:
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecResItem , true);

        g_pkUIScene->m_pkQuiz->LockQuestionList(true);
        //정답인 경우
        if( kRecv.m_bCorrect)
        {
            g_KDSound.Play("Enchant_Start");

            g_pkUIScene->m_pkQuiz->SetResolved(true);

            g_pkUIScene->m_pkBingo->PushBingoData(kRecv.m_prPos);
            g_pkUIScene->m_pkBingo->SetCurrentBoxLock(kRecv.m_prPos.first,kRecv.m_prPos.second);
            g_pkUIScene->m_pkBingo->CheckBingo(kRecv.m_prPos.first,kRecv.m_prPos.second);

            for(std::vector<KItem>::iterator kIt = kRecv.m_vecItem.begin();kIt!= kRecv.m_vecItem.end();++kIt)
            {            
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, kIt->m_ItemID/10, 0, true, true );

            }
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);

            g_pkUIScene->m_pkQuiz->SetRemainDrawAnswerResult(50);
            g_pkUIScene->m_pkQuiz->SetRemainTime(30);
        }
        //오답인 경우
        else if( !kRecv.m_bCorrect)
        {
            g_KDSound.Play("9");
            g_pkUIScene->m_pkQuiz->SetResolved(false);
            if(g_pkUIScene->m_pkQuiz->GetRemainTime() ==0 )
            {
                g_pkUIScene->m_pkQuiz->LockQuestionList(false);
                g_pkUIScene->m_pkQuiz->SetRemainTime(30);
            }
            else
            {
                g_pkUIScene->m_pkQuiz->SetRemainDrawAnswerResult(50);
                g_pkUIScene->m_pkQuiz->SetRemainTime(30);
            }      

            //std::vector< KItem >::iterator vit = kRecv.m_vecResItem.begin();
            //if( vit == kRecv.m_vecResItem.end() ) { 
            //    g_pkUIScene->m_pkQuiz->SetResurrectionBonus( 0 );
            //}
            //else { 
            //    g_pkUIScene->m_pkQuiz->SetResurrectionBonus( vit->m_nDuration );
            //}
        }

        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
     
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR1),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR2),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR4),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR9),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR6),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR11),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR12),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR7),L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BINGO_ERROR8),strTemp,KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        }
        break;
    }    

    Result_BingoRequestAnswer   =   kRecv.m_nOK;
}

void On_EVENT_BINGO_COIN_CHARGE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BINGO_COIN_CHARGE_NOT );
    SAFE_DELETE( pkBuff );

    // 1시간지나서 코인 받을때 패킷이 옮.. 그리고 날짜가 바뀔때..
    //kRecv.m_bFinishToday;
    //kRecv.m_nAccTime;
    //kRecv.m_nCoinCount ;

    int nChargedCoin = kRecv.m_nCoinCount - g_pkUIScene->m_pkBingo->GetRemainCoin();

    g_pkUIScene->m_pkBingo->SetAccPlayerTime( kRecv.m_nAccTime);
    g_pkUIScene->m_pkBingo->SetBingoCoinCount(kRecv.m_nCoinCount);

    std::wstring strMsg;
    if ( nChargedCoin > 0 ) {
        //g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK,L" 빙고 코인을 2개 받았습니다.", strFinishToday.c_str(),KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        strMsg = g_pkStrLoader->GetReplacedString(STR_ID_GET_COIN,"i", nChargedCoin);
    }

    if ( kRecv.m_bFinishToday ) {
        //g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK,L"오늘은 코인을 더 이상 받을 수 없습니다",L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        g_pkUIScene->m_pkBingo->SetAccPlayerTime( 0 );
        strMsg += g_pkStrLoader->GetString(STR_ID_NOT_ACQUIRE_COIN);
    }

    if(g_MyD3D->m_pStateMachine)
    {
        if(g_MyD3D->m_pStateMachine->GetState() == GS_GAME)
        {
            if ( !strMsg.empty() ) {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg.c_str(), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false );
            }
        }
        else
        {
            if ( !strMsg.empty() ) {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg.c_str(), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
            }
        }
    }

    Result_BingoChangeCoin = NULL;
}

void On_EVENT_NEW_YEAR_DONATION_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_NEW_YEAR_DONATION_NOT );
    SAFE_DELETE( pkBuff );

    //SiKGCContributionManager()->SetNewYearContributionInfo(kRecv);

}

void On_EVENT_NEW_YEAR_DONATION_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_NEW_YEAR_DONATION_INFO_ACK );
    SAFE_DELETE( pkBuff );
/*
    OK값 설명.
    NET_OK,                   m_nOK, 0 );    // 성공.
    ERR_NEW_YEAR_DONATION_00, m_nOK, 1 );    // 이벤트 기간이 아님.
    ERR_NEW_YEAR_DONATION_05, m_nOK, 6 );    // 서버에 정의된 NPC Type이 아님.
    ERR_NOT_FINISHED_YET,     m_nOK, -98 );   // 아직 처리중인 작업입니다.
*/
    //switch( kRecv.m_nOK )
    //{
    //case 0:
    //    SiKGCContributionManager()->SetNewYearContributionNPCNumber(kRecv.m_dwType);
    //    SiKGCContributionManager()->SetTotalContributionNewYearPoint(kRecv.m_dwType - 1,kRecv.m_nTotalDonation);
    //    SiKGCContributionManager()->SetNewContributionEvent(kRecv.m_dwType);
    //    SiKGCContributionManager()->SetContributionUnitType( kRecv.m_dwDonationItemID / 10 );
    //    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_CONTRIBUTION_DLG );
    //    g_pkUIScene->m_pkContributionDlg->Update();
    //    //SiKGCContributionManager()->SetUnitTypeString(g_pkStrLoader->GetString(iStringNum));
    //    break;
    //case 1:
    //    break;
    //case 6:
    //    break;
    //case -98:
    //    break;
    //}
}

void On_EVENT_NEW_YEAR_DONATION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_NEW_YEAR_DONATION_ACK );
    SAFE_DELETE( pkBuff );
/*
    
    OK값 설명.
    NET_OK,                   m_nOK, 0 );                      // 성공.
    ERR_NEW_YEAR_DONATION_00, m_nOK, 1 );    // 이벤트 기간이 아님.
    ERR_NEW_YEAR_DONATION_01, m_nOK, 2 );    // 서버 클라이언트간 기부 아이템 번호 불일치
    ERR_NEW_YEAR_DONATION_02, m_nOK, 3 );    // 기부 아이템 가져오기 실패
    ERR_NEW_YEAR_DONATION_03, m_nOK, 4 );    // 기부 아이템 갯수가 부족하다.
    ERR_NEW_YEAR_DONATION_04, m_nOK, 5 );    // DB에 기부 정보 넣기 실패.
*/

    /*switch( kRecv.m_nOK )
    {
    case 0:
        SiKGCContributionManager()->SetTotalContributionNewYearPoint(kRecv.m_dwType - 1, kRecv.m_nTotalDonation );
        SiKGCContributionManager()->SetNewContributionEvent(kRecv.m_dwType);
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecDurationItemInv );
        g_pkUIScene->m_pkContributionDlg->Update();
        break;
    case 1:
        break;
    case 2:
        break;
    case 3:
        break;
    case 4:
        break;
    case 5:
        break;
    case -98:
        break;
    }*/

}

void On_EVENT_ATTRIBUTE_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ATTRIBUTE_LIST_ACK );
    SAFE_DELETE( pkBuff );

    // 0 : 성공
    // 1 : 속성을 선택할 아이템이 인벤에 없음.

    switch( kRecv.m_nOK )
    {
    case 0:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_ATTRIBUTE_SELECT_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        g_pkUIScene->m_pkAttributeSelectBox->SetAttributeInfoSelect(kRecv);
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_SELECT_ATTRIBUTE_SUCCESS_MSG),
            L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT9),
                strTemp,KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,true);
        }
        break;
    }
}

void On_EVENT_ATTRIBUTE_SELECT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ATTRIBUTE_SELECT_ACK );
    SAFE_DELETE( pkBuff );

    // 0 : 성공
    // 1 : 속성을 선택할 아이템이 인벤에 없음.
    // 2 : 선택한 속성이 선택 가능한 속성에 포함되지 않습니다.
    // 3 : 선택한 속성의 갯수가 올바르지 못합니다.
    // 4 : 랜덤 속성을 선택할 수 없습니다.

    switch( kRecv.m_nOK )
    {
    case 0:
        g_pItemMgr->m_kInventory.AddItem(kRecv.m_kItem, true);
        //아이템 추가 시켜주자!
        //g_pItemMgr->EquipInventoryItem( &g_kGlobalValue.m_kUserInfo.GetCurrentChar(), kRecv.m_kItem.m_ItemUID );
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_SELECT_ATTRIBUTE_SUCCESS_MSG),
            L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,false);
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_SELECT_ATTRIBUTE_ERROR1),
            L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,false);
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_SELECT_ATTRIBUTE_ERROR2),
            L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,false);
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_SELECT_ATTRIBUTE_ERROR3),
            L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,false);
        break;
    case 4: //
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_SELECT_ATTRIBUTE_ERROR3),
            L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,false);
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_RANDOM_ATTRIBUTE_16 ),
                strTemp,KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,false);
        }
        break;
    }
    Result_SelectAttribute = kRecv.m_nOK;
}

void On_EVENT_SOCKET_OPEN_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SOCKET_OPEN_ACK );
    SAFE_DELETE( pkBuff );

    // m_nOK 설명
    //1 : 소켓 봉인해제 할 아이템 없음
    //2 : 소켓 봉인해제/카드제거 캐쉬 아이템 없음
    //3 : 클라이언트가 보낸 봉인해제 아이템 ID 틀림
    //4 : 봉인해제 요청한 소켓 슬롯 ID 를 찾을 수 없음
    //5 : 봉인해제 요청한 소켓을 열 수 없는 상태

    std::wstring strMsg;
    std::wstring strTemp;
    switch( kRecv.m_nOK )
    {
    case 0:
        g_pItemMgr->m_kInventory.AddItem( kRecv.m_kItem, true );
        if( KGCItemSocketManagementDlg::UMK_CASHITEM == kRecv.m_nConsumeKind )
            g_pItemMgr->m_kInventory.AddItem( kRecv.m_kCashItem, true );
        else if( KGCItemSocketManagementDlg::UMK_GAMEPOINT == kRecv.m_nConsumeKind )
            g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGamePoint );
        
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_SOCKET_OPEN_SUCCESS );
        break;
    case 1:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_SOCKET_OPEN_ERROR0 );
        break;
    case 2:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_SOCKET_OPEN_ERROR1 );
        break;
    case 3:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_SOCKET_OPEN_ERROR4 );
        break;
    case 4:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_SOCKET_OPEN_ERROR2 );
        break;
    case 5:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_SOCKET_OPEN_ERROR3 );
        break;
    default:
        strMsg = g_pkStrLoader->GetString( STR_ID_ENCHANT_RESULT9 );
        strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        break;
    }

    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0 , false, true );
    Result_SocketManagement_Action = kRecv.m_nOK;

}
void On_EVENT_MONSTER_CARD_INSERT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MONSTER_CARD_INSERT_ACK );
    SAFE_DELETE( pkBuff );

    // 1 : 카드를 장착할 대상 아이템이 없음
    // 2 : 카드를 장착할 아이템의 소켓을 찾을 수 없음
    // 3 : 카드를 장착할 수 없는 소켓의 상태
    // 4 : 카드 장착시 GP 부족
    // 5 : 몬스터 카드 아이템 DB 동기화 실패
    // 6 : 사용 캐시 아이템 수량 DB 동기화 실패

    std::wstring strMsg;
    std::wstring strTemp;

    switch( kRecv.m_nOK )
    {
    case 0:
        g_pItemMgr->m_kInventory.AddItem( kRecv.m_kItem, true );
        if( KGCItemSocketManagementDlg::UMK_CASHITEM == kRecv.m_nConsumeKind )
            g_pItemMgr->m_kInventory.AddItem( kRecv.m_kCashItem, true );
        else if( KGCItemSocketManagementDlg::UMK_GAMEPOINT == kRecv.m_nConsumeKind )
            g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGamePoint );

        g_pItemMgr->m_kInventory.AddItem( kRecv.m_kCardItem, true );
        g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGamePoint );
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();

        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_SOCKET_CARD_EQUIP_SUCCESS );
        break;
    case 1:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_SOCKET_CARD_EQUIP_ERROR0 );
        break;
    case 2:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_SOCKET_CARD_EQUIP_ERROR1 );
        break;
    case 3:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_SOCKET_CARD_EQUIP_ERROR3 );
        break;
    case 4:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_SOCKET_CARD_EQUIP_ERROR2 );
        break;
    default:
        strMsg = g_pkStrLoader->GetString( STR_ID_ENCHANT_RESULT9 );
        strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        break;
    }
    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0 , false, true );
    Result_SocketManagement_Action = kRecv.m_nOK;

}

void On_EVENT_MONSTER_CARD_REMOVE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MONSTER_CARD_REMOVE_ACK );
    SAFE_DELETE( pkBuff );

//1 : 카드를 빼낼 아이템 없음
//2 : 카드를 빼낼 수 없는 소켓의 상태
//3 : 카드를 빼낼 소켓을 찾을 수 없음
//4 : 소켓 봉인해제/카드제거 캐쉬 아이템 없음

    std::wstring strMsg;
    std::wstring strTemp;
    switch( kRecv.m_nOK )
    {
    case 0:
        g_pItemMgr->m_kInventory.AddItem( kRecv.m_kItem, true );
        if( KGCItemSocketManagementDlg::UMK_CASHITEM == kRecv.m_nConsumeKind )
            g_pItemMgr->m_kInventory.AddItem( kRecv.m_kCashItem, true );
        else if( KGCItemSocketManagementDlg::UMK_GAMEPOINT == kRecv.m_nConsumeKind )
            g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGamePoint );

        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecInv, true );
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_SOCKET_CARD_REMOVE_SUCCESS );
        break;
    case 1:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_SOCKET_CARD_REMOVE_ERROR0 );
        break;
    case 2:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_SOCKET_CARD_REMOVE_ERROR1 );
        break;
    case 3:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_SOCKET_CARD_REMOVE_ERROR2 );
        break;
    case 4:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_SOCKET_CARD_REMOVE_ERROR3 );
        break;
    default:
        strMsg = g_pkStrLoader->GetString( STR_ID_ENCHANT_RESULT9 );
        strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        break;
    }

    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0 , false, true );
    Result_SocketManagement_Action = kRecv.m_nOK;
}

void On_EVENT_TIME_DROP_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KTimeDropItem );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nIndex : 그날 몇번째로 받는 아이템인지.
    // kRecv.m_vecItems : 받은 아이템 리스트.

    // 이 패킷을 받으면 kRecv.m_vecItems 아이템들 인벤토리 갱신만 해주세요.

    g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItems, true );
    
    if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
}

void On_ENU_SOCKET_TABLE_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KENU_SOCKET_TABLE_INFO_NOT );
    SAFE_DELETE( pkBuff );

    g_pItemMgr->SetSocketManagementCostTableInfo( kRecv.m_mapCashItemUseCount, kRecv.m_mapConsumeGP, kRecv.m_SocketOpenItemID );
}

void On_EVENT_GET_WEB_CASH_ITEM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GET_WEB_CASH_ITEM_ACK );
    SAFE_DELETE( pkBuff );

    Result_Buy = 0;

    if ( !kRecv.m_vecGetItems.empty() ) {
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecGetItems, true );


        // [1/20/2008] breadceo. 지금 있는걸로 퀵슬롯다시
        //	퀵슬롯 수량 체크 문제로 갱신안해 줍니다.
//		g_MyD3D->GetMyShortCutSlot()->Clear();
//      g_MyD3D->GetMyShortCutSlot()->initQuickSlot( g_kGlobalValue.m_kUserInfo.kQuickSlot );

        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();

        if ( g_pkUIScene->m_pkRickoonTornado->GetCreateComplete() ) {
            g_pkUIScene->m_pkRickoonTornado->SetCoinCount();
        }

        if (g_pkUIScene->m_pkSphinxDlg->GetCreateComplete()) {
            g_pkUIScene->m_pkSphinxDlg->UpdateCoin();
        }

#if defined( NATION_USA ) || defined( NATION_EU )
        g_pkUIScene->m_pkVipGachaBox->UpdateBadgeNum();
#endif    

#if defined (USE_AGIT_SYSTEM)
        // 배치 가능 오브젝트 리스트 갱신
        SiKGCAgitGameManager()->BuyDummyObject();
        SiKGCAgitGameManager()->RefreshInvenObject();
        g_pkAgitOverlayUI->UpdatePlaceCollectUI();
        g_pkUIScene->m_pkAgitShop->InitAgitShop(false);
#endif

        /*
        if (g_pItemMgr->GetCurrentSelectedGachaList()) {
            if (g_pkUIScene->GetClearSealDlg() && g_pkUIScene->GetClearSealDlg()->IsRenderOn())
                g_pkUIScene->GetClearSealDlg()->UpdateOwnItemList();
        }*/

        if ( g_pkUIScene->m_pkCoordiComposeDlg && g_pkUIScene->m_pkCoordiComposeDlg->IsRenderOn() )
            g_pkUIScene->m_pkCoordiComposeDlg->UpdateItemCount();
			
			
        if ( g_pkUIScene->m_pkCoordiUpgradeDlg && g_pkUIScene->m_pkCoordiUpgradeDlg->IsRenderOn() )
            g_pkUIScene->m_pkCoordiUpgradeDlg->UpdateItemCount();
			
        if( g_MyD3D->m_pStateMachine->GetState() == GS_CHAR_SELECT )
        {
            g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_BUT_ADD_SLOT_ITEM ) );
        }

        // GC 적립내역
        if( kRecv.m_kVirtualCashInfo.m_dwAddCashPoint == 0 ){
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
                g_pkStrLoader->GetString( STR_ID_BUY_ITEM_SUCCEEDED1 ),
                g_pkStrLoader->GetString( STR_ID_BUY_ITEM_SUCCEEDED2 ), KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        } else { 
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_BUY_CASH_ITEM_ACCUMULATED_GC_DLG, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
            g_pkUIScene->m_pkBuyCashItemAccumulatedGCDlg->SetAccumulateInfo( kRecv.m_kVirtualCashInfo );
        }
    }
}

void On_EVENT_ITEM_BREAKUP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ITEM_BREAKUP_ACK );
    SAFE_DELETE( pkBuff );

//     kRecv.m_nOK;
//     kRecv.m_kBreakupItem;   // 사용한 아歷?정보 아이템을 지워 주세요.
//     kRecv.m_vecMaterials;   // 얻은 아이템 목록 ( 재료 )
//     kRecv.m_bJackpot;       // 잭팟 여부
//     kRecv.m_nAccReelPoint;  // 누적 포인트( 서버에서 사용함. )

    // 오류값
    // 0 성공.
    // 1  해체 하려는 아이템이 존재 하지 않습니다.
    // 2  해체 가능한 아이템이 아닙니다.
    // 3  재료 아이템 정보 얻는중 오류.
    // 4  DB 처리 오류.
    // 5 비용 정보 얻기 실패
    // 6 보유 GP 부족

    // -98 처리중.

    std::wstring strMsg;
    std::wstring strTemp;
    switch( kRecv.m_nOK )
    {
    case 0:
        {
            g_pItemMgr->m_kInventory.RemoveItem( kRecv.m_kBreakupItem.m_ItemUID );

            // 장착중인 장비나 코디가 있는지 확인하고 제거해주도록 하자.
            KCharInfoVector::iterator vecCharIter = g_kGlobalValue.m_kUserInfo.vecCharInfo.begin();
            for(; vecCharIter != g_kGlobalValue.m_kUserInfo.vecCharInfo.end(); ++vecCharIter)
            {
                g_pItemMgr->UnequipItemForItemUID(&(*vecCharIter), kRecv.m_kBreakupItem.m_ItemUID);
                if( kRecv.m_kStrengthItem.m_ItemID != 0 ) {
                    g_pItemMgr->UnequipItemForItemUID(&(*vecCharIter), kRecv.m_kStrengthItem.m_ItemUID);
                }
            }

            std::vector<KDropItemInfo> vecReceivedMaterial;
            ItemDiff( kRecv.m_vecMaterials, vecReceivedMaterial );
            g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGP );


            std::vector<KItem> vecRewards = kRecv.m_vecMaterials;

            for (std::vector< KItem >::iterator vit = vecRewards.begin() ; vit != vecRewards.end() ; ++vit ){
                vit->m_ItemID /= 10;
                if(vit->m_nCount == -1) continue;
                KItem *pItem = NULL;
                g_pItemMgr->FindInventory(vit->m_ItemUID,&pItem);
                if(pItem == NULL) continue;

                vit->m_nCount = vit->m_nCount - pItem->m_nCount; 
            }

            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecMaterials, true );

            SiGCForgeManager()->SetResultItem(vecRewards);

            g_MyD3D->m_TempPlayer.SetMyPlayer(-1);	
            g_MyD3D->m_TempPlayer.ReleasePlayerResource();
            g_MyD3D->m_TempPlayer.UpdatePlayerResource(true);
            g_pkUIScene->m_pkMyInfoScene->UpdateData();

            g_pkUIScene->m_pkForgeDlg->SpeakToActionListener(KActionEvent( g_pkUIScene->m_pkForgeDlg, KGCUIScene::D3DWE_FORGE_COMPLETE_RESULT_ITEM ));
        }
        break;
    case 1:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_BREAKUP_ERROR0 );
        break;
    case 2:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_BREAKUP_ERROR1 );
        break;
    case 3:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_BREAKUP_ERROR2 );
        break;
    case 4:
        strMsg = g_pkStrLoader->GetString( STR_ID_RECOMMEND_ERROR_MESSAGE4 );
        break;
    case 5:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_BREAKUP_ERROR3 );
        break;
    case 6:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_BREAKUP_ERROR4 );
        break;
    case -98:
        strMsg = g_pkStrLoader->GetString( STR_ID_BINGO_ERROR7 );
        break;
    default:
        strMsg = g_pkStrLoader->GetString( STR_ID_BINGO_ERROR8 );
        strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        break;
    }

    if( false == strMsg.empty() )
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0 , false, true );

    SiGCForgeManager()->SetResultSendMaterial();

}


void On_EVENT_MANUFACTURES3_CATALOG_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<KManufactureItem> );
    SAFE_DELETE( pkBuff );


    //KManufactureItem::m_ItemID; ItemID
    //KManufactureItem::m_nDuration; Item 수량
    //KManufactureItem::m_nPeriod; Item 기간
    //KManufactureItem::m_nPrice; Item 만드는데 드는 비용.
    SiGCForgeManager()->SetRecipeAllList(kRecv);
    SiGCForgeManager()->SetResultSendMaterial();

}

void On_EVENT_MANUFACTURES3_MATERIAL_ACK( WPARAM wParam, LPARAM lParam )
{
    typedef std::map< PAIR_USHORT_DWORD, std::vector<KDropItemInfo> >  MATERIALS;
    KSerializer ks;
    ACK_DESERIALIZE( MATERIALS );
    SAFE_DELETE( pkBuff );

    SiGCForgeManager()->AddMaterialList(kRecv);
    SiGCForgeManager()->SetResultSendMaterial();

    //KDropItemInfo::m_ItemID; // Item ID
    //KDropItemInfo::m_nDuration; // 아이템 수량 ( -1 이면 영구 아이템)
    //KDropItemInfo::m_nPeriod; // 기본적으로 -1
}

void On_EVENT_MANUFACTURES3_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MANUFACTURES3_ACK );
    SAFE_DELETE( pkBuff );

    //1 ); // 아이템이 목록에 존재 하지 않음.
    //2 ); // 제작 아이템의 가격 정보가 잘못 되었음.
    //3 ); // GP가 충분하지 않음.
    //4 ); // 재료 정보가 없음.
    //5 ); // 재료 아이템을 보유하고 있지 않음.
    //6 ); // Item 삽입 실패.
    //7 ); // 코디 인벤토리 부족
    //9 ); // 전달된 재료 아이템이 존재하지 않음.
    //11 ); // 패키지 아이템을 수량으로 제작 하려고 함.
    // -98 현재 처리중..

    //kRecv.m_nOK; // OK 값.
    //kRecv.m_nGP; // 제작 후 나의 GP 덮어 쓰시오..
    //kRecv.m_vecRewards; // 받은 아이템.
    //kRecv.m_vecCountMaterialItems; // 사용된 수량 아이템
    //kRecv.m_vecPeriodMaterialItems; // 제거된 기간/영구 아이템.

    // 대충 아래와 같이 처리 하면 될듯.
    // 그리고 인벤 갱신..
    std::wstring strMsg;
    std::wstring strTemp;
    g_kGlobalValue.bItemCrafting = false;

    switch( kRecv.m_nOK ) 
    {
    case 0:
        {
            g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGP );
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecCountMaterialItems, true );

            //std::vector<KDropItemInfo> vecRewards;
            //ItemDiff( kRecv.m_vecRewards, vecRewards );
            //g_pkUIScene->m_pkItemCreationDlg->RefreshRecipeView();
            //g_pkUIScene->m_pkItemCreationDlg->SetRewardList( vecRewards );

            //g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewards, true );
            g_MyD3D->m_TempPlayer.SetMyPlayer(-1);	
            g_MyD3D->m_TempPlayer.ReleasePlayerResource();

            for (std::vector< GCITEMUID >::iterator vit = kRecv.m_vecPeriodMaterialItems.begin() ; vit != kRecv.m_vecPeriodMaterialItems.end() ; ++vit )
            {
                g_pItemMgr->m_kInventory.RemoveItem( *vit );


                // 장착중인 장비나 코디가 있는지 확인하고 제거해주도록 하자.
                KCharInfoVector::iterator vecCharIter = g_MyD3D->m_TempPlayer.m_kUserInfo.vecCharInfo.begin();
                for(; vecCharIter != g_MyD3D->m_TempPlayer.m_kUserInfo.vecCharInfo.end(); ++vecCharIter)
                {
                    g_pItemMgr->UnequipItemForItemUID(&(*vecCharIter),*vit);
                }
                g_MyD3D->m_TempPlayer.UnEquipPetforUID( *vit );
            }
            std::vector<KItem> vecRewards = kRecv.m_vecRewards;
            for (std::vector< KItem >::iterator vit = vecRewards.begin() ; vit != vecRewards.end() ; ++vit ){
                vit->m_ItemID /= 10;
                if(vit->m_nCount == -1) continue;
                KItem *pItem = NULL;
                g_pItemMgr->FindInventory(vit->m_ItemUID,&pItem);
                if(pItem == NULL) continue;

                vit->m_nCount = vit->m_nCount - pItem->m_nCount; 
            }

            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewards, true );

            SiGCForgeManager()->SetResultItem(vecRewards);



            g_MyD3D->m_TempPlayer.UpdatePlayerResource(true);
            g_MyD3D->m_TempPlayer.UpdateGlobalUserInfo();

            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_kGlobalValue.bItemCrafting = true;
        }
        break;
    case 1:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_CREATION_ERROR0 );
        break;
    case 2:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_CREATION_ERROR1 );
        break;
    case 3:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_CREATION_ERROR2 );
        break;
    case 4:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_CREATION_ERROR3 );
        break;
    case 5:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_CREATION_ERROR4 );
        break;
    case 6:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_CREATION_ERROR5 );
        break;
    case 7:
        strMsg = g_pkStrLoader->GetString( STR_ID_CREATE_CODI_ITEM_ERR );
        break;
    case 8:
        break;
    case 11:
        strMsg = g_pkStrLoader->GetString( STR_ID_ITEM_CREATION_ERROR6 );
        break;
    case -98:
        strMsg = g_pkStrLoader->GetString( STR_ID_BINGO_ERROR7 );
        break;
    default:
        strMsg = g_pkStrLoader->GetString( STR_ID_BINGO_ERROR8 );
        strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        break;
    }

    g_pkUIScene->m_pkForgeDlg->SpeakToActionListener(KActionEvent( g_pkUIScene->m_pkForgeDlg, KGCUIScene::D3DWE_FORGE_COMPLETE_RESULT_ITEM ));

    if( false == strMsg.empty() )
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0 , false, true );

    SiGCForgeManager()->SetResultSendMaterial();

}

void On_EVENT_ITEM_BREAKUP_PRICE_RATIO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( float );
    SAFE_DELETE( pkBuff );

}

void On_ENU_LOADING_IMAGE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KENU_LOADING_IMAGE_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_vecNewsNumber;        // 서버목록 옆에 띄우는 이미지 채널 뉴스 넘버
    // kRecv.m_prLoadingImageName; // 로딩이미지 이름
    // kRecv.m_mapScriptName;      // 스크립티 이름
    // kRecv.m_vecExceptionMotionID;       // 예외 모션 ID 여기 걸리는 ID발생시 꺼주십니당.

    Result_Loading_image = 0;

    g_kGlobalValue.SetLoadingImageData( kRecv.m_vecLoadingImageName, kRecv.m_vecNewsNumber);
    g_kGlobalValue.SetPvPLoadingImageName(kRecv.m_mapPVPLoadingImageName);
    g_kGlobalValue.SetSquareScriptName( kRecv.m_mapScriptName[KENU_LOADING_IMAGE_ACK::SCF_SQUARE],
        kRecv.m_mapScriptName[KENU_LOADING_IMAGE_ACK::SCF_SQUAREOBJECT],
        kRecv.m_mapScriptName[KENU_LOADING_IMAGE_ACK::SCF_SQUARE3DOBJECT]
    );
    g_kGlobalValue.SetCharSkillEnable(kRecv.m_setCharSkillEnable);
    g_kGlobalValue.SetvecExceptionMotionID(kRecv.m_vecExceptionMotionID);
    g_kGlobalValue.SetChampionAbility(kRecv.m_mapChampionRatio);

    g_kGlobalValue.SetEventBannerInfo(kRecv.m_vecEventBannerInfo);

    g_kGlobalValue.m_vecEventOpenInfo = kRecv.m_vecEventOpenInfo;

    //Blacklist In the InitClientContents(Center Server Script , TableName is 'DLLBlackList')
    g_kGlobalValue.m_setBlackDllList = kRecv.m_setDLLBlackList;
    g_kGlobalValue.m_vecExtendSHAList = kRecv.m_vecExtendSHAList;
    g_kGlobalValue.SetSmartPanelMailList( kRecv.m_bSmartPanelMailListEnable, kRecv.m_vecSmartPanelMailList );

//    g_MyD3D->m_fileDownloadManager.SetDownLoadURL( FileDownloadManager::EDOWN_EVENT_BANNER, L"http://14.45.79.22/cp/GrandChase/" );
    g_kGlobalValue.SetChannerImgClickURL(kRecv.m_mapChannelImageDownloadURLList[0]);
    g_MyD3D->m_fileDownloadManager.SetDownLoadURL( FileDownloadManager::EDOWN_CHANNEL_IMG, kRecv.m_mapChannelImageDownloadURLList[1] );

#if defined(NATION_CHINA)
    std::wstring strImageName;

    for (int i=0 ; i< KGCNewsFrame::MAX_NEWS ; i++)
    {
        WCHAR temp[MAX_PATH];
        wsprintf( temp, L"%d.png", i+1 );
        strImageName = temp;

        //파일 전송한다.
        g_MyD3D->m_fileDownloadManager.InsertDownloadData(strImageName, FileDownloadManager::EDOWN_CHANNEL_IMG);
    }
#endif

}

void On_ENU_CLIENT_CONTENTS_FIRST_INIT_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CLIENT_CONTENTS_FIRST_INIT_INFO_NOT );
    SAFE_DELETE( pkBuff );

    // kRecv.m_vecNewsNumber;        // 서버목록 옆에 띄우는 이미지 채널 뉴스 넘버
    // kRecv.m_prLoadingImageName; // 로딩이미지 이름
    // kRecv.m_mapScriptName;      // 스크립티 이름
    // kRecv.m_vecExceptionMotionID;       // 예외 모션 ID 여기 걸리는 ID발생시 꺼주십니당.

    Result_Loading_image = 0;

    g_kGlobalValue.SetLoadingImageData( kRecv.m_prUsingFilesInfo.second.m_mapLoadingImageName, kRecv.m_prUsingFilesInfo.second.m_vecNewsNumber);
    g_kGlobalValue.SetPvPLoadingImageName(kRecv.m_prUsingFilesInfo.second.m_mapPVPLoadingImageName);
    g_kGlobalValue.SetSquareScriptName( kRecv.m_prUsingFilesInfo.second.m_mapScriptName[KCCUsingFilesInfo::SCF_SQUARE],
        kRecv.m_prUsingFilesInfo.second.m_mapScriptName[KCCUsingFilesInfo::SCF_SQUAREOBJECT],
        kRecv.m_prUsingFilesInfo.second.m_mapScriptName[KCCUsingFilesInfo::SCF_SQUARE3DOBJECT]
    );
    g_kGlobalValue.SetEventBannerInfo(kRecv.m_prUsingFilesInfo.second.m_vecEventBannerInfo);
    g_kGlobalValue.SetvecExceptionMotionID(kRecv.m_prHackCheckInfo.second.m_vecExceptionMotionID);
    g_kGlobalValue.m_setBlackDllList = kRecv.m_prHackCheckInfo.second.m_setDLLBlackList;

    //Blacklist In the InitClientContents(Center Server Script , TableName is 'DLLBlackList')
    
    //g_kGlobalValue.m_vecExtendSHAList = kRecv.m_kHackCheckInfo.m_vecExtendSHAList;


}

void On_ENU_CLIENT_CONTENTS_FIRST_INIT_ADDITIONAL_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KENU_CLIENT_CONTENTS_FIRST_INIT_ADDITIONAL_INFO_ACK );
    SAFE_DELETE( pkBuff );

    //kRecv.m_bSmartPanelMailListEnable;      //스마트패널 사용 유무
    //kRecv.m_vecSmartPanelMailList;          //스마트패널 메일리스트
    //kRecv.m_mapChannelImageDownloadURLList; //채널이미지 다운로드 주소

    Result_ClientContentsAdditionInfo = 0;

    g_kGlobalValue.SetSmartPanelMailList( kRecv.m_bSmartPanelMailListEnable, kRecv.m_vecSmartPanelMailList );

    g_kGlobalValue.SetChannerImgClickURL(kRecv.m_mapChannelImageDownloadURLList[0]);
    g_MyD3D->m_fileDownloadManager.SetDownLoadURL( FileDownloadManager::EDOWN_CHANNEL_IMG, kRecv.m_mapChannelImageDownloadURLList[1] );

    std::wstring strImageName;

    for (int i=0 ; i< KGCNewsFrame::MAX_NEWS ; i++)
    {
        WCHAR temp[MAX_PATH];
        wsprintf( temp, L"%d.png", i+1 );
        strImageName = temp;

        //파일 전송한다.
        g_MyD3D->m_fileDownloadManager.InsertDownloadData(strImageName, FileDownloadManager::EDOWN_CHANNEL_IMG);
    }
}

void On_EVENT_PRESENTBOX_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_PRESENTBOX_INFO_ACK );
    SAFE_DELETE( pkBuff );
    /*
    // 0 : 선물 상자 이벤트 정보 가져오기 성공
    // 1 : 선물 상자 이벤트 기간이 아님.
    // -98 : 아직 처리중인 작업입니다.
    */
    if( kRecv.m_nOK == 0 )
    {
        g_pkUIScene->m_pkPuzzle->m_mapTradeList = kRecv.m_mapTradeList;
        g_pkUIScene->m_pkPuzzle->m_vecRewardList = kRecv.m_vecRewardList;
    }
    
    g_pkUIScene->m_pkPuzzle->m_iOK = kRecv.m_nOK;
}

void On_EVENT_PRESENTBOX_TRADE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_PRESENTBOX_TRADE_ACK );
    SAFE_DELETE( pkBuff );
    /*
    // 0 : 성공.
    // 1 : 선물상자 이벤트 기간이 아님. 
    // 2 : 선물상자 조각 아이템이 존재 하지 않음. 
    // 3 : 선물상자 교환 아이템 정보가 없습니다. 
    // -98 : 아직 처리중인 작업입니다.
    */
    if( kRecv.m_nOK == 0 )
    {
        OnItemReceiveSmallBox( kRecv.m_vecItem, true, true );		
        g_pItemMgr->m_kInventory.AddItemList(kRecv.m_vecUseItem);
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();

    }

    g_pkUIScene->m_pkPuzzle->m_iOK = kRecv.m_nOK;
}

void On_EVENT_PRESENTBOX_ACTION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_PRESENTBOX_ACTION_ACK );
    SAFE_DELETE( pkBuff );

    if( kRecv.m_nOK == 0 )
    {
        OnItemReceiveSmallBox( kRecv.m_vecItem, true, true );
        g_pItemMgr->m_kInventory.AddItemList(kRecv.m_vecUseItem);
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
    }
    
    g_pkUIScene->m_pkPuzzle->m_iOK = kRecv.m_nOK;

    /*
    // 0 : 성공.
    // 1 : 선물상자 이벤트 기간이 아님. 
    // 2 : 선물상자 조각 아이템이 존재 하지 않음. 
    // 3 : 선물상자 교환 아이템 정보가 없습니다. 
    // 4 : 꽝입니다
    // 5 : 로터리에 등록 되지 않음.
    // -98 : 아직 처리중인 작업입니다.
    */
}

void On_EVENT_STRING_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_STRING_INFO_NOT );
    SAFE_DELETE( pkBuff );
    KEVENT_STRING_INFO_NOT::iterator   it = kRecv.begin();

    //신규 첫 접속자는 이벤트 메세지를 알리지 않는다 - 지훈형 요청.
    if (g_kGlobalValue.m_kLoginInfo.bNewUser)
        return;

    //// 공지 다 끝나면 이벤트 캐릭터 획득 있을때 알려 줍시다. 
    //if( g_kGlobalValue.m_iGetCharType > -1 &&  g_kGlobalValue.m_iGetCharType < GC_CHAR_NUM) { 
    //    if( false == g_pkUIScene->m_pkCharGetInfoDlg->IsCreate() ) {    
    //        g_pkUIScene->m_pkCharGetInfoDlg->Create(); 
    //    }

    //    g_pkUIScene->m_pkCharGetInfoDlg->SetInfo( true, g_kGlobalValue.m_iGetCharType, 0 );
    //    g_pkUIScene->m_pkCharGetInfoDlg->SetShow( true );
    //    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GET_NEW_CHARACTER );

    //    g_kGlobalValue.m_iGetCharType = -1;
    //}

    if( g_pkUIScene->m_pkCharGetInfoDlg->IsRenderOn() == false ) { 
        for(;it != kRecv.end();it++)
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( *it ));     
        }
    }
}

void On_EVENT_ITEM_BUY_CHECK_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ITEM_BUY_CHECK_ACK );
    SAFE_DELETE( pkBuff );

    /* 아이템 구매제한 체크
    0 : 성공 (구매가능)
    1 : 구매제한 아이템이 아님 (구매가능)

    2 : 구매제한 횟수 초과. (구매한도 초과)
    3 : 인벤토리가 충분하지 않음. (인벤토리 부족)
    4 : 코디인벤토리가 충분하지 않음. (인벤토리 부족)
    5 : 아지트인벤토리가 충분하지 않음.
    6 : 아이템 소지한도 초과.
    -98 : 아직 처리중인 작업.
    */
    Result_CanBuyCashItem = kRecv.m_nOK;
}

void On_EVENT_DUNGEON_STATE_ACK( WPARAM wParam, LPARAM lParam )
{
    typedef std::map<int,std::vector<KGameModeState> > MAP_GAMEMODE;
    KSerializer ks;
    ACK_DESERIALIZE( MAP_GAMEMODE );
    SAFE_DELETE( pkBuff );

    //std::map<int,KGameModeState> => < GameMode, Status >

    // KGameModeState::m_nDifficulty; 난이도. ( 0 ~ 3 ) 3 => 챔피언.
    // KGameModeState::m_nPublicWaitRoomCount; 공개 대기방
    // KGameModeState::m_nPrivateWaitRoomCount; 비공개 대기방
    // KGameModeState::m_nPlayingRoomCount; 플레이중인방.

    //SiKGCWorldMapManager()->SetMapRoomCount( kRecv );
}

void On_EVENT_GIFT_ITEM_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector<KGiftInfo> );
    SAFE_DELETE( pkBuff );

    // KGiftInfo::m_dwItemID;  // 선물 받은 ItemID
    // KGiftInfo::m_strBuyerNick; // 선물 한 사람 닉네임.
    // KGiftInfo::m_strMsg;  // 메세지
    std::vector<KGiftInfo>::iterator vit = kRecv.begin();

    for ( ; vit != kRecv.end(); ++vit )
    {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GIFT_ITEM_BOX, vit->m_strBuyerNick, vit->m_strMsg, KGCUIScene::GC_MBOX_USE_NORMAL, vit->m_dwItemID/10, 0 ,true, false);
    }
}

//void On_EVENT_TOURNAMENT_DONATION_ACK( WPARAM wParam, LPARAM lParam )
//{
//    /*
//    OK값 설명.
//    0 : // 성공
//    1 : // 이벤트 기간이 아님.
//    2 : // 서버 클라이언트간 기부 아이템 번호 불일치.
//    3 : // 기부 아이템 가져오기 실패.
//    4 : // 기부 아이템 갯수가 부족하다.
//    5 : // DB에 기부 정보 넣기 실패.
//    */
//    KSerializer ks;
//    ACK_DESERIALIZE( KEVENT_TOURNAMENT_DONATION_ACK );
//    SAFE_DELETE( pkBuff );  
//
//    switch( kRecv.m_nOK )
//    {
//    case 0: //성공
//        {
//            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecUseItem, true );
//            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_VOTE_SUCCESS), L""
//                , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0 , false, true );
//            break;
//        }
//    default:
//        {
//            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
//            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_VOTE_FAILURE), strTemp
//                , KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false , true );
//        }
//    }
//}

void On_ENU_GUIDE_BOOK_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( MAP_SHORT_SHORT );
    SAFE_DELETE( pkBuff );
    
    if ( kRecv.empty() ) {
        //아무 데이터 없음..
    }

    //g_MyD3D->m_kGuideMgr.InitGuideBookHistory( kRecv );

    // 훼이크로 여기에 케릭터 정보를 넣었습니다.
    // 추후에 확장 시 일정 받아서 작업하기로 함.
    const short SavedCharType = 255;
    MAP_SHORT_SHORT::iterator mit = kRecv.find( SavedCharType );
    if( mit != kRecv.end() ) {
        char charType = static_cast<char>(mit->second);
        g_kGlobalValue.SetSavedCharType( charType );
    }
}

void On_ENU_TEXTURE_DYNAMIC_LOAD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( bool );
    SAFE_DELETE( pkBuff );

    kRecv; // true이면 수집, false 이면 수집 않함.

}

void On_ENU_CLIENT_PING_CONFIG_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPingConfig );
    SAFE_DELETE( pkBuff );

    SetRelayPingInterval( kRecv.m_dwPingCheckGap );
    SetRelayPingLimit( kRecv.m_dwPingLimitValue );
    SetRelayPingOutCount( kRecv.m_nRepetitionCount );
    kRecv.m_nJoinRoomLimitPing;

    g_kGlobalValue.m_dwJoinRoomLimitPing = kRecv.m_nJoinRoomLimitPing;
}
void On_ENU_SHAFILENAME_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KENU_SHAFILENAME_LIST_ACK );
    SAFE_DELETE( pkBuff );

    Result_SHAFileList = 0;


    g_setSHAFileList = kRecv;
}

void On_ENU_STAY_SERVER_TIMEOUT ( WPARAM wParam, LPARAM lParam )
{
    ::MessageBoxW( NULL, g_pkStrLoader->GetString( STR_ID_STAY_SERVER_TIMEOUT ).c_str(), g_pkStrLoader->GetString( STR_ID_APPMSG_ERR_CASH_FAIL_TITLE ).c_str(), MB_OK );

    exit(0);
}

void On_EVENT_GET_ROOMUSER_PRESS_STATE_ACK( WPARAM wParam, LPARAM lParam )
{
    typedef std::vector<std::pair<DWORD, KPressureState> > ROOM_MEMBERS_STATE;
    KSerializer ks;
    ACK_DESERIALIZE( ROOM_MEMBERS_STATE );

    for (int i=0;i<(int)kRecv.size();i++)
    {
        SiKGCRoomManager()->SetPressureState( kRecv[i].first, kRecv[i].second );
    }	

    SAFE_DELETE( pkBuff );

}
void On_EVENT_PRESS_STATE_NOT( WPARAM wParam, LPARAM lParam )
{
    typedef std::pair<DWORD, KPressureState> PRESS_STATE;
    KSerializer ks;
    ACK_DESERIALIZE( PRESS_STATE );

    SiKGCRoomManager()->SetPressureState( kRecv.first, kRecv.second );
    SAFE_DELETE( pkBuff );
}
void On_EVENT_PRESSURE_USER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_PRESSURE_USER_NOT );
    SiKGCRoomManager()->PressureUser( kRecv.m_dwRequestee);
    SAFE_DELETE( pkBuff );

}
void On_EVENT_GET_ROOMUSER_IDLE_STATE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    typedef std::vector<std::pair<DWORD, int> > ROOM_MEMBERS_IDLE_STATE;
    //int 0 실패 1 OK
    ACK_DESERIALIZE( ROOM_MEMBERS_IDLE_STATE );
    for (int i=0;i<(int)kRecv.size();i++)
    {
        SiKGCRoomManager()->SetIdleState(kRecv[i].first , kRecv[i].second == 0 ? false : true);
    }
    SAFE_DELETE( pkBuff );

}
void On_EVENT_IDLE_STATE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    //int 0 실패 1 OK
    typedef std::pair<DWORD, int> IDLE_STATE;
    ACK_DESERIALIZE( IDLE_STATE );
    SiKGCRoomManager()->SetIdleState( kRecv.first, kRecv.second == 0 ? false : true );
    SAFE_DELETE( pkBuff );

}

// 핑 안테나
void On_EVENT_ROOM_MEMBER_PING_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    typedef std::vector<std::pair<DWORD,DWORD> > MEMBER_PING_INFO;
    KSerializer ks;
    ACK_DESERIALIZE( MEMBER_PING_INFO );
    SAFE_DELETE( pkBuff );
    kRecv; // 방원들의 Ping 정보.std::vector<std::pair<USerUID,PingTime> >
    
    if( g_MyD3D->m_pStateMachine->GetState() == GS_GAME || g_MyD3D->m_pStateMachine->GetState() == GS_GAME_LOADING )
    {
        if( SiKGCRoomManager()->GetGameModeCategory() != GC_GMC_DUNGEON )
        {
            g_pkUIScene->m_pkGameOverlayUI->GetHeadUp()->SetPlayerStatusBar();
        }
        g_pkUIScene->m_pkGameOverlayUI->SetPlayingGameUserPing(kRecv);
    }
    else
    {
        g_pkUIScene->m_pkRoomSceneS6->SetRoomMemberPingInfo(kRecv);
    }
}


// 이 패킷을 받을 시는 게임에서 나가게 된다.( 모든 정상처리 필요 )
void On_EVENT_LOW_PING_NOT( WPARAM wParam, LPARAM lParam )
{
    
    KSerializer ks;
    ACK_DESERIALIZE( DWORD );
    SAFE_DELETE( pkBuff );
    kRecv; // 나의 평균 핑
    
    g_pStateGame->OnExitGame();
    g_pkUIScene->m_pkGameOverlayUI->HideAllQuestTitle();
    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_EXIT_ROOM,
        g_pkStrLoader->GetString( STR_ID_NETWORK_TOO_SLOW ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );


    SiGCClientErrorManager()->ErrorCollect( KEventErr::ERR_CLIENTRPT, KClientErr::CE_BAD_CONNECTION_USER );
}

void On_EVENT_LOAD_COMPLETE_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_LOAD_COMPLETE_BROAD );
    SAFE_DELETE( pkBuff );

    kRecv; // 로딩 실패 유저들

    // 로딩 실패 유저들이 있다면 지워준다.
    for( int i = 0; i < (int)kRecv.size(); i++ )
    {
        KEVENT_INFORM_USER_LEAVE_ROOM_NOT kFailUserInfo;
        kFailUserInfo.m_dwUserUID = kRecv[i];
        On_DESTROY_USER(kFailUserInfo);
    }

    KGCStateLoading* pState = (KGCStateLoading*)g_MyD3D->m_pStateMachine->GetStatePtr( GS_GAME_LOADING );    
    pState->SetLoadCompleteInServer(true);
}

void On_EVENT_STAGE_LOAD_COMPLETE_BROAD( WPARAM wParam, LPARAM lParam ) 
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_STAGE_LOAD_COMPLETE_BROAD );
    SAFE_DELETE( pkBuff );

    kRecv; // 로딩 실패 유저들

    // 로딩 실패 유저들이 있다면 지워준다.
    for( int i = 0; i < (int)kRecv.size(); i++ )
    {
        KEVENT_INFORM_USER_LEAVE_ROOM_NOT kFailUserInfo;
        kFailUserInfo.m_dwUserUID = kRecv[i];
        On_DESTROY_USER(kFailUserInfo);
    }

    g_pkGameOverlayUI->FadeInOrOut( true );
    g_pkGameOverlayUI->CheckAllPlayerLoadComplete();
    g_MyD3D->m_pkQuestGameMgr->AllStageLoadComplete();
}

void On_EVENT_LOADING_TIME_OVER_NOT( WPARAM wParam, LPARAM lParam )
{
    // 데이터는 없음. 이벤트 아이디만 존재
    g_pStateGame->OnExitGame();
    g_pkUIScene->m_pkGameOverlayUI->HideAllQuestTitle();

    std::wstring strTemp = boost::str(boost::wformat( L"%1% - (%2%)")
        %g_pkStrLoader->GetString( STR_ID_CAN_NOT_LOADCOMPLETE2 )%KClientErr::EM_LOADING_TIME_OUT2);
    
    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_EXIT_ROOM,
            g_pkStrLoader->GetString( STR_ID_CAN_NOT_LOADCOMPLETE1 ),
            strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );

    SiGCClientErrorManager()->ErrorCollect( KEventErr::ERR_CLIENTRPT, KClientErr::CE_INFINITLOADING );
}

void On_EVENT_RELAY_LOADING_STATE( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( PAIR_DWORD_INT );
    SAFE_DELETE( pkBuff );

    kRecv; //유저의 로딩상태

    if( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_DUNGEON )
    {
        g_pkUIScene->m_pkGameOverlayUI->DungeonMembersLoadingState(kRecv);
    }
    else if( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_AUTOMATCH )
    {
        g_pkUIScene->m_pkAutoMatchLoading->SetProgress(kRecv);
    }
    else if( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_MATCH ||
             SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_ANGELS_EGG ||
             SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_DOTA )
    {
        g_pkUIScene->m_pkLoadingScene->SetLoadingState(kRecv);
    }
}

void On_EVENT_GET_ACHIEVEMENT_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KAchievementFullInfo );
    SAFE_DELETE( pkBuff );

    kRecv.m_setCompledList; // std::set<int> 이미 완료한 업적 ID리스트
    kRecv.m_setWaitForComplet; // std::set<int> 완료 가능한 업적 리스트
    kRecv.m_mapGoalInfo; // std::map<int,int>  < CounterID, Count > 


}
void On_EVENT_REPORT_ACHIEVEMENT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::set<int> );
    SAFE_DELETE( pkBuff );

    kRecv; //std::set<int> 완료 가능한 업적 리스트.std::set<int>

}
void On_EVENT_COMPLETE_ACHIEVEMENT_SILENT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::set<int> );
    SAFE_DELETE( pkBuff );

    kRecv; // std::set<int> 보상이 없어서 자동으로 완료한 업적 리스트

}
void On_EVENT_COMPLETE_ACHIEVEMENT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_COMPLETE_ACHIEVEMENT_ACK );
    SAFE_DELETE( pkBuff );


    kRecv.m_nOK; // 성공 여부.
    kRecv.m_nAchieveID; // 이번에 완료된 업적 (요청한것)
    kRecv.m_nGP; // 보상 GP
    kRecv.m_nTagID; // 보상 Tag
    kRecv.m_vecItems; // 보상 아이템들..
}

void On_EVENT_CHECK_ACHIEVE_FROM_SERVER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::set<int> );
    SAFE_DELETE( pkBuff );

    kRecv; //std::set<int> 완료 가능한 업적 리스트.std::set<int>
    // 이 패킷이 온 후 "EVENT_COMPLETE_ACHIEVEMENT_SILENT_ACK" 가 올 가능성 있음.
}

void On_EVENT_CHANGE_NORMAL_TO_LOOK_ACK( WPARAM wParam, LPARAM lParam )
{
    // 일반 아이템을 룩으로
    KSerializer ks;
    ACK_DESERIALIZE( KChangeLookItem );
    SAFE_DELETE( pkBuff );

    kRecv;
    kRecv.m_nOK;
    kRecv.m_vecChangeItem; // 변경하는데 사용 되는 소비 아이템..
    kRecv.m_vecItems; // 변경된 Item의 UID

    switch( kRecv.m_nOK ) {
    case 0:
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecChangeItem, true );
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItems, true ); 
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
            g_pkStrLoader->GetString(STR_ID_ALL_CHAR_UNEQUIP1),
            g_pkStrLoader->GetString(STR_ID_ALL_CHAR_UNEQUIP2),
            KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
            g_pkStrLoader->GetString(STR_ID_COORDI_CHANGE2), L"",
            KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
            g_pkStrLoader->GetString(STR_ID_COORDI_CHANGE1),
            g_pkStrLoader->GetReplacedString(STR_ID_COORDI_INVENTORY_FULL_ERROR, "i", kRecv.m_nOK ),
            KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
        break;
    case 8:
        break;
    default:
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );	
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
            g_pkStrLoader->GetString(STR_ID_COORDI_CHANGE1),
            strTemp,
            KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
        break;
    }

    // 1 요청 패킷이 비어 있음.
    // 2 교환 아이템의 수량이 부족.
    // 3 변경 하려는 아이템을 보유하고 있지 않음
    // 4 변경 할려는 아이템이 현재 일반 아이템이 아님
    // 5 변경 할려는 아이템을 장착 하고 있음.
    // 6 룩 아이템으로 변환중 DB 오류.
    // 7 룩 인벤크기 초과.
    // 8 변경 할려는 아이템이 룩변환 금지 아이템
    // -98 이미 처리 중임..
}

void On_EVENT_CHANGE_LOOK_TO_NORMAL_ACK( WPARAM wParam, LPARAM lParam )
{
    // 룩 아이템을 일반 아이템으로.
    KSerializer ks;
    ACK_DESERIALIZE( KChangeLookItem );
    SAFE_DELETE( pkBuff );

    kRecv;
    kRecv.m_nOK;
    kRecv.m_vecChangeItem; // 소비 아이템.
    kRecv.m_vecItems; // 변경된 Item UID

    switch( kRecv.m_nOK ) {
    case 0:
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecChangeItem, true );
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItems, true );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
            g_pkStrLoader->GetString(STR_ID_ALL_CHAR_UNEQUIP1),
            g_pkStrLoader->GetString(STR_ID_ALL_CHAR_UNEQUIP2),
            KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
        break;
    case 6:
        break;
    default:
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );	
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
            g_pkStrLoader->GetString(STR_ID_COORDI_CHANGE1),
            strTemp,
            KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
        break;
    }

    //  1  요청 패킷이 비어 있음.
    //  2  변경 하려는 아이템을 보유하고 있지 않음
    //  3  변경 할려는 아이템이 현재 룩이 아님
    //  4  변경 할려는 아이템을 장착 하고 있음.
    //  5  일반 아이템으로 변환중 DB 오류.
    //  6  변경 할려는 아이템이 일반변환 금지 아이템
    // -98 이미 처리 중임..

}

void On_EVENT_SAVE_COORDI_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );

    kRecv;
    // 1  코디 저장시 없는 캐릭터 정보를 보내 왔음.
    // 2  해당 캐릭터의 코디 정보가 없음.
    // 3  저장하려는 코디의 코디 ID 가 범위를 벗어났음.
    // 4  해당 아이템을 보유 하고 있지 않음.
    // 5  해당 아이템은 룩 아이템이 아닙니다.
    // 6  코디 이름 길이가 초과 되었음.
}

void On_EVENT_CHANGE_LOOK_EQUIP_NOT(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KChangeLookEquipInfo);
    SAFE_DELETE(pkBuff);

    kRecv;
    kRecv.m_dwUID;
    kRecv.m_mapCurrentLookEquip;

    PLAYER* pPlayer = NULL;

    if (g_MyD3D->m_pStateMachine->IsStateRoom() || g_MyD3D->m_pStateMachine->GetState() == GS_GAME)
    {
        pPlayer = g_MyD3D->GetPlayerByUID(kRecv.m_dwUID);
    }

    SUserInfo* pUserInfo = NULL;
    bool bLocalPlayer = (g_kGlobalValue.m_kUserInfo.dwUID == kRecv.m_dwUID);
    if (pPlayer == NULL && bLocalPlayer) {
        pUserInfo = &g_kGlobalValue.m_kUserInfo;
    }
    else if (pPlayer != NULL) {
        pUserInfo = &pPlayer->m_kUserInfo;
    }

    ASSERT(pUserInfo);
    RETURN_NIL(pUserInfo);

    std::map<char, std::vector<KEquipItemInfo> >::iterator mit = kRecv.m_mapCurrentLookEquip.begin();
    for (; mit != kRecv.m_mapCurrentLookEquip.end(); ++mit) {
        SCharInfo& sCharInfo = pUserInfo->GetCurrentChar(mit->first);
        sCharInfo.vecLookInfo.clear();

        std::vector<KEquipItemInfo>::iterator sit = mit->second.begin();
        sCharInfo.vecLookInfo.clear();
        for (; sit != mit->second.end(); ++sit) {
            if (bLocalPlayer) {
                g_pItemMgr->EquipInventoryItem(&sCharInfo, (*sit).m_dwUID, true);
            }
            else {
                SUserItem kLookItem;
                kLookItem = *sit;
                sCharInfo.vecLookInfo.push_back(kLookItem);
            }
        }
    }

    if (bLocalPlayer) {
        g_kGlobalValue.m_kUserInfo = *pUserInfo;
    }

    if (pPlayer != NULL) {
        pPlayer->RemovePlayerObject();
        pPlayer->UpdatePlayerResource();
    }

    if (g_MyD3D->m_pStateMachine->GetState() == GS_ROOM)
        g_pkUIScene->RoomSceneUpdateData();
    else if (g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO)
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
    else if (g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO_FROM_ROOM)
    {
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->RoomSceneUpdateData();
    }
    else if (g_MyD3D->m_pStateMachine->GetState() == GS_CHAR_SELECT_FROM_ROOM)
    {
        g_pkUIScene->RoomSceneUpdateData();
    }
}

void On_EVENT_CHANGE_LOOK_EQUIP_ACK( WPARAM wParam, LPARAM lParam )
{
    // 룩 장착 변경 실패시 본인만 받는다.
    KSerializer ks;
    ACK_DESERIALIZE( KChangeLookEquipInfo );
    SAFE_DELETE( pkBuff );

    kRecv;
    kRecv.m_dwUID; // 장착을 변경한 사람..
    kRecv.m_mapCurrentLookEquip; // 장착 내용.. <캐릭터 타입, 장착한 아이템 UID>

    Result_CoordiEquip = 0;

    SUserInfo* pUserInfo = NULL;
    pUserInfo = &g_kGlobalValue.m_kUserInfo;

    ASSERT( pUserInfo );
    RETURN_NIL( pUserInfo );

    std::map<char, std::vector<KEquipItemInfo> >::iterator mit = kRecv.m_mapCurrentLookEquip.begin();
    for( ; mit != kRecv.m_mapCurrentLookEquip.end() ; ++mit ) {
        SCharInfo& sCharInfo = pUserInfo->GetCurrentChar( mit->first );
        sCharInfo.vecLookInfo.clear();

        // 여기에 들어있는 DWORD는 ItemID 일수도 있고 ItemUID 일 수도 있다.
        // 나의 변경 정보일 경우에는 ItemUID가 들어있고,
        // 방에서 타인의 변경 정보를 받은 경우에는 ItemID가 들어 있다.
        std::vector<KEquipItemInfo>::iterator sit = mit->second.begin();
        sCharInfo.vecLookInfo.clear();
        for( ; sit != mit->second.end(); ++sit ) {
            g_pItemMgr->EquipInventoryItem( &sCharInfo, (*sit).m_dwUID, true );
        }
    }

    g_kGlobalValue.m_kUserInfo = *pUserInfo;
}

void On_EVENT_FULL_LOOK_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    // 전체 장착 정보.
    // 게임 서버 접속후 인증 이후 받게됨..
    // 코디 아이디 0 번이 현재 장착이다.
    KSerializer ks;
    ACK_DESERIALIZE( KLookFullInfo );
    SAFE_DELETE( pkBuff );

    kRecv;
    kRecv.m_mapLookFullInfo; // <캐릭터 타입, < 코디 ID, 코디 정보.> >
    kRecv.m_changeItemID; // 변환 아이템 ID
    kRecv.m_nMaxLookInvenSize; // 룩 인벤 최대 사이즈.

    g_pItemMgr->SetCoordiInventoryMaxSize( kRecv.m_nMaxLookInvenSize );

    //KCoordiInfo::m_nCoordiID; -> 코디 아이디
    //KCoordiInfo::m_setEquip;  -> 장착 아이템UID
    //KCoordiInfo::m_strCoordiName; -> 해당 코디 이름.
}

void On_EVENT_BUNDLE_SELL_ITEM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BUNDLE_SELL_ITEM_ACK );
    SAFE_DELETE( pkBuff );

    kRecv.m_nOK; // 전체에 문제 있을 경우 이녀석이 0이 아닌값을 나타 냅니다.
    kRecv.m_mapFailInfo; // 판매시 오류 발생한 아이템에 대한 오류값. < Item UID, 오류값 >
    kRecv.m_nGamePoint; // 나의 보유 GP (전체량..)
    kRecv.m_vecRewardItem; // 판매후 받은 아이템 (잽, 크리스탈.)
    kRecv.m_vecEraseList; // 제거 성공한 아이템
    kRecv.m_vecNormalItem; // 판매 성공한 일반 아이템.
    kRecv.m_vecCountItem; // 판매 성공한 수량 아이템. ( 수량이 0이면 제거하고, 수량잉 있으면 덮어 쓰시오.)


    std::wstring strResult;
    std::wstring strItemResult;



    if( kRecv.m_nOK == 0 ) {
        if( !kRecv.m_vecEraseList.empty() ) {
            g_pItemMgr->m_kInventory.RemoveItemList( kRecv.m_vecEraseList );
        }

        if( !kRecv.m_vecNormalItem.empty() ) {
            g_pItemMgr->m_kInventory.RemoveItemList( kRecv.m_vecNormalItem );
        }

        if( !kRecv.m_vecCountItem.empty() ) {
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecCountItem );
        }

        // 이제 아이템의 변경 사항은 다 적용이 되었음.
        // Reward에 있는 아이템의 변경사항을 체크할 차례.
        // 이유는 젬을 다 판매하고, 동시에 캐시 아이템을 팔면
        // 원래 젬이 100개이고, 얻은게 3개이면 -97개로 표시될 수 있으므로..
        int iGPAcquisition = kRecv.m_nGamePoint -  g_kGlobalValue.m_kUserInfo.GetCurrentChar().GetCurrentGP();
        int iGEMAcquisition = 0;
        int iCristalAcquisition = 0;

        if(!kRecv.m_vecRewardItem.empty())
        {
            std::vector<KItem>::iterator vIter = kRecv.m_vecRewardItem.begin();
            for(;vIter !=  kRecv.m_vecRewardItem.end();vIter++)
            {
                if(vIter->m_ItemID/10 == GEM_ITEM_ID)
                {
                    iGEMAcquisition = vIter->m_nCount - g_pItemMgr->GetInventoryItemDuration(GEM_ITEM_ID);
                }
                else if(vIter->m_ItemID/10 == CRYSTAL_ITEM_ID)
                {
                    iCristalAcquisition = vIter->m_nCount - g_pItemMgr->GetInventoryItemDuration(CRYSTAL_ITEM_ID);
                }
            }
        }

        if ( !kRecv.m_vecRewardItem.empty() ) {
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewardItem, true );
        }

        g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGamePoint );
        g_MyD3D->MyPlayer[ g_MyD3D->Get_MyPlayer() ]->m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGamePoint );
        g_kGlobalValue.m_kUserMission.RefreshUserMission();
        g_kGlobalValue.m_kUserCollectionMission.RefreshUserCollectionMission();
        g_pItemMgr->ClearSellItemList();
        g_pItemMgr->m_kInventory.UpdatePremiumInfo();

        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
        g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();
        //		std::wstring strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE1, "l", kItem->strItemName );
        
#if defined(NATION_CHINA)
		strResult = g_pkStrLoader->GetReplacedString(STR_ID_SELL_BUNDLE_ITEM_SUCCESS,"ii",iGPAcquisition,iGEMAcquisition);
#else
		strResult = g_pkStrLoader->GetReplacedString(STR_ID_SELL_BUNDLE_ITEM_SUCCESS,"iii",iGPAcquisition,iGEMAcquisition,iCristalAcquisition);
#endif

        //  룸안이면
        if ( g_MyD3D->m_pStateMachine->IsStateRoom() ) 
        {
            g_pkUIScene->m_pkRoomSceneS6->UpdateMissionData();
        }

    }
    else
    {
        strResult = g_pkStrLoader->GetString( STR_ID_SELL_BUNDLE_ITEM_FAIL_ALL );
    }
    int iLine = 0;


    if(!kRecv.m_mapFailInfo.empty()){	
        std::map<GCITEMUID,int>::iterator mIter = kRecv.m_mapFailInfo.begin();
        for(;mIter != kRecv.m_mapFailInfo.end();mIter++)
        {
            if (strItemResult.size() >= strItemResult.max_size()-2)
                break;

            std::wstring strTmp;
            iLine++;

            switch(mIter->second)
            {
            case 1:
                strTmp = g_pkStrLoader->GetReplacedString(STR_ID_SELL_BUNDLE_ITEM_FAIL1,"l",g_pItemMgr->GetItemNameUID(mIter->first));
                break;
            case 2:
                strTmp = g_pkStrLoader->GetReplacedString(STR_ID_SELL_BUNDLE_ITEM_FAIL2,"l",g_pItemMgr->GetItemNameUID(mIter->first));
                break;
            case 3:
                strTmp = g_pkStrLoader->GetReplacedString(STR_ID_SELL_BUNDLE_ITEM_FAIL4,"l",g_pItemMgr->GetItemNameUID(mIter->first));
                break;
            case 4:
                strTmp = g_pkStrLoader->GetReplacedString(STR_ID_SELL_BUNDLE_ITEM_FAIL5,"l",g_pItemMgr->GetItemNameUID(mIter->first));
                break;
            case 5:
                strTmp = g_pkStrLoader->GetReplacedString(STR_ID_SELL_BUNDLE_ITEM_FAIL6,"l",g_pItemMgr->GetItemNameUID(mIter->first));
                break;
            case 6:
                strTmp = g_pkStrLoader->GetReplacedString(STR_ID_SELL_BUNDLE_ITEM_FAIL7,"l",g_pItemMgr->GetItemNameUID(mIter->first));
                break;
            case 7:
            case 8:
            case 9:
            case 12:
            case 13:
            case 14:
            case 15:
            case 16:
                strTmp = g_pkStrLoader->GetReplacedString(STR_ID_SELL_BUNDLE_ITEM_FAIL3,"l",g_pItemMgr->GetItemNameUID(mIter->first));
                break;
            case 17:
                strTmp = g_pkStrLoader->GetReplacedString(STR_ID_SELL_BUNDLE_ITEM_FAIL8,"l",g_pItemMgr->GetItemNameUID(mIter->first));
                break;
            default:
                iLine--;
                continue;
            }

            if (strItemResult.max_size() -4 <= strItemResult.size() + strTmp.size() )
            {
                strItemResult += L"...";
                strItemResult += L"\n";
                break;
            }

            strItemResult += strTmp;
            strItemResult += L"\n";
        }
    }
    //DWORD x =0;

    //KLuaManager luaMgr;
    //GCFUNC::LoadLuaScript( luaMgr, "Dev.lua" );
    //LUA_GET_VALUE_DEF( "x", x, 0 );
    if (!g_kGlobalValue.isUndoCoordi) {
        if (Result_Drop != INT_MAX)
            g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, strResult, strItemResult,
                KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0);
    }

    Result_Drop = kRecv.m_nOK;
    //	STR_ID_SELL_BUNDLE_ITEM_SUCCESS			= 6473, //@1 GP / @2 Gem / @3 크리스탈을 획득하였습니다.
    //	STR_ID_SELL_BUNDLE_ITEM_FAIL1			= 6474, //@1 아이템은 이미 판매된 아이템입니다.
    //	STR_ID_SELL_BUNDLE_ITEM_FAIL2			= 6475, //@1 아이템은 인벤토리에 없는 아이템 입니다.
    //	STR_ID_SELL_BUNDLE_ITEM_FAIL3			= 6476, //@1 아이템의 인벤토리 정보를 읽어 오지 못했습니다.
    //	STR_ID_SELL_BUNDLE_ITEM_FAIL4			= 6477, //@1 아이템은 PC방 아이템입니다.
    //	STR_ID_SELL_BUNDLE_ITEM_FAIL5			= 6478, //@1 아이템은 수량으로 판매할 수 없습니다.
    //	STR_ID_SELL_BUNDLE_ITEM_FAIL6			= 6479, //@1 아이템은 잘못된 수량 값이 입력되었습니다.
    //	STR_ID_SELL_BUNDLE_ITEM_FAIL7			= 6480, //@1 아이템의 기간 입력이 잘못되었습니다.
    //	STR_ID_SELL_BUNDLE_ITEM_FAIL8			= 6481, //@1 아이템은 출석 포인트 아이템입니다.
    //	STR_ID_SELL_BUNDLE_ITEM_FAIL_ALL		= 6482, //아이템 판매를 실패하였습니다.

    // 1  판매 아이템이 중복이 있습니다. )
    // 2  Item이 존재 하지 않음. )
    // 3  PC방 아이템을 팔려고 했음. )
    // 4  수량 아이템이 아닌데 수량 판매 시도 )
    // 5  음수 수량을 판매 하려고 함. )
    // 6  보유 수량 보다 많은 수를 판매하려고 함. )
    // 7  영구 아이템이 아닌데 영구 아이템처럼 팔려고 함. )
    // 8  요청 패킷이 비어 있음. )
    // 9  처리 과정에서 전체가 오류 발생. )
    // 12 유저 캐싱 데이터 동기화 실패. )
    // 13 수량 아이템 DB 동기화 실패. )
    // 14 아이템 삭제 DB 처리 실패. )
    // 15 수량 아이템 판매 DB 처리 실패. )
    // 16 일반 아이템 판매 DB 처리 실패. )
    // 17 판매 하려는 아이템이 출석 포인트 아이템입니다. )
    // -98 처리중 //5322



}

void On_EVENT_BUY_FOR_GAMBLE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BUY_FOR_GAMBLE_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK; // 겜블구매 결과.
    // kRecv.m_nUseGP; // 겜블구매흐, 현재 보유GP
    // kRecv.m_vecItems; // 획득한 아이템	
    switch( kRecv.m_nOK )
    {
    case 0: // 성공.
        g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nUseGP );
        g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nUseGP );
        g_MyD3D->MyPlayer[ g_MyD3D->Get_MyPlayer() ]->m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nUseGP );
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItems, true );
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();		
        g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
        g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();
        g_pkUIScene->m_pkGambleBox->InsertGambledItem( kRecv.m_vecItems );
        //g_pkUIScene->m_pkGambleBox->OnUpdate();
        //std::copy(kRecv.m_vecItems.begin(),kRecv.m_vecItems.end(),  g_pkUIScene->m_pkGambleBox->m_vecGot.end() );

        
        //g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
        //	g_pkStrLoader->GetString( STR_ID_BUY_ITEM_SUCCEEDED1 ),
        //	g_pkStrLoader->GetString( STR_ID_BUY_ITEM_SUCCEEDED2 ),
        //	KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0,
        //	true, true );			
        break;
    case 1: // GP부족
        break;
    case 2: // 필수데이터 동기화 실패.
        break;
    case 3: // GP아이템이 아니다.
        break;
    case 4: // DB아이템 넣기 작업 실패.
        break;
    case -98: // 아직 처리중인 작업입니다.
        break;
    default: // 알수 없는 오류
        break;
    }
    Result_Buy = kRecv.m_nOK;

}

void On_EVENT_COST_RATE_FOR_GAMBLE_BUY_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( float );
    SAFE_DELETE( pkBuff );
    // kRecv : 겜블비용 비율 (1.f = 100%, 겜블구매비용 = GP구매비용 * kRecv )

    g_pkUIScene->m_pkGambleBox->m_fCostRate = kRecv;

}

void On_EVENT_TR_SERVER_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( PAIR_DWORD_USHORT );
    SAFE_DELETE( pkBuff );

    kRecv.first; // TR Server IP
    kRecv.second; // TR Server Port

    in_addr in;
    in.S_un.S_addr = kRecv.first;
    SiKP2P()->DisConnectTCPRelay();
    
    if( !SiKP2P()->m_spTRUserProxy->Connect( inet_ntoa(in), kRecv.second, g_kGlobalValue.ServerInfo.dwUserUID ) )
    {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_TCP_CONNECT_FAIL), L"" );
        SiGCClientErrorManager()->ErrorCollect( KEventErr::ERR_NETWORK, KNetWorkErr::CE_TCP_CONNECT_ERROR );        
    }

    SiKP2P()->m_spTRUserProxy->SetPingTimeoutLimit( GetRelayPingLimit() );
    SiKP2P()->m_spTRUserProxy->SetPingSendGap( GetRelayPingInterval() );
}

void On_EVENT_HERO_DUNGEON_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_HERO_DUNGEON_INFO_NOT );
    SAFE_DELETE( pkBuff );
    // 게임서버 접속시 전달됨.
    // kRecv.m_PointItemID;      // 영웅포인트ItemID
    // kRecv.m_vecDungeonInfo;   // 영웅던전 정보
    // kRecv.m_tmResetTime;      // 입장 초기화 시간

    g_kGlobalValue.m_kHeroDungeonInfo.SetHeroDungeonInfo( kRecv.m_vecDungeonInfo, kRecv.m_PointItemID, kRecv.m_tmResetTime );
}

void On_EVENT_USER_HERO_DUNGEON_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_USER_HERO_DUNGEON_INFO_ACK );
    SAFE_DELETE( pkBuff );
    // 게임서버 접속시 전달됨.
    // map< ModeID, 플레이데이터>
    // kRecv : std::map< int, KHeroPlayData >

    g_kGlobalValue.m_kHeroDungeonInfo.SetHeroPlayData( kRecv );
}

void On_EVENT_HERO_ITEM_CATALOG_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_HERO_ITEM_CATALOG_ACK );
    SAFE_DELETE( pkBuff );
    // 영웅 아이템 리스트
    // kRecv : std::map<GCITEMID,KManufactureItem>

    g_kGlobalValue.m_kHeroDungeonInfo.SetHeroItemCatalog( kRecv );
    Result_HeroItemList = 0;
}

void On_EVENT_HERO_ITEM_MATERIAL_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_HERO_ITEM_MATERIAL_ACK );
    SAFE_DELETE( pkBuff );
    // 영웅아이템 구매조건
    // map<영웅아이템ItemID, vector<구매조건> >
    // kRecv : std::map<GCITEMID,std::vector<KDropItemInfo> >

    g_kGlobalValue.m_kHeroDungeonInfo.SetHeroItemMaterial( kRecv );
    Result_HeroItemList = 0;
}

void On_EVENT_BUY_FOR_HERO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BUY_FOR_HERO_ACK );
    SAFE_DELETE( pkBuff );
    // 영웅아이템 구매결과
    // kRecv.m_nOK; // 구매 결과
    // kRecv.m_nGP; // 현재GP량(사용안함)
    // kRecv.m_vecRewards; // 획득 아이템
    // kRecv.m_vecCountMaterialItems; // 소모된 수량 아이템
    // kRecv.m_vecPeriodMaterialItems; // 소모된 영구 아이템
    switch( kRecv.m_nOK )
    {
    case 0: // 성공.
        {
            // 소모된 수량 아이템 
            std::vector<KItem>  vecZeroCount;
            for( std::vector<KItem>::iterator it = kRecv.m_vecCountMaterialItems.begin() ; it != kRecv.m_vecCountMaterialItems.end() ; ++it )
            {
                DWORD ItemID = static_cast<DWORD>(it->m_ItemID/10);
                g_pItemMgr->m_kInventory.FindItemByItemID( ItemID )->m_nCount = it->m_nCount;

                if( g_pItemMgr->m_kInventory.FindItemByItemID( ItemID )->m_nCount <= 0 )
                    vecZeroCount.push_back( *(g_pItemMgr->m_kInventory.FindItemByItemID( ItemID )) );

            }

            // 소모된 영구 아이템
            std::vector<KItem> vecMaterailItem;
            for( std::vector<GCITEMUID>::iterator it = kRecv.m_vecPeriodMaterialItems.begin() ; it != kRecv.m_vecPeriodMaterialItems.end() ; ++it )
            {
                vecMaterailItem.push_back( *(g_pItemMgr->m_kInventory.FindItemByItemUID( *it )) );
            }

            // 인벤토리에서 삭제 
            g_pItemMgr->m_kInventory.RemoveItemList( vecZeroCount );
            g_pItemMgr->m_kInventory.RemoveItemList( vecMaterailItem );
        }

        // 아이템 추가 
        for( std::vector<KItem>::iterator it = kRecv.m_vecRewards.begin() ; it != kRecv.m_vecRewards.end() ; ++it )
        {
            g_pItemMgr->m_kInventory.AddItem( *it, true);
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_BUY_POINT_ITEM_SUCCESS, "l", g_pItemMgr->GetItemName(static_cast<DWORD>(it->m_ItemID/10)) ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        }

        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        break;

    case 1: // 구매재료 아이템 정보가 없음
    case 2: // 인벤토리에 구매재료 아이템이 없음.
    case 3: // 인벤토리에 구매재료 영구아이템이 없음.
    case 4: // 인벤토리에 구매재료 수량아이템의 수량이 부족함.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_HERO_ITEM_BUY_ERROR4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;

    case 5: // DB작업 실패.
    case 6: // DB작업중 룩 아이템 변환 실패.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_DICE_ERROR_06 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;

    case 7: // 코디아이템 구매시 충분한 인벤 공간이 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_HERO_ITEM_BUY_ERROR6 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;
    
    case 8: // 일반 아이템 구매시 충분한 인벤 공간이 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_HERO_ITEM_BUY_ERROR3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;

    case -98: // 아직 처리중인 작업입니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PACKET_DELAY ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;

    default: // 알수없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true, true);
        }
        break;
    }

    Result_BuyForHero = kRecv.m_nOK;
}

void On_EVENT_BILLBOARD_REGISTRATION_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_BILLBOARD_REGISTRATION_ACK);
    SAFE_DELETE(pkBuff);

    if (kRecv.m_nOK == 0)
    {
        std::wstringstream ss;
        ss << g_pkStrLoader->GetString(STR_ID_BILLBOARD_CHAT_WAIT_LIST) << kRecv.m_nWaitingMessages;

        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK,
            g_pkStrLoader->GetString(STR_ID_BILLBOARD_CHAT_TEXT),
            ss.str(), KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

        KItem* item = g_pItemMgr->GetInventoryItemFromID(ITEM_BILLBOARD);
        if (item->m_nCount > 0)
            item->m_nCount--;
    }

}

void On_EVENT_BILLBOARD_CHAT_MSG_NOT(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_BILLBOARD_CHAT_MSG_NOT);
    SAFE_DELETE(pkBuff);

    SiKGCBillboardChatManager()->PushMessage(kRecv.m_wstrNickName, kRecv.m_wstrMessage, kRecv.m_dwColor);
}

void On_EVENT_HERO_DUNGEON_ALARM_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_HERO_DUNGEON_ALARM_NOT );
    SAFE_DELETE( pkBuff );
    // 영웅던전 오픈 알림
    // enum ALARM_TYPE {
    //     AT_ALARM_OPEN  = 0, // 오픈전 알림
    //     AT_ALARM_CLOSE = 1, // 클로즈전 알림
    // };
    // kRecv.m_usAlarmType;  // 알람 타입 (enum ALARM_TYPE값 사용)
    // kRecv.m_nModeID;      // 영웅던전 ModeID
    // kRecv.m_nMin;         // 출력할 시간 분
    // kRecv.m_prOpenTime;   // pair<오픈시간~종료시간>    
    
    // 현재 영웅던전이면서 게임 중이라면 알림메시지는 띄우지 않는다.
    if( SiKGCWorldMapManager()->IsHeroDungeonMode() && g_MyD3D->m_pStateMachine->GetState() == GS_GAME )
        return;

    // 정시가 됐을 때는 전관팡을 띄운다.
    if( kRecv.m_nMin == 0 )
    {
        CTime startTime(kRecv.m_prOpenTime.first+ g_kGlobalValue.m_tmServerSyncTime);
        CTime endTime(kRecv.m_prOpenTime.second+ g_kGlobalValue.m_tmServerSyncTime);
        KSignBoardData kData;
        kData.m_eType = KSignBoardData::SBT_SQUARE_ADMIN;
        kData.m_dwSenderUID = 0;
        kData.m_strSenderNick.clear();
        kData.m_ItemID = 0;
        kData.m_dwColor = 0;
        std::wstringstream strStratTimeHour;
        std::wstringstream strStratTimeMinute;
        std::wstringstream strEndTimeHour;
        std::wstringstream strEndTimeMinute;

        if(startTime.GetHour()<10)
            strStratTimeHour<<L"0";
        if(startTime.GetMinute()<10)
            strStratTimeMinute<<L"0";

        strStratTimeHour<<startTime.GetHour()<<L"\0";
        strStratTimeMinute<<startTime.GetMinute()<<L"\0";

        if(endTime.GetHour()<10)
            strEndTimeHour<<L"0";
        if(endTime.GetMinute()<10)
            strEndTimeMinute<<L"0";

        strEndTimeHour<<endTime.GetHour()<<L"\0";
        strEndTimeMinute<<endTime.GetMinute()<<L"\0";


        kData.m_strMsg = g_pkStrLoader->GetReplacedString( STR_ID_HERO_DUNGEON_ALRAM_OPEN_TIME, "ssss",
            strStratTimeHour.str().c_str(), strStratTimeMinute.str().c_str(), strEndTimeHour.str().c_str(), strEndTimeMinute.str().c_str());

    }
    else
    {
        if( kRecv.m_usAlarmType == KEVENT_HERO_DUNGEON_ALARM_NOT::AT_ALARM_OPEN )
        {
            g_pkChatManager->AddChatMsgTo( g_MyD3D->m_pStateMachine->GetState(), g_pkStrLoader->GetReplacedString( STR_ID_HERO_DUNGEON_ALRAM_BEFORE_OPEN, "i", kRecv.m_nMin ), KGCChatManager::CHAT_TYPE_ADMIN, false, L"", 0xffff00 );
        }
        else
        {
            g_pkChatManager->AddChatMsgTo( g_MyD3D->m_pStateMachine->GetState(), g_pkStrLoader->GetReplacedString( STR_ID_HERO_DUNGEON_ALRAM_BEFORE_CLOSE, "i", kRecv.m_nMin ), KGCChatManager::CHAT_TYPE_ADMIN, false, L"", 0xffff00 );
        }
    }
}

void On_EVENT_CHANNELING_REWARD_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHANNELING_REWARD_NOT );
    SAFE_DELETE( pkBuff );

    // 채널링 이벤트 아이템 갱신.
    if(!kRecv.empty())
    {
        g_pItemMgr->m_kInventory.AddItemList( kRecv , true );

        std::vector<KItem>::iterator vIter = kRecv.begin();
        for(;vIter !=  kRecv.end() ;vIter++)
        {
            std::wstring str = g_pkStrLoader->GetString( STR_ID_REPETITION_MESSAGE2 ) + L"\n";                                                        //축하합니다. 이벤트에 당첨되셨습니다.
            str += g_pkStrLoader->GetReplacedString( STR_ID_REPETITION_MESSAGE3, "l", g_pItemMgr->GetItemName( vIter->m_ItemID / 10 ) ); //'#cFFFF00@1#cX'
            if( vIter->m_nCount > 1 )
            {          
                str += g_pkStrLoader->GetReplacedString( STR_ID_REPETITION_MESSAGE6, "i", vIter->m_nCount );
            }                     //아이템 @1개를 지급 받으셨습니다. 지금 바로 장비창에 가서 확인해 보세요!
            else
            {           
                str += g_pkStrLoader->GetString( STR_ID_REPETITION_MESSAGE5 );  
            }                      //아이템을 지급 받으셨습니다. 지금 바로 장비창에 가서 확인해 보세요!

            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_REPETITION_EVENT_BOX,
                str,
                g_pkStrLoader->GetString( STR_ID_REPETITION_MESSAGE1 ),
                KGCUIScene::GC_MBOX_USE_NORMAL, vIter->m_ItemID, vIter->m_ItemUID );
        }
    }

    g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    g_pkUIScene->m_pkMyInfoScene->UpdateData();
}

void On_EVENT_CHAR_PROMOTION_UPDATE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHAR_PROMOTION_UPDATE_ACK );
    SAFE_DELETE( pkBuff );
    // 전직 마법서 아이템 사용에 대한 결과값.
    /*
    m_nOK = 0 : 성공
    m_nOK = 1 : 전직 마법서 아이템 가져오기 실패. )
    m_nOK = 2 : 해당 전직 변경 불가 아이템. )
    m_nOK = 3 : 캐릭터 미션정보가 없음. )
    m_nOK = 4 : 캐릭터 전직변경 DB 처리실패. )
    m_nOK = 5 :캐릭터 정보 가져오기 실패.
    m_nOK = 6 :해당 전직으로 변경 불가. )
    m_nOK = 7 :등록되지 않은 미션. )
    m_nOK = 8 :유저가 존재하지 않음. )
    m_nOK = 9 :미션이 등록되어 있지 않음.
    m_nOK = 10 : 전직 수행레벨이 되지 않음.
    */

    switch( kRecv.m_nOK )
    {
    case 0:
        {
            SMissionReward sReward;
            for(int i = 0; i < (int)g_kGlobalValue.m_kUserInfo.vecCharInfo.size(); i++ )
            {
                SCharInfo &Info = g_kGlobalValue.m_kUserInfo.vecCharInfo[i];
                if( kRecv.m_cCharType == Info.iCharType )
                {
                    // 전직 처리                    
                    Info.iPromotionLevel = kRecv.m_cPromotionLevel;

                    // Jaeho 2008.01.10
                    // 전직레벨 정보를 변경시켜 주지 않으면 미션 보상받은 아이템을 바로 껴보지 못함.
                    if( Info.iCharType == g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar().iCharType )
                    {
                        if( g_MyD3D->m_pStateMachine->IsStateRoom() || g_MyD3D->m_pStateMachine->IsStateMyInfo() )
                        {
                            g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar().iPromotionLevel = Info.iPromotionLevel;
                        }
                    }

                    // 보상아이템처리
                    for( int i = 0 ; i < (int)kRecv.m_vecRewards.size() ; ++i )
                    {
                        sReward.m_vecItem.push_back( std::vector< std::pair< DWORD, int > >::value_type( kRecv.m_vecRewards[i].m_ItemID / 10, kRecv.m_vecRewards[i].m_nPeriod ) );
                    }
                    g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewards, true );
                    sReward.m_iNewChar = kRecv.m_cCharType;
                    sReward.m_iNewJob = (int)kRecv.m_cPromotionLevel;                    

                    // 전직마법서 수량 깍기 작업
                    std::vector<KItem>::iterator veciter = kRecv.m_vecCountItem.begin();
                    for(; veciter != kRecv.m_vecCountItem.end(); ++veciter)
                    {
                        KItem* pkItem = g_pItemMgr->m_kInventory.FindItemByItemUID( veciter->m_ItemUID );
                        if( pkItem == NULL )
                        {   continue;   }

                        g_pItemMgr->DecreaseDuration( pkItem->m_ItemUID, false );
                        if( pkItem->m_nCount <= 0 )
                        {   g_pItemMgr->m_kInventory.RemoveItem(pkItem->m_ItemUID);   }
                    }
                    g_pkUIScene->m_pkMyInfoScene->UpdateData();
                    g_pkUIScene->m_pkMyInfoScene->UpdateGameData();


                    // 미션리스트에 전직미션이 있다면 제거하자
                    g_kGlobalValue.m_kUserMission.DeleteMission( kRecv.m_dwMissionID );
                    g_pkUIScene->m_pkMissionUI_S4->RefreshUI();
                    g_kGlobalValue.m_kUserMission.RefreshUserMission();
                    Info.kSkillInfo = kRecv.m_kSkillInfo;

                    //  룸안이면
                    if ( g_MyD3D->m_pStateMachine->IsStateRoom() ) 
                    {
                        g_pkUIScene->m_pkRoomSceneS6->UpdateMissionData();
                    }

                    // UI 출력
                    if( false == g_pkUIScene->m_pkCharGetInfoDlg->IsCreate() )
                    {    g_pkUIScene->m_pkCharGetInfoDlg->Create(); }
                    g_pkUIScene->m_pkCharGetInfoDlg->SetReward( sReward );
                    g_pkUIScene->m_pkCharGetInfoDlg->SetInfo( false, kRecv.m_cCharType, kRecv.m_cPromotionLevel );
                    g_pkUIScene->m_pkCharGetInfoDlg->SetShow( true );
                    g_pkUIScene->m_pkCharGetInfoDlg->SetMagic( true );
                    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GET_NEW_CHARACTER );

                    return;
                }
            }
        }
        break;
    case 1:        //전직 마법서 아이템 가져오기 실패
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_ERROR_CHAR_PROMOTION_UPDATE, "i", 1001 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;
    case 2:        //해당 전직 변경 불가 아이템
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_ERROR_CHAR_PROMOTION_UPDATE, "i", 1002 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;
    case 3:        //캐릭터 미션정보가 없음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_ERROR_CHAR_PROMOTION_UPDATE, "i", 1003 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;
    case 4:        //캐릭터 전직변경 DB 처리실패
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_ERROR_CHAR_PROMOTION_UPDATE, "i", 1004 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;
    case 5:        //캐릭터 정보 가져오기 실패
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_ERROR_CHAR_PROMOTION_UPDATE, "i", 1005 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;
    case 6:        //해당 전직으로 변경 불가
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_ERROR_CHAR_PROMOTION_UPDATE, "i", 1006 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;
    case 7:        //등록되지 않은 미션
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_ERROR_CHAR_PROMOTION_UPDATE, "i", 1007 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;
    case 8:        //유저가 존재하지 않음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_ERROR_CHAR_PROMOTION_UPDATE, "i", 1008 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;
    case 9:        //미션이 등록되어 있지 않음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_ERROR_CHAR_PROMOTION_UPDATE, "i", 1009 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;
    case 10:        //전직 수행레벨이 되지 않음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_ERROR_CHAR_PROMOTION_UPDATE, "i", 1010 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true, true);
        }
        break;
    }
}

void On_EVENT_ITEM_CHARPROMOTION_LEVEL_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ITEM_CHARPROMOTION_LEVEL_NOT );
    SAFE_DELETE( pkBuff );

    g_kGlobalValue.m_mapItemCharpromotionLevel.clear();

    g_kGlobalValue.m_mapItemCharpromotionLevel = kRecv;


}

void On_EVENT_HERO_DUNGEON_RESET_NOT( WPARAM wParam, LPARAM lParam )
{
    // 영웅던전 플레이 데이터 초기화 알림.(데이터 없음)

    // 클리어 횟수를 초기화 한다.
    g_kGlobalValue.m_kHeroDungeonInfo.ReSetHeroPlayData();

    // 영웅던전 정보창이 띄워져 있다면 업데이트 해준다.
}

void On_EVENT_SPECIAL_REWARD_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KRewardInfoList );
    SAFE_DELETE( pkBuff );
    // 던전 결과창 선택한 보물상자 결과 전달
    // kRecv;
    // std::vector<KRewardInfo>    KRewardInfoList; // 룸 전체유저 스페셜드랍 보상정보

    // 세부 보상 정보
    // KRewardInfo
    // m_dwUID;            // UserUID
    // m_cCharType;        // 캐릭터 타입
    // m_setSelectIndex;   // 선택한 보상 번호
    // m_nRewardGP;        // 실제 획득 GP
    // m_nCurrentGP;       // 총 보유 GP
    // m_vecRewardItem;    // 실제 획득 보상아이템
    // m_vecItemList;      // 상자 아이템 정보(정렬은 서버에서). vector<보상정보>
    g_pkGameOverlayUI->GetQuestResultS3()->GetBonusBoxSelect()->SetEachUserBoxInfo( kRecv );
}

void On_EVENT_GAWIBAWIBO_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GAWIBAWIBO_INFO_ACK );
    SAFE_DELETE( pkBuff );
    //STR_ID_GAWIBAWIBO_ERR_1					= 8132, //	@1 : 오류가 발생 하였습니다.
    //	STR_ID_GAWIBAWIBO_ERR_2 				= 8133,	//가위바위보 도전 혹은 재도전 포인트가 부족합니다.
    //	STR_ID_GAWIBAWIBO_ERR_3					= 8134,	//가위바위보 스크립트에 없는 스테이지 보스입니다.
    //	STR_ID_GAWIBAWIBO_ERR_4					= 8135,	//가위바위보 정보 DB 기록을 실패 하였습니다.
    //	STR_ID_GAWIBAWIBO_ERR_5					= 8136,//	가위바위보 아이템 DB 넣기를 실패 하였습니다.
    //	STR_ID_GAWIBAWIBO_ERR_6					= 8137,//가위바위보 포인트 아이템이 인벤토리에 없습니다.
    //	STR_ID_GAWIBAWIBO_ERR_7					= 8138,	//가위바위보 포인트 아이템 교환정보가 없습니다.
    //	STR_ID_GAWIBAWIBO_ERR_8					= 8139,	//가위바위보 재도전을 할 수 없는 상태입니다.
    //  STR_ID_GAWIBAWIBO_ERR_10					= 8125,	//이벤트 기간이 아닙니다.

    if(kRecv.m_nOK == 0)
    {
        //if(kRecv.m_kUserGawibawiboInfo.m_usVersion != g_pkUIScene->)
        //	;

        g_pkUIScene->m_pkGawibawiboGame->SetGawibawiboGameInfo(kRecv);

		g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GAWIBAWIBO_DLG,L"",L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,false);
	}
	else if(kRecv.m_nOK == 1) // 이벤트 기간이 아님.
	{
		g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GAWIBAWIBO_ERR_10 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

    }
    Result_GawibawiboGameInfo = kRecv.m_nOK;
}

void On_EVENT_GAWIBAWIBO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GAWIBAWIBO_ACK );
    SAFE_DELETE( pkBuff );


	if(kRecv.m_nOK == 0)
	{
        if ( g_pkUIScene->m_pkGawibawiboGame )
        {
            g_pkUIScene->m_pkGawibawiboGame->GetGamePlay()->SetRollTimeDeg( true );
            g_pkUIScene->m_pkGawibawiboGame->ResultGawiBawiBoGame(kRecv);
        }
	}
	else
	{
		switch(kRecv.m_nOK)
		{
		case 1:	//이벤트 기간이 아님
            if ( g_pkUIScene->m_pkGawibawiboGame )
                g_pkUIScene->m_pkGawibawiboGame->Close();
			g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GAWIBAWIBO_ERR_10 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
			break;
		case 2: // 도전 혹은 재도전 포인트 부족
			g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GAWIBAWIBO_ERR_2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
			break;
		case 3: // 스크립트에 없는 스테이지 보스
			g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GAWIBAWIBO_ERR_3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
			break;
		case 4: // 정보 DB 기록 실패
			g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GAWIBAWIBO_ERR_4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
			break;
		case 5: // 아이템 DB에 넣기 실패
			g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GAWIBAWIBO_ERR_5 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
			break;
		default:// 알 수 없는 오류
            {
                std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_GAWIBAWIBO_ERR_1, "i", kRecv.m_nOK ), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
            }
            break;
        }

        g_pkUIScene->m_pkGawibawiboGame->SpeakToActionListener( KActionEvent( g_pkUIScene->m_pkGawibawiboGame, KD3DWnd::EWNDMESSAGE_CLOSE));
    }
}

void On_EVENT_GAWIBAWIBO_GIVE_UP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GAWIBAWIBO_GIVE_UP_ACK );
    SAFE_DELETE( pkBuff );


    if(kRecv.m_nOK == 0)
    {
        KEVENT_GAWIBAWIBO_INFO_ACK kRevType;
        kRevType.m_dwPointTimeGap = 0;
        kRevType.m_dwRetryMark = 0;
        kRevType.m_nOK = kRecv.m_nOK;
        kRevType.m_kUserGawibawiboInfo = kRecv.m_kUserGawibawiboInfo;
        kRevType.m_dwPointTimeGap = 0;

        g_pkUIScene->m_pkGawibawiboGame->SetGawibawiboGameInfo(kRevType);
    }
    else if(kRecv.m_nOK == 2)
    {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GAWIBAWIBO_ERR_2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

    }
    else if(kRecv.m_nOK == 8)
    {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GAWIBAWIBO_ERR_8 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

    }
    else
    {
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_GAWIBAWIBO_ERR_1, "i", kRecv.m_nOK ), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
    }

    Result_GawibawiboGameGiveUp = kRecv.m_nOK;
}

void On_EVENT_GAWIBAWIBO_TRYPOINT_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( DWORD );
    SAFE_DELETE( pkBuff );

    g_pkUIScene->m_pkGawibawiboGame->SetGawibawiboTryPointInfo(kRecv);
}

void On_EVENT_GAWIBAWIBO_ITEM_TRADE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GAWIBAWIBO_ITEM_TRADE_ACK );
    SAFE_DELETE( pkBuff );

    if(kRecv.m_nOK == 0)
    {
        // 포인트로 변환시 상황 처리 해주어야 함. 
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecUseItem, true );
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_TRADE_COIN ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

    }
    else{
        switch(kRecv.m_nOK)
        {
        case 1: //이벤트 기간이 아님
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GAWIBAWIBO_ERR_2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
            break;
        case 6: //포인트 아이템이 인벤토리에 없음.
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GAWIBAWIBO_ERR_6 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
            break;
        case 7: //포인트 아이템 교환정보 없음.
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GAWIBAWIBO_ERR_7 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
            break;
        default://에러번호 : 알 수 없는 오류입니다.
            {
                std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_GAWIBAWIBO_ERR_1, "i", kRecv.m_nOK ), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
            }
            break;
        }
    }

}

void On_EVENT_NONE_INVEN_ITEM_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_NONE_INVEN_ITEM_LIST_NOT );
    SAFE_DELETE( pkBuff );
    // kPacket_ 
    // std::set<DWORD>         m_setNonInvenSizeItem;  // 인벤토리 차지 않하는 ItemList.
    // std::set<DWORD>         m_setHideInvenItem;     // 인벤토리 보이지 않는 ItemList.

    g_pItemMgr->Server_SetNonCountItem( kRecv.m_setNonInvenSizeItem );
    g_pItemMgr->Server_SetNonVisibleItem( kRecv.m_setHideInvenItem );
}

void On_EVENT_INIT_ITEM_ATTRIBUTE_LIST( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( MAP_DWORD_SET );
    SAFE_DELETE( pkBuff );
    // kPacket_ : std::map< DWORD, std::set<DWORD> >
    // 속성 초기화 아이템 리스트.
    g_pItemMgr->SetRandomInitAttributeItemList(kRecv);

}

void On_EVENT_INIT_ITEM_ATTRIBUTE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_INIT_ITEM_ATTRIBUTE_ACK );
    SAFE_DELETE( pkBuff );
    // kPacket_ 
    // int m_nOK; 
    // m_nOK = 1  : 속성을 초기화 할 아이템이 인벤에 없음.
    // m_nOK = 2  : 속성 초기화할 아이템이 에픽 등급 이상이 아님.
    // m_nOK = 3  : 속성 초기화할 아이템이 코디아이템임.
    // m_nOK = 4  : 속성초기화 DB에 기록 하는데 오류 발생.

    // KItem m_kItem; // 서버에서 사용
        
    if(kRecv.m_nOK == 0){
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem, true );
        g_pItemMgr->m_kInventory.AddItem(kRecv.m_kItem, true);
        
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_INIT_ATTRIBUTE_SUC1,"l",
            g_pItemMgr->GetItemName(kRecv.m_kItem.m_ItemID/10) ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false);
    }
    else if(kRecv.m_nOK == 1){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_INIT_ATTRIBUTE_ERR1 ), L"", 
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false);

    }
    else if(kRecv.m_nOK == 2){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_INIT_ATTRIBUTE_ERR2 ), L"", 
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false);

    }
    else if(kRecv.m_nOK == 3){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_INIT_ATTRIBUTE_ERR3 ), L"", 
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false);
    }
    else if(kRecv.m_nOK == 4){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_INIT_ATTRIBUTE_ERR4 ), L"", 
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false);
    }
    else if(kRecv.m_nOK == 5){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_INIT_ATTRIBUTE_ERR7 ), L"", 
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false);
    }
    else{
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_INIT_ATTRIBUTE_ERR5,"i",
            kRecv.m_nOK ), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false);
    }
    Result_Random_Init_attribute = kRecv.m_nOK;

}


void On_EVENT_INIT_ITEM_GP_ATTRIBUTE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_INIT_ITEM_GP_ATTRIBUTE_ACK );
    SAFE_DELETE( pkBuff );
    // kPacket_ 
    // int m_nOK; 
    // m_nOK = 1  : 속성을 초기화 할 아이템이 인벤에 없음.
    // m_nOK = 2  : 속성 초기화할 아이템이 에픽 등급 이상이 아님.
    // m_nOK = 3  : 속성 초기화할 아이템이 코디아이템임.
    // m_nOK = 4  : 속성초기화 DB에 기록 하는데 오류 발생.

    // KItem m_kItem; // 서버에서 사용

    if(kRecv.m_nOK == 0){
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem, true );
        g_pItemMgr->m_kInventory.AddItem(kRecv.m_kItem, true);

        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();

        KEVENT_ATTRIBUTE_LIST_ACK attList;
        attList.m_nOK = kRecv.m_nOK;
        attList.m_ItemID = kRecv.m_kItem.m_ItemID;
        attList.m_nSelectCount = kRecv.m_nSelectCount;
        attList.m_vecAttributeList = kRecv.m_vecAttributeList;
        attList.m_setRandomAttributeIndex = kRecv.m_setRandomAttributeIndex;
        g_pkUIScene->m_pkAttributeSelectBox->SetAttributeInfoSelect( attList );

        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_INIT_ATTRIBUTE_SUC1,"l",
            g_pItemMgr->GetItemName(kRecv.m_kItem.m_ItemID/10) ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        
    }
    else if(kRecv.m_nOK == 1){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_INIT_ATTRIBUTE_ERR1 ), L"", 
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false);

    }
    else if(kRecv.m_nOK == 2){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_INIT_ATTRIBUTE_ERR2 ), L"", 
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false);

    }
    else if(kRecv.m_nOK == 3){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_INIT_ATTRIBUTE_ERR3 ), L"", 
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false);
    }
    else if(kRecv.m_nOK == 4){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_INIT_ATTRIBUTE_ERR4 ), L"", 
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false);
    }
    else if(kRecv.m_nOK == 5){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_INIT_ATTRIBUTE_ERR7 ), L"", 
            KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false);
    }
    else{
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_INIT_ATTRIBUTE_ERR5,"i",
            kRecv.m_nOK ), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false);
    }
    Result_Random_Init_attribute = kRecv.m_nOK;
}


void On_EVENT_DUNGEON_REWARD_ITEM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DUNGEON_REWARD_ITEM_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK : 결과값
    // kRecv.m_dwRecvUserUID : 아이템 획득한 UserUID
    // KRecv.m_vecDropItem : 드랍 아이템 std::vector<KItem>
    // KRecv.m_mapUserDice : 룰렛아이템일 경우, UserUID별 주사위값. std::map<DWORD,int>
    switch ( kRecv.m_nOK )
    {
    case 0: // 성공.
        {
            if ( g_pStateGame ) 
                g_pStateGame->DungeonRewardItem( kRecv.m_dwRecvUserUID, kRecv.m_vecDropItem, kRecv.m_vecPartyDropItem, kRecv.m_mapUserDice );
        }
        break;
    case 1: // 방 정보가 없음.
        break;
    case 2: // 드랍할 아이템이 없음.
        break;
    case 3: // DB지급 실패.
        break;
    case -98: // 아직 처리중인 작업.
        break;
    default: // 알 수 없는 오류.
        break;
    }
}

void On_EVENT_DUNGEON_REWARD_EXP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DUNGEON_REWARD_EXP_ACK );
    SAFE_DELETE( pkBuff );
    // KEVENT_DUNGEON_REWARD_EXP_ACK : std::map< DWORD, KCharExpReward >
    // kRecv : 유저별 경험치 획득 결과. [UserUID, ExpInfo]

    if ( g_pStateGame ) 
        g_pStateGame->DungeonRewardExp( kRecv );
}

void On_EVENT_PVP_REWARD_EXP_GP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_PVP_REWARD_EXP_GP_ACK );
    SAFE_DELETE( pkBuff );
    // KEVENT_PVP_REWARD_EXP_GP_ACK : std::map< DWORD, KCharExpReward >
    // kRecv : 유저별 경험치 획득 결과. [UserUID, ExpInfo]

    KEVENT_PVP_REWARD_EXP_GP_ACK::iterator mit;
    for ( int i = 0; i < MAX_DUNGEON_PLAYER_NUM; ++i )
    {
        PLAYER* pPlayer = g_MyD3D->MyPlayer[i];
        mit = kRecv.find( pPlayer->m_kUserInfo.dwUID );
        if ( mit != kRecv.end() )
        {
            if ( pPlayer->IsLocalPlayer() )
            {
                // 해당 캐릭터에게 경험치 ㄱㄱ
                SCharInfo* pCharInfo = &pPlayer->m_kUserInfo.GetCurrentChar( mit->second.m_cCharType );
                pCharInfo->biExp = mit->second.m_biExp;
                pCharInfo->iLevel = static_cast<int>(mit->second.m_dwLevel);
                pCharInfo->kSkillInfo = mit->second.m_kSkillInfo;
            }

            // 레벨업 이펙트!
            if (static_cast<int>(static_cast<int>(mit->second.m_dwLevel) - static_cast<int>(mit->second.m_dwOldLevel)) > 0 )
            {
                pPlayer->AddDamage( DT_LEVELUP_EFF, 0 );
                g_kGlobalValue.m_kUserMission.AddVirtualMissionToLevelUp();
                g_pkUIScene->m_pkGameOverlayUI->InitMinimap();
                std::wstring& strLevelUpMessage = g_pkStrLoader->GetReplacedString( 8210, "l", pPlayer->m_kUserInfo.strNickName );
                g_pkChatManager->AddChatMsgTo( GS_GAME, strLevelUpMessage, KGCChatManager::CHAT_TYPE_NORMAL );
            }
        }
    }
}

void On_EVENT_PVP_TAG_REWARD_EXP_GP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_PVP_TAG_REWARD_EXP_GP_ACK );
    SAFE_DELETE( pkBuff );
    // KEVENT_PVP_TAG_REWARD_EXP_GP_ACK : std::map< DWORD, KCharExpReward >
    // kRecv : 유저별 경험치 획득 결과. [UserUID, ExpInfo]

    KEVENT_PVP_TAG_REWARD_EXP_GP_ACK::iterator mit;
    for ( int i = 0; i < MAX_DUNGEON_PLAYER_NUM; ++i )
    {
        PLAYER* pPlayer = g_MyD3D->MyPlayer[i];
        mit = kRecv.find( pPlayer->m_kUserInfo.dwUID );
        if ( mit != kRecv.end() )
        {
            if ( pPlayer->IsLocalPlayer() )
            {
                // 해당 캐릭터에게 경험치 ㄱㄱ
                SCharInfo* pCharInfo = &pPlayer->m_kUserInfo.GetCurrentChar( mit->second.m_cCharType );
                pCharInfo->biExp = mit->second.m_biExp;
                pCharInfo->iLevel = static_cast<int>(mit->second.m_dwLevel);
                pCharInfo->kSkillInfo = mit->second.m_kSkillInfo;
            }

            // 레벨업 이펙트!
            if (static_cast<int>(static_cast<int>(mit->second.m_dwLevel) - static_cast<int>(mit->second.m_dwOldLevel)) > 0 )
            {
                pPlayer->AddDamage( DT_LEVELUP_EFF, 0 );
                g_kGlobalValue.m_kUserMission.AddVirtualMissionToLevelUp();
                g_pkUIScene->m_pkGameOverlayUI->InitMinimap();
                std::wstring& strLevelUpMessage = g_pkStrLoader->GetReplacedString( 8210, "l", L"#c" + pPlayer->m_kUserInfo.strNickColor + pPlayer->m_kUserInfo.strNickName + L"#cX");
                g_pkChatManager->AddChatMsgTo( GS_GAME, strLevelUpMessage, KGCChatManager::CHAT_TYPE_NORMAL );
            }
        }
    }
}

void On_EVENT_SOCKS_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KUserSocksInfo );
    SAFE_DELETE( pkBuff );

    g_pkUIScene->m_pkSocksTreeDlg->OnEventSocksInfoNot( kRecv );
}

void On_EVENT_SOCKS_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KUserSocksInfo );
    SAFE_DELETE( pkBuff );

    Result_SockTreeReq  = 0;
    g_pkUIScene->m_pkSocksTreeDlg->OnEventSocksInfoNot( kRecv );
}

void On_EVENT_SOCKS_HANGUP_ACK( WPARAM wParam, LPARAM lParam ) 
{
    // 0     // 정상 
    // 1     // 양말 이벤트 기간이 아님.
    // 2     // 양말 아이템이 없는데 걸기 요청함. )
    // 3     // 이미 걸려있는 양말 아이템을 걸기 요청함.

    KSerializer ks;
    ACK_DESERIALIZE( KSocksResult );
    SAFE_DELETE( pkBuff );

    g_pkUIScene->m_pkSocksTreeDlg->SetPushHangUpBtn(false);

    switch( kRecv.m_nOK )
    {
    case 0:
        g_pkUIScene->m_pkSocksTreeDlg->OnEventSocksHangUpAck( kRecv );
        break;
    case 1:
    case 2:
    case 3:
        //	아무것도 처리 하지 않음
        break;

    default:
        //::MessageBoxA( NULL, __FUNCTION__, "default case0", MB_OK );
        break;
    }

}

void On_EVENT_SOCKS_COLLECT_ACK( WPARAM wParam, LPARAM lParam )
{
    // 0    정상
    // 2  // 양말 아이템이 없는데 걸기 요청함.
    // 5  // 안걸려있는 양말 아이템을 받기 요청함.
    // 6  // 남은 시간이 0 이 아닌 양말을 받기 요청함.

    KSerializer ks;
    ACK_DESERIALIZE( KSocksResult );
    SAFE_DELETE( pkBuff );

    g_pkUIScene->m_pkSocksTreeDlg->SetPushDetachBtn(false);

    switch( kRecv.m_nOK )
    {
    case 0:	//	성공했으니 데이터를 덮어쓴다.
    case 2:	//	이하는 실패했지만, 서버로부터 올바른 정보를 덮어쓴다.
    case 5:
    case 6:
        g_pkUIScene->m_pkSocksTreeDlg->OnEventSocksCollectAck( kRecv );
        break;

    default:
        //	이하는 무시한다.
        break;
    }
}

void On_EVENT_SOCKS_MATERIAL_EXCHANGE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSocksExchangeData );
    SAFE_DELETE( pkBuff );
    
    //g_pkUIScene->m_pkSocksTreeDlg->OnEventSocksMaterialExchangeNot( kRecv );
}

void On_EVENT_SOCKS_HANGUP_COMPLETE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSocksResult );
    SAFE_DELETE( pkBuff );
    
    switch( kRecv.m_nOK )
    {
    case 0:
        g_pkUIScene->m_pkSocksTreeDlg->OnEventSocksHangupCompleteNot( kRecv );
        break;

    default:
        //::MessageBoxA( NULL, __FUNCTION__, "default case0", MB_OK );
        break;
    }
}

void On_EVENT_SOCKS_MATERIAL_EXCHANGE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSocksExchangeData );
    SAFE_DELETE( pkBuff );

    Result_CheckEnoughSocksMaterial = kRecv.m_nOK;
    g_pkUIScene->m_pkSocksTreeDlg->OnEventSocksMaterialExchangeACK( kRecv );
}

void On_EVENT_UNLOCK_CHANGE_WEAPON_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_UNLOCK_CHANGE_WEAPON_ACK );
    SAFE_DELETE( pkBuff );


    // kRecv.m_nOK;          // 무기체인지 언락 성공여부
    // kRecv.m_cCharType;    // 언락 대상 캐릭터 타입
    // kRecv.m_vecItem;      // 언락에 사용된 수량 아이템 정보.
    std::wstring strMsg;
    switch ( kRecv.m_nOK )
    {
    case 0: // 교체무기 언락 성공
        {
            std::map<char,std::pair<bool,GCITEMUID> >::iterator mit = g_kGlobalValue.m_mapChangeWeapon.find(kRecv.m_cCharType);
            if ( mit != g_kGlobalValue.m_mapChangeWeapon.end() )
            {
                (*mit).second.first = true;
            }
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem, true );
            g_pkUIScene->m_pkMyInfoScene->SetEquipWndCategory(UEC_EQUIP1);
            strMsg = g_pkStrLoader->GetString( STR_ID_WC_STRING1 );
        }
        break;
    case 1: // 교체무기 언락할 캐릭터를 보유하지 않음.
        strMsg = g_pkStrLoader->GetString( STR_ID_WC_STRING2 );
        break;
    case 2: // 교체무기 캐릭터 레벨 제한에 걸림.
        strMsg = g_pkStrLoader->GetString( STR_ID_WC_STRING3 );
        break;
    case 3: // 교체무기 언락 아이템 수량 부족.
        strMsg = g_pkStrLoader->GetString( STR_ID_WC_STRING4 );
        break;
    case 4: // 무기교체 언락할 캐릭터 슬롯이 이미 열려있음.
        break;
    default:
        break;
    }

    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, L"", KGCUIScene::GC_MBOX_USE_NORMAL );
}

void On_EVENT_USER_STAGE_LOAD_COMPLETE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_USER_STAGE_LOAD_COMPLETE_NOT );
    SAFE_DELETE( pkBuff );
    // kPacket_( DWORD ) : 스테이지 전이 완료된 UserUID


    g_pkGameOverlayUI->CheckStageLoadComplete(kRecv);    
}

void On_EVENT_GP_ATTRIBUTE_INIT_ITEM_LIST( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( MAP_DWORD_SET );
    SAFE_DELETE( pkBuff );
    // kPacket_ : std::map< DWORD, std::set<DWORD> >
    // GP 속성 초기화 아이템 리스트.
    g_pItemMgr->SetGPAttributeInitItemList( kRecv );
}

void On_EVENT_GP_ATTRIBUTE_RANDOM_ITEM_LIST( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( MAP_DWORD_SET );
    SAFE_DELETE( pkBuff );
    // kPacket_ : std::map< DWORD, std::set<DWORD> >
    // GP 속성 랜덤 아이템 리스트.
    g_pItemMgr->SetGPAttributeRandomItemList( kRecv );
}

void On_EVENT_ITEM_ATTRIBUTE_RANDOM_SELECT_LIST( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( MAP_DWORD_SET );
    SAFE_DELETE( pkBuff );
    // kPacket_ : std::map< DWORD, std::set<DWORD> >
    // 랜덤 속성 아이템 리스트.
    g_pItemMgr->SetRandomInitAttributeItemList(kRecv);

}

void On_EVENT_ITEM_ATTRIBUTE_RANDOM_SELECT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ITEM_ATTRIBUTE_RANDOM_SELECT_ACK );
    SAFE_DELETE( pkBuff );
    // kPacket_ 
    // int m_nOK; 
    // m_nOK = 0  : 성공.
    // m_nOK = 1  : 랜덤 속성을 적용할 아이템이 인벤에 없음.
    // m_nOK = 2  : 랜덤 속성 적용할 아이템이 에픽 등급 이상이 아님.
    // m_nOK = 3  : 랜덤 속성 적용할 아이템이 코디아이템임.
    // m_nOK = 4  : 랜덤 속성 DB에 기록 하는데 오류 발생.
    // m_nOK = 5  : 랜덤 속성을 할수 있는 아이템이 아님.

    // KItem m_kItem; // 서버에서 사용
    if(kRecv.m_nOK == 0){
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem, true );
        g_pItemMgr->m_kInventory.AddItem(kRecv.m_kItem, true);

        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();

        g_pkUIScene->m_pkAttributeSelectBox->SetAttributeInfoRandom(kRecv.m_kItem.m_ItemUID, false, false);

    }
    else if(kRecv.m_nOK == 1){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RANDOM_ATTRIBUTE_11 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

    }
    else if(kRecv.m_nOK == 2){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RANDOM_ATTRIBUTE_12 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

    }
    else if(kRecv.m_nOK == 3){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RANDOM_ATTRIBUTE_13 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

    }
    else if(kRecv.m_nOK == 4){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RANDOM_ATTRIBUTE_14 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

    }
    else if(kRecv.m_nOK == 5){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RANDOM_ATTRIBUTE_15 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

    }
    else{
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_INIT_ATTRIBUTE_ERR5
            ,"i",kRecv.m_nOK ), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

    }
    Result_Random_Init_attribute = kRecv.m_nOK;

}

void On_EVENT_GP_ATTRIBUTE_RANDOM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GP_ATTRIBUTE_RANDOM_ACK );
    SAFE_DELETE( pkBuff );
    // kPacket_ 
    // int m_nOK; 
    // m_nOK = 0  : 성공.
    // m_nOK = 1  : 랜덤 속성을 적용할 아이템이 인벤에 없음.
    // m_nOK = 2  : 랜덤 속성 적용할 아이템이 에픽 등급 이상이 아님.
    // m_nOK = 3  : 랜덤 속성 적용할 아이템이 코디아이템임.
    // m_nOK = 4  : 랜덤 속성 DB에 기록 하는데 오류 발생.
    // m_nOK = 5  : 랜덤 속성을 할수 있는 아이템이 아님.

    // KItem m_kItem; // 서버에서 사용
    if(kRecv.m_nOK == 0){
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem, true );
        g_pItemMgr->m_kInventory.AddItem(kRecv.m_kItem, true);

        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();

        g_pkUIScene->m_pkAttributeSelectBox->SetAttributeInfoRandom(kRecv.m_kItem.m_ItemUID, false, false );

    }
    else if(kRecv.m_nOK == 1){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RANDOM_ATTRIBUTE_11 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

    }
    else if(kRecv.m_nOK == 2){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RANDOM_ATTRIBUTE_12 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

    }
    else if(kRecv.m_nOK == 3){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RANDOM_ATTRIBUTE_13 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

    }
    else if(kRecv.m_nOK == 4){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RANDOM_ATTRIBUTE_14 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

    }
    else if(kRecv.m_nOK == 5){
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RANDOM_ATTRIBUTE_15 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

    }
    else{
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_INIT_ATTRIBUTE_ERR5
            ,"i",kRecv.m_nOK ), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

    }
    //Result_Random_Init_attribute = kRecv.m_nOK;

}

void On_EVENT_GAWIBAWIBO_TRY_POINT_NOT( WPARAM wParam, LPARAM lParam )
{
    // 가위바위보 재시도 포인트 받음 알림.
    KGCHotEventBtn::SetHotStateOn();
}

void On_EVENT_USER_SERVER_ROOM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_USER_SERVER_ROOM_ACK );
    SAFE_DELETE( pkBuff );
    /*
    kRecv.m_nOK;                            // 결과
    kRecv.m_kServerRoomInfo.m_dwUserUID;    // 대상 유저UID
    kRecv.m_kServerRoomInfo.m_dwServerUID;  // 대상이 있는 서버UID
    kRecv.m_kServerRoomInfo.m_dwChannelUID; // 대상이 있는 채널UID
    kRecv.m_kServerRoomInfo.m_usRoomID;     // 대상이 있는 룸ID

    STR_ID_FOLLOW_FRIEND_1 = 8407,//	요청 주기가 너무 짧습니다. 잠시 후 다시 시도해주세요.
    STR_ID_FOLLOW_FRIEND_2 = 8408,//	대상이 채널에 없습니다.
    STR_ID_FOLLOW_FRIEND_3 = 8409,//	대상이 방에 없습니다.
    STR_ID_FOLLOW_FRIEND_4 = 8410,//	대상 유저를 찾을 수 없습니다.
    STR_ID_FOLLOW_FRIEND_5 = 8411,//	대상이 서버에 없습니다.
    STR_ID_FOLLOW_FRIEND_6 = 8412,//	@1 : 알수없는오류
    STR_ID_FOLLOW_FRIEND_7 = 8413,//	따라가기
    STR_ID_FOLLOW_FRIEND_8 = 8414,//	3초 딜레이 

    */
    
    switch(kRecv.m_nOK)
    {
    case 0: // 성공
        {
            // 성공해도 다른 서버에 있는 유저의 방으로는 이동을 막는다. 
            if( kRecv.m_kServerRoomInfo.m_dwServerUID != g_kGlobalValue.GetCurrentServerUID() ) { 
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_FOLLOW_OTHER_SERCER ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
                break;
            }

            g_pkUIScene->m_pkGuildSquareNotice->Close();			
            if( g_MyD3D->m_pStateMachine->GetState() == GS_SQUARE )
            {
                g_pkUIScene->CloseInSquareUI();
                g_pkSquareOverlayUI->ExitSquare();
                g_pkUIScene->m_pkGuildSquareNotice->Destroy();
            }
            g_pkUIScene->m_pkNateOn->OnClose();
            if( g_MyD3D->m_pStateMachine->GetState() == GS_SQUARE )
            {
                g_pkSquareOverlayUI->ExitSquare();
                g_pkUIScene->m_pkGuildSquareNotice->Destroy();
            }

            if ( SiKGCWorldMapManager()->IsPrivateDungeon( static_cast<EGCGameMode>(kRecv.m_kServerRoomInfo.m_iGameMode) ) )
            {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NOT_MOVE_PRIVATE_DUNGEON ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
                break;
            }

            if ( SiKGCWorldMapManager()->IsInfinityDungeon( static_cast<EGCGameMode>(kRecv.m_kServerRoomInfo.m_iGameMode) ) )
            {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NOT_MOVE_INFINITY_DUNGEON ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
                break;;
            }

            if ( SiKGCWorldMapManager()->IsInfinityDungeon( static_cast<EGCGameMode>(kRecv.m_kServerRoomInfo.m_iGameMode) ) )
            {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NOT_MOVE_INFINITY_DUNGEON ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
                break;;
            }
                
            if( false == g_pkUIScene->m_pkServerScene->MoveServer(kRecv.m_kServerRoomInfo.m_dwServerUID)){
                break;
            }
            if( false == SiKGCChannelManager()->MoveChannel(kRecv.m_kServerRoomInfo.m_dwChannelUID)){
                break;
            }
    #if defined (PARTY_SYSTEM)
            if ( false == SiKGCRoomManager()->MoveRoom(kRecv.m_kServerRoomInfo.m_usRoomID, kRecv.m_kServerRoomInfo.m_bPublic , SiKGCPartyManager()->GetRoomPass() ) ) 
                break;
    #else
            if( false == SiKGCRoomManager()->MoveRoom(kRecv.m_kServerRoomInfo.m_usRoomID, kRecv.m_kServerRoomInfo.m_bPublic)){
                break;
            }
    #endif
        }
        break;
    case 1: // 요청 주기가 짧습니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_FOLLOW_FRIEND_1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 2: // 대상이 채널에 없습니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_FOLLOW_FRIEND_2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 3: // 대상이 방에 없습니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_FOLLOW_FRIEND_3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 4: // 대상 유저를 찾을 수 없습니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_FOLLOW_FRIEND_4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 5: // 대상이 서버에 없습니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_FOLLOW_FRIEND_5 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    default: // 알수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_FOLLOW_FRIEND_6
                ,"i",kRecv.m_nOK ), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        }
        break;
    }
    g_pkUIScene->m_pkNateOn->OffViewWaitImage();

}

void On_EVENT_TODAYS_POPUP_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );
    // 닉네임 변경 캠페인 팝업창 켤지 여부 알림.
    // kRecv : 0 이면 팝업창 켜기. 그외 팝업창 끄기.

#ifndef NICKNAME_CAMPAIGN
    return;
#endif

    if ( kRecv == 0 ) {
        //팝업창 켜기
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_NICKNAME_CAMPAIGN_BOX );
    }
}

void On_EVENT_INIT_TODAYS_POPUP_NOT( WPARAM wParam, LPARAM lParam )
{
    // 자정, 일일 팝업창 켜기 초기화 알림.
#ifndef NICKNAME_CAMPAIGN
    return;
#endif
}

void On_EVENT_RESET_SKILL_ACK( WPARAM wParam, LPARAM lParam )
{
    // 스킬전체초기화 요청 응답.
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RESET_SKILL_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK : 결과값
    // 0 : 성공
    // 1 : 스킬전체초기화 아이템이 아님.
    // 2 : 스킬전체초기화 아이템 수량이 부족함.
    // 3 : 보유하지 않은 캐릭터를 스킬전체 초기화하려고 함.
    // kRecv.m_cCharType : 스킬초기화 캐릭터타입
    // kRecv.m_kItem : 스킬초기화아이템 정보

    switch(kRecv.m_nOK)
    {   
    case 0:// 0 : 성공
        {
            // 스킬 업데이트
            int iCharType = g_MyD3D->m_TempPlayer.m_kUserInfo.vecCharInfo[g_MyD3D->m_TempPlayer.m_kUserInfo.cCharIndex].iCharType;
            for(int iLoop=-1; iLoop<4; ++iLoop)
            {
                
                SiGCSKT()->_D_UnAllTrainSkill( (EGCCharType)iCharType, iLoop );
                SiGCSKT()->_D_UnAllEquip_Skill( (EGCCharType)iCharType, iLoop, SiGCSKT()->GetSetting( iCharType, iLoop ) );
            }

            // 남은 스킬들 정보 받아 다시 갱신해 줍니다. 
            SiGCSKT()->Server_SetTrainedSkill( kRecv.m_mapTrainedSkill );
            g_pkUIScene->m_pkSkillTree->ThreadSafeUpdate();

            SiGCSKT()->ApplySettingToServer();

            // 아이템 수량 감소
            KItem* pkItem = g_pItemMgr->m_kInventory.FindItemByItemID( KGCItemManager::ITEM_RESET_SKILL );
            if( pkItem )
            {
                g_pItemMgr->DecreaseDuration( pkItem->m_ItemUID, false );
                if( pkItem->m_nCount <= 0 )
                {
                    g_pItemMgr->m_kInventory.RemoveItem(pkItem->m_ItemUID);
                }
                g_pkUIScene->m_pkMyInfoScene->UpdateData();
            }
        }
        break;
    case 1:// 1 : 스킬전체초기화 아이템이 아님.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RESETSKILL_ERROR_01 ), L"");
        break;
    case 2:// 2 : 스킬전체초기화 아이템 수량이 부족함.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RESETSKILL_ERROR_02 ), L"");
        break;
    case 3:// 3 : 보유하지 않은 캐릭터를 스킬전체 초기화하려고 함.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RESETSKILL_ERROR_03 ), L"");
        break;
    }

}

void On_EVENT_FASHION_CATALOG_ACK( WPARAM wParam, LPARAM lParam )
{
    // 패션 카탈로그 전달
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_FASHION_CATALOG_ACK );
    SAFE_DELETE( pkBuff );
    // map[ Index, pair[CharacterType, SetItemID] ]
    // kRecv : std::map< int, std::pair<int,GCITEMID> >
}

void On_EVENT_USER_RECOM_TYPE_ACK( WPARAM wParam, LPARAM lParam )
{
    // 반갑다친구야 유저타입 전달
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );
    // kRecv : UserType
    // 1 ; 신규유저
    // 2 ; 복귀유저
    // 4 ; 활성유저

#if defined( WELCOMEBACK_FRIEND_NEW )
    g_pkUIScene->m_pkWelcomeBackNewDlg->UpdateMyState( kRecv );
#else
    g_pkUIScene->m_pkWelcomeBackDlg->UpdateMyState( kRecv );
#endif
}
void On_EVENT_PLANT_TREE_MAP_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_PLANT_TREE_MAP_NOT );
    SAFE_DELETE( pkBuff );
    // kPacket_( std::map< DWORD, KPlantTreeInfo > ) : 나무나무 이벤트 정보.
    // typedef std::map< DWORD, KPlantTreeInfo > KEVENT_PLANT_TREE_MAP_NOT; // 대륙ID, 대륙의 정보.
    //DWORD                   m_dwContinentType; // 대륙 Type
    //DWORD                   m_dwTotalTreeCount; // 전체 나무 갯수.
    //DWORD                   m_dwWaterCount; // 열매 물주기까지의 Count
    //std::map< DWORD, std::vector< KDropItemInfo > > m_mapRewardList; // 보상 리스트.

    if (g_pkUIScene->m_pkPlantTree)
        g_pkUIScene->m_pkPlantTree->SetPlantTreeRewardInfo(kRecv);
    if (g_pkUIScene->m_pkPlantTreeRewardItemListView)
        g_pkUIScene->m_pkPlantTreeRewardItemListView->SetRewardSetting(kRecv);

}

void On_EVENT_PLANT_TREE_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_PLANT_TREE_INFO_ACK );
    SAFE_DELETE( pkBuff );
/*
    ok값
    0 : 성공
    1 : DB에서 초기 데이터 이미 가져왔음.
    2 : 나무나무 이벤트 기간이 아님.
  -98 : 아직 처리중인 작업입니다.
*/
    // 여기서 ok값 0, 1 둘다 성공이다.

    switch(kRecv.m_nOK)
    {
    case 0:
    case 1:
        g_pkUIScene->m_pkPlantTree->SetPlantTreeInfo(kRecv.m_dwContinentType,kRecv.m_dwCurrentPosition,kRecv.m_dwTreeStatus );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_01 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);

        break;
    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_17 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true);
        }
        break;
    }
    Result_PlantTreeInfo = kRecv.m_nOK;
}

void On_EVENT_PLANT_TREE_ACTION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_PLANT_TREE_ACTION_ACK );
    SAFE_DELETE( pkBuff );
    /*
    ok값
    0 : 성공
    1 : 나무나무 이벤트 기간이 아님.
    2 : 해당 아이템 인벤토리에 없음.
    3 : 나무를 심을수 없는 상태.
    4 : 잘못된 ItemID.
    5 : 잘못된 대륙 타입.
    6 : 물을 줄수 없는 상태.
    7 : 거름을 줄수 없는 상태.
    8 : 로터리에 등록되어 있지 않음.
    9 : 정의되지 않은 행동 Type.
    -98 : 아직 처리중인 작업입니다.
    */
    switch(kRecv.m_nOK)
    {
    case 0:
        g_pkUIScene->m_pkPlantTree->On_ActionAck(kRecv);
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_01 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_02 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_03 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_04 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_05 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_06 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_07 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 8:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_08 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 9:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_09 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true);
        }
        break;
    }
    Result_PlantTreeInfo = kRecv.m_nOK;

}

void On_EVENT_PLANT_TREE_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_PLANT_TREE_REWARD_ACK );
    SAFE_DELETE( pkBuff );
    /*
    ok값
    0 : 성공
    1 : 나무나무 이벤트 기간이 아님.
    2 : 보상을 받을수 있는 나무상태가 아님.
    3 : 보상정보 가져오기 실패.
    -98 : 아직 처리중인 작업입니다.
    */
    switch(kRecv.m_nOK)
    {
    case 0:
        g_pkUIScene->m_pkPlantTree->On_RewardAck(kRecv);
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_11 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_12 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_13 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_17 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true);
        }
        break;
    }
    Result_PlantTreeInfo = kRecv.m_nOK;

}

void On_EVENT_CHOICE_BOX_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHOICE_BOX_LIST_ACK );
    SAFE_DELETE( pkBuff );
    // 상자ItemID 리스트
    // kRecv : std::set<GCITEMID>
    if( g_pkUIScene->m_pkChoiceDrop != NULL )
        g_pkUIScene->m_pkChoiceDrop->ReceiveItemBoxList( kRecv );
}

void On_EVENT_CHOICE_BOX_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KChoiceBox );
    SAFE_DELETE( pkBuff );
    // 상자정보
    // kRecv.m_BoxItemID   : 상자ItemID
    // kRecv.m_usDropCount : 선택가능한 보상개수
    // kRecv.m_mapMaterial : 보상아이템 종류 [Index,ItemInfo]
    if( g_pkUIScene->m_pkChoiceDrop != NULL )
    {
        if ( kRecv.m_BoxItemID == g_pkUIScene->m_pkChoiceDrop->GetBoxID() * 10 )
        {
            g_pkUIScene->m_pkChoiceDrop->SetLimitSelCount( kRecv.m_usDropCount );
            
            for ( size_t i = 0 ; i < kRecv.m_mapMaterial.size() ; ++i) 
            {
                g_pkUIScene->m_pkChoiceDrop->AddItem( kRecv.m_mapMaterial[i] );
            }
        }
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_CHOICE_DROP );
    }
}

void On_EVENT_CHOICE_BOX_OPEN_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHOICE_BOX_OPEN_ACK );
    SAFE_DELETE( pkBuff );
    // 상자열기 보상
    // kRecv.m_nOK : 결과
    //      0 ; 성공
    //      1 ; 해당 박스 정보가 없다.          //5954	재료 아이템의 정보가 없습니다.
    //      2 ; 선택한 보상이 없다.             //선택한 보상이 없습니다.
    //      3 ; 선택한 보상개수가 전체 보상개수보다 많다.           //선택한 보상개수가 전체 보상개수보다 많습니다. 
    //      4 ; 선택한 보상개수가 박스의 보상가능 개수와 다르다.    //선택한 보상개수가 박스의 보상가능 개수와 다릅니다.
    //      5 ; 인벤토리에서 해당 박스를 찾을 수 없다.      //인벤토리에서 해당 박스를 찾을 수 없습니다.
    //      6 ; 선택한 보상이 보상 리스트에 없다.           //선택한 보상이 보상 리스트에 없습니다.
    //      7 ; 룩인벤토리가 부족함.            //코디 인벤토리 공간이 부족합니다.               
    //      8 ; 일반인벤토리가 부족함.          //6000	인벤토리의 공간이 부족합니다.
    //      9 ; 지급할 아이템 리스트가 없음.    //지급할 아이템 리스트가 없습니다.
    //      10; DB 아이템 지급 실패.            //4310	DB 처리 오류
    //     -98; 아직 처리중인 작업.             //8462	아직 처리중인 작업입니다.
    //
    // kRecv.m_kBoxItem : 상자ItmeID
    // kRecv.m_vecItem  : 받은 보상 아이템


    switch(kRecv.m_nOK)
    {
    case 0:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_CHOICE_DROP_RECEIVE_OK ) );
            g_pItemMgr->DecInventoryDurationItemForItemIdWithOutAck( kRecv.m_kBoxItem.m_ItemID/10 ); 
            //받은 아이템을 인벤토리에 넣어준다.
            std::vector<KItem>::iterator vit = kRecv.m_vecItem.begin();
            for ( ; vit != kRecv.m_vecItem.end(); ++vit )
            {
                g_pItemMgr->m_kInventory.AddItem( (*vit), true );
            }
            //인벤토리를 리프레시 한다.
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            g_pkUIScene->m_pkMyInfoScene->UpdateInventoryCapacity();
        }
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ITEM_CREATION_ERROR3 ) );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_CHOICE_DROP_ERROR2 ) );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_CHOICE_DROP_ERROR3 ) );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_CHOICE_DROP_ERROR4 ) );
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_CHOICE_DROP_ERROR5 ) );
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_CHOICE_DROP_ERROR6 ) );
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_CHOICE_DROP_ERROR7 ) );
        break;
    case 8:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_INVENTORY_FULL_ERROR1 ) );
        break;
    case 9:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_CHOICE_DROP_ERROR9 ) );
        break;
    case 10:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RECOMMEND_ERROR_MESSAGE4 ) );
        break;
    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_10 ) );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetReplacedString( STR_ID_FOLLOW_FRIEND_6,"i",kRecv.m_nOK ), strTemp );
        }
        break;
    }

}

void On_EVENT_USER_AUTH_CHECK_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_USER_AUTH_CHECK_ACK );
    SAFE_DELETE( pkBuff );

    // ok value
    // m_nOK : 0      // 성공
    // m_nOK :  1     // 남미 미국 유저 인증 체크 기간이 아님.
    // m_nOK :  2     // 대상 유저가 아님.
    // m_nOK :  3     // 이미 지급 받았음.
    // m_nOK :  -98   // 아직 처리중인 작업입니다.

    switch(kRecv.m_nOK)
    {
    case 0:
        g_kGlobalValue.m_dwVirtualCash = kRecv.m_kVirtualCashInfo.m_dwCashPoint;

        if( kRecv.m_kVirtualCashInfo.m_dwCashPoint != 0 )
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_USER_MIGRATION_MESSAGE, "i", kRecv.m_kVirtualCashInfo.m_dwCashPoint ), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        }
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewardItem , true);
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
        g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();

        OnItemReceive(kRecv.m_vecRewardItem, false, false );
        break;
    case 1:
        //처리 필요
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_USER_MIGRATION_ERROR01 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_FOLLOW_FRIEND_4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_DONATION_ITEM_GET_ERROR ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BINGO_ERROR7 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    default:
        break;
    }
}


void On_EVENT_GUILD_STORE_CATALOG_ACK( WPARAM wParam, LPARAM lParam )
{
    // 길드상점 아이템리스트 전달
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GUILD_STORE_CATALOG_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv
    // std::map< int, std::vector<KManufactureItem> >
    // map[ TabID, 아이템정보 ]
#if defined (GUILD_STORE_S4)
    if (g_pkUIScene->m_pkGuildShop != NULL)
        g_pkUIScene->m_pkGuildShop->SetItemList(kRecv);
    Result_ReqGuildStoreCatalog = 0;
#endif
    
}

void On_EVENT_BUY_FOR_GUILD_ACK( WPARAM wParam, LPARAM lParam )
{
    // 길드상점 아이템구매 결과
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BUY_FOR_GUILD_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK;       // 구매 결과
    // kRecv.m_nGP;       // 현재GP량
    // kRecv.m_vecRewards;// 획득 아이템
    
    std::wstring strMsg;
    std::wstring strTemp;

    int iStrID;

    switch( kRecv.m_nOK )
    {
    case 0: // 성공.
        for( std::vector<KItem>::iterator it = kRecv.m_vecRewards.begin() ; it != kRecv.m_vecRewards.end() ; ++it )
        {
            g_pItemMgr->m_kInventory.AddItem( *it, true);
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, (*it).m_ItemID/10, 0, false, true );
        }
        g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGP );
        g_MyD3D->MyPlayer[ g_MyD3D->Get_MyPlayer() ]->m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGP );
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        return;
    case 1: // 유저의 길드정보가 없음.
        iStrID = STR_ID_NEW_GUILD_MEMBER_CHAGNGE_ERROR03;
        break;
    case 2: // 구매 아이템 정보가 없음.
        iStrID = STR_ID_GUILD_NO_ITEMINFO;
        break;
    case 3: // GP가격이 설정되지 않음.
        iStrID = STR_ID_NOT_EXIST_PRICE_INFO;
        break;
    case 4: // GP가 부족함.
        iStrID = STR_ID_ITEM_CREATION_ERROR2;
        break;
    case 5: // 충분한 코디 인벤 공간이 없음
    case 6: // 충분한 인벤 공간이 없음.
        iStrID = STR_ID_INVENTORY_FULL_ERROR1;
        break;
    case 7: // 길드레벨조건이 안됨.
        iStrID = STR_ID_GUILD_NO_GUILDLEVELLIMIT;
        break;
    case 8: // 개인기여도가 부족함.
        iStrID = STR_ID_GUILD_LACK_CONTRIBUTE;
        break;
    case 9: // 일일구매제한.
        iStrID = STR_ID_GUILD_OVER_PURCHASELIMIT;
        break;
    case 10: // 없는 구매탭 정보
        iStrID = STR_ID_GUILD_NO_TABINFO;
        break;
    case 11: // DB처리 실패.
    case 12: // 룩아이템 변환 실패
        iStrID = STR_ID_DICE_ERROR_06;
        break;
    case -98:// 아직 처리중인 작업
        iStrID = STR_ID_PACKET_DELAY;
        break;
    default: // 알수없는 오류
        strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        iStrID = STR_ID_ENCHANT_RESULT9;
        break;
    }

    strMsg = g_pkStrLoader->GetString(iStrID);

    if( !strMsg.empty() )
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0 , false, true );

    Result_BuyForGuildItem = kRecv.m_nOK;
}

void On_EVENT_GUILD_LEVEL_TABLE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GUILD_LEVEL_TABLE_NOT );
    SAFE_DELETE( pkBuff );

    g_kGlobalValue.m_mapGuildLevelTable = kRecv;

}

void On_EVENT_GUILD_ROOM_INFO_CHANGE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KRoomInfo );
    SAFE_DELETE( pkBuff );

    SiKGCRoomManager()->GetRoomInfo().m_pairGuildMarkName = kRecv.m_pairGuildMarkName;
    SiKGCRoomManager()->GetRoomInfo().m_pairGuildName = kRecv.m_pairGuildName;
    SiKGCRoomManager()->GetRoomInfo().m_pairBattlePoint = kRecv.m_pairBattlePoint;

    SiKGCRoomManager()->UpdateRoomUI();
}

void On_EVENT_VIPEVENT_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_VIPEVENT_LIST_ACK );
    SAFE_DELETE( pkBuff );
    // Vip이벤트 정보. 가공해서 쓰세요.
    // kRecv.m_mapEventByVer;        // 버전별 이벤트정보 [Ver, 이벤트정보]
    // kRecv.m_mapPayTable;          // 구매금액 테이블 [금액ID, [min이상~max이하] ]
    // kRecv.m_mapRewardByVer;       // 버전별 보상ID [Ver, [금액ID,보상ID] ]
    // kRecv.m_mapNewbieRewardItem;  // 신규 보상그룹 [보상ID,아이템리스트]
    // kRecv.m_mapVipRewardItem;     // VIP 보상그룹 [보상ID,아이템리스트]

    g_pkUIScene->m_pkVipReward->SetVipEventList( kRecv );
}

void On_EVENT_VIPEVENT_USER_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_VIPEVENT_USER_INFO_ACK );
    SAFE_DELETE( pkBuff );
    // 버전별 VIP이벤트 유저 달성정보
    // kRecv.m_usVersion; // VIP이벤트 버전
    // kRecv.m_nPoint; // 사용한 캐쉬금액
    // kRecv.m_mapReward; // 획득한 보상 : key값 0은 신규, 1이상은 VIP구매급액ID.

    g_pkUIScene->m_pkVipReward->SetVipEventUserInfo( kRecv );
}

void On_EVENT_VIPEVENT_USER_REWARD_UPDATE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_VIPEVENT_USER_REWARD_UPDATE_NOT );
    SAFE_DELETE( pkBuff );
    // kRecv : VIP이벤트로 받은 보상아이템 리스트std::vector<KItem>

    g_pkUIScene->m_pkVipReward->SetVipEventUserRewardUpdate( kRecv );
}


void On_EVENT_MAGIC_BOX_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MAGIC_BOX_LIST_ACK );
    SAFE_DELETE( pkBuff );

    g_pkUIScene->m_pkMagicBox->SetSelectableList( kRecv.m_mapItemInfo );
}

void On_EVENT_SET_MAGIC_BOX_TARGET_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SET_MAGIC_BOX_TARGET_ACK );
    SAFE_DELETE( pkBuff );
    // 두근두근마법상자 잠금깎을 상자 설정 응답
    // kRecv.m_nOK : 결과값
    //     0 : 성공
    //     1 : 이벤트 기간이 아니다.
    //     2 : 해당 아이템이 아이템 리스트에 없다.
    //     3 : DB처리 실패
    //     -98 : 아직 처리중인 작업입니다
    // 
    // kRecv.m_ItemID : 설정된 아이템ItemID
}

void On_EVENT_USE_MAGIC_BOX_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_USE_MAGIC_BOX_ACK );
    SAFE_DELETE( pkBuff );
    // 두근두근마법상자 상자 잠금깎기 결과.
    // kRecv.m_nOK : 결과값
    //     0 : 성공
    //     1 : 이벤트 기간이 아니다.
    //     2 : 해당 아이템이 아이템 리스트 중에 없다.
    //     3 : DB처리 실패
    //     4 : 키 아이템이 아님
    //     5 : 키 아이템이 없음
    //     6 : 키 아이템 수량부족.
    //     7 : 키 아이템 DB 동기화 실패
    //     8 : 인벤토리가 가득 찼음.
    //     9 : 인벤토리 보유제한 초과
    //     -98 : 아직 처리중인 작업입니다
    // 
    // kRecv.m_TargetItemID; // 키가 사용된 아이템ID
    // kRecv.m_nLeftKeyCount; // 아이템 획득까지 남은 키 개수
    // kRecv.m_kKeyItem; // 사용한 키 아이템(수량)
    // kRecv.m_bClear; // 아이템 획득 여부
    // kRecv.m_nClearCount; // 아이템 획득 회수
    // kRecv.m_vecItem; // 획득한 아이템



    switch ( kRecv.m_nOK )
    {
    case 0://     0 : 성공
        g_pkUIScene->m_pkMagicBox->ResultEvent( kRecv );
        break;
    case 1://     1 : 이벤트 기간이 아니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_HAPPY_NEWYEAR_NOT_EVENT_TIME), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;

    case 2://     2 : 해당 아이템이 아이템 리스트 중에 없다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_ERROR_MAGICBOX1), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;

    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;

    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_ERROR_MAGICBOX2), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;

    case 5:
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_ERROR_MAGICBOX3), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;

    case 7:
        break;

    case 8:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_INVENTORY_FULL_ERROR1), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;

    case 9:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_BUY_AGIT_ITEM_FAIL8), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;

    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_PLANT_TREE_10), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;

    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ERROR_MAGICBOX4 ), strTemp,
                KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        }
        break;
    }       
}

void On_EVENT_MAX_CHAR_SP_LEVEL_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MAX_CHAR_SP_LEVEL_NOT );
    SAFE_DELETE( pkBuff );

    SiGCSKT()->SetSkillMaxSPInfo(kRecv);
}

void On_EVENT_ITEM_LEVEL_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ITEM_LEVEL_LIST_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK;          // 아이템 레벨 리스트 요청 ok값.
    // kRecv.m_ItemID;    // ItemID
    // kRecv.m_setItemLevelList;      // 해당 아이템의 레벨리스트.
    // 
    // ok Value
    // 0 : 성공
    // 1 : 레벨설정할 아이템이 인벤에 없음.
    // 2 : 요청한 아이템의 레벨 리스트 없음.
    switch( kRecv.m_nOK )
    {
    case 0:        
        break;
    case 1:
        break;
    case 2:
        break;
    }
}

void On_EVENT_ITEM_LEVEL_SELECT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ITEM_LEVEL_SELECT_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK;          // 아이템 레벨 선택 요청 ok값.
    // kRecv.m_kItem;        // 레벨선택된 아이템 정보.
    // ok Value
    // 0 : 성공
    // 1 : 레벨설정할 아이템이 인벤에 없음.
    // 2 : 레벨선택 가능한 아이템이 아님.
    // 3 : 선택한 레벨이 리스트에 없음.
    // 4 : 레벨을 DB에 기록하는데 오류 발생.

    switch( kRecv.m_nOK )
    {
    case 0:
        g_pItemMgr->m_kInventory.AddItem( kRecv.m_kItem, true );
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        break;
    case 1:
        break;
    case 2:
        break;
    case 3:
        break;
    case 4:
        break;
    }
}

void On_EVENT_PACKAGE_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_PACKAGE_INFO_ACK );
    SAFE_DELETE( pkBuff );

    g_pItemMgr->SetPackageIndexMax( kRecv.m_nMaxIndex );
    g_pItemMgr->SetPackageIndexCurrendIndex( kRecv.m_nStartIndex );

    g_pItemMgr->SetPackageInfo( true );
    Result_ReceivePackageInfo = 0;
}

void On_EVENT_PACKAGE_INFO_DETAIL_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_PACKAGE_INFO_DETAIL_ACK );
    SAFE_DELETE( pkBuff );


    if( kRecv.m_nMaxIndex > kRecv.m_nCurrentIndex )
    {
        g_pItemMgr->SetPackageInfo( kRecv.m_mapPackageInfo, false );

    }
    else if ( kRecv.m_nMaxIndex ==  kRecv.m_nCurrentIndex )
    {
        g_pItemMgr->SetPackageInfo( kRecv.m_mapPackageInfo, true );
    }

    Result_ReceivePackageDetailInfo = 0;

}


void On_EVENT_GET_GUILD_POINT_NOTICE( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GET_GUILD_POINT_NOTICE );
    SAFE_DELETE( pkBuff );

#if defined(GUILD_RENEW_S4)
    std::wstring strMsg;

    if(kRecv.m_nGetType == KEVENT_GET_GUILD_POINT_NOTICE::ATTEND)
    {
        strMsg = g_pkStrLoader->GetString(STR_ID_FORMAL_GUILD_ENTER_RECEIVE_POINT1);
    }
    else if(kRecv.m_nGetType == KEVENT_GET_GUILD_POINT_NOTICE::FIRST_CONNECT)
    {
        strMsg = g_pkStrLoader->GetString(STR_ID_FORMAL_GUILD_ENTER_RECEIVE_POINT2);

    }

    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
        g_pkStrLoader->GetReplacedString( STR_ID_FORMAL_GUILD_ENTER_RECEIVE_POINT3, "li", strMsg, kRecv.m_nGuildPoint  ),
        L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
#endif
}

void On_EVENT_ITEM_ATTRIBUTE_TABLE_ID_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );
    // kRecv : Item Attribute Table ID

    g_pkUIScene->m_pkAttributeSelectBox->SetAttributeTableID(-1, kRecv );
    Result_Random_Init_attribute = 0;
}

void On_EVENT_RKTORNADO_ITEM_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RKTORNADO_ITEM_LIST_NOT );
    SAFE_DELETE(pkBuff);

    if ( kRecv.m_bEventEnable )
        g_pkUIScene->m_pkRickoonTornado->SetInitInfo( kRecv.m_dwLuckyEnableCount, kRecv.m_mapNonFailRewardList, kRecv.m_dwExposeItemToUser );
    
    g_pkUIScene->m_pkRickoonTornado->SetEnableEvent( kRecv.m_bEventEnable);
}

void On_EVENT_RKTORNADO_ACTION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RKTORNADO_ACTION_ACK );
    SAFE_DELETE(pkBuff);
    // kRecv.m_nOK : 결과
    // kPacket_.m_nOK, 0    // 성공
    // kPacket_.m_nOK, 1    // 릭쿤 토네이도 이벤트 기간이 아님.
    // kPacket_.m_nOK, 2    // 릭쿤 토네이도 코인 아이템이 없음.
    // kPacket_.m_nOK, 3    // 릭쿤 토네이도 럭키 세븐 아이템 수량 부족.
    // kPacket_.m_nOK, 4    // 시스템 오류입니다.
    // kPacket_.m_nOK, 5    // 꽝 보상 아이템 가져오기 실패.
    // kPacket_.m_nOK, 6    // 보상 아이템 가져오기 실패.
    // kPacket_.m_nOK, 7    // 지급할 아이템 리스트 없음.
    // kPacket_.m_nOK, -98  // 아직 처리중인 작업입니다.

    switch(kRecv.m_nOK)
    {
    case 0:
        if( kRecv.m_vecItem.empty() == false )
        {
            g_pkUIScene->m_pkRickoonTornado->SetRewardItemList( kRecv.m_dwRewardType, kRecv.m_vecUseItem, kRecv.m_vecItem, kRecv.m_dwRewardItemID );
        }            
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RICKOON_TORNADO_ERROR1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, false );
        if ( g_pkUIScene->m_pkRickoonTornado )
        {
            g_pkUIScene->m_pkRickoonTornado->RollStop();
            g_pkUIScene->m_pkRickoonTornado->InitRollState();
            g_pkUIScene->m_pkRickoonTornado->Close();
        }

        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RICKOON_TORNADO_ERROR2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        g_pkUIScene->m_pkRickoonTornado->RollStop();
        g_pkUIScene->m_pkRickoonTornado->InitRollState();
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RICKOON_TORNADO_ERROR3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        g_pkUIScene->m_pkRickoonTornado->RollStop();
        g_pkUIScene->m_pkRickoonTornado->InitRollState();
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RICKOON_TORNADO_ERROR4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        g_pkUIScene->m_pkRickoonTornado->RollStop();
        g_pkUIScene->m_pkRickoonTornado->InitRollState();
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RICKOON_TORNADO_ERROR5 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        g_pkUIScene->m_pkRickoonTornado->RollStop();
        g_pkUIScene->m_pkRickoonTornado->InitRollState();
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RICKOON_TORNADO_ERROR6 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        g_pkUIScene->m_pkRickoonTornado->RollStop();
        g_pkUIScene->m_pkRickoonTornado->InitRollState();
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_CHOICE_DROP_ERROR9 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        g_pkUIScene->m_pkRickoonTornado->RollStop();
        g_pkUIScene->m_pkRickoonTornado->InitRollState();
        break;
    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_17 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        g_pkUIScene->m_pkRickoonTornado->RollStop();
        g_pkUIScene->m_pkRickoonTornado->InitRollState();
        break;
    default:
        g_pkUIScene->m_pkRickoonTornado->RollStop();
        g_pkUIScene->m_pkRickoonTornado->InitRollState();
        break;
    }
}

void On_EVENT_SPHINX_ITEM_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SPHINX_ITEM_LIST_NOT );
    SAFE_DELETE( pkBuff );
    if(g_pkUIScene->m_pkSphinxDlg)
        g_pkUIScene->m_pkSphinxDlg->SetResultItemList( kRecv );

}

void On_EVENT_USER_SPHINX_DATA_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_USER_SPHINX_DATA_ACK );
    SAFE_DELETE( pkBuff );
/*
    kPacket_.m_nOK, 0      // 성공
    kPacket_.m_nOK, 1      // DB에서 초기 데이터 이미 가져왔음.
    kPacket_.m_nOK, 2      // 스핑크스 OX 이벤트 기간이 아님.
    kPacket_.m_nOK, -98    // 아직 처리중인 작업입니다.

    int                             m_nOK;
    int                             m_nRightAnswerCnt;
    std::vector<int>                m_vecCorrectQuestions;
*/
    
    switch(kRecv.m_nOK)
    {
    case 0 :
    case 1 :
        g_pkUIScene->m_pkSphinxDlg->InitSphinxInfo( kRecv.m_nRightAnswerCnt );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_EVENT_SPHINX_DLG,L"",L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,false);
        break;
    case 2://     2 : 스핑크스 OX 이벤트 기간이 아님.
        if ( g_pkUIScene->m_pkSphinxDlg )
            g_pkUIScene->m_pkSphinxDlg->close();
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_SPHINX_EVENT_11 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case -98://     -98 : 아직 처리중인 작업입니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SPHINX_EVENT_15 ) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RICKOON_TORNADO_ERROR1 ), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        }
        break;
    }

    Result_SphinxReq = kRecv.m_nOK;
}

void On_EVENT_SPHINX_QUESTION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SPHINX_QUESTION_ACK );
    SAFE_DELETE( pkBuff );
/*
    kPacket_.m_nOK, 0      // 성공
    kPacket_.m_nOK, 1      // 스핑크스 OX 이벤트 기간이 아님.
    kPacket_.m_nOK, 2      // 스핑크스 OX 코인 아이템이 없음.
    kPacket_.m_nOK, 3      // 질문을 가져오지 못함.
    kPacket_.m_nOK, 4      // 시간정보 가져오지 못함.
    kPacket_.m_nOK, -98    // 아직 처리중인 작업입니다.

    int                             m_nOK;
    int                             m_nTimeValue; // 난이도에 따른 시간정보.
    int                             m_nQuestionID;
    KSerBuffer                      m_kQuestionBuff; // Compressed KSphinxQuestionInfo.
    KItem                           m_kCoinItem;   // 스핑크스 OX 코인 Item정보.
    std::vector<KItem>              m_vecUseItem;  //사용한 아이템 정보.
*/
    KSphinxQuestionInfo kQuestion;
    {
        kRecv.m_kQuestionBuff.UnCompress();
        KSerializer ks;
        ks.BeginReading( &kRecv.m_kQuestionBuff );
        ks.Get( kQuestion );
        ks.EndReading();
    }

    switch(kRecv.m_nOK)
    {
    case 0 :
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecUseItem , true);
        g_pkUIScene->m_pkSphinxDlg->SetQuizInfo( kRecv.m_nTimeValue, kQuestion );
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();

        break;
    case 1://     1 : 스핑크스 OX 이벤트 기간이 아님.
        if ( g_pkUIScene->m_pkSphinxDlg )
            g_pkUIScene->m_pkSphinxDlg->close();
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_SPHINX_EVENT_11 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 2://     2 : 스핑크스 OX 코인 아이템이 없음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_SPHINX_EVENT_12 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 3://      3      // 질문을 가져오지 못함.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_SPHINX_EVENT_13 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 4://     4      // 시간정보 가져오지 못함.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_SPHINX_EVENT_14 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;

    case -98://     -98 : 아직 처리중인 작업입니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_SPHINX_EVENT_15 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SPHINX_EVENT_11 ), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        }
        break;

    }
    if(kRecv.m_nOK != 0)
        g_pkUIScene->m_pkSphinxDlg->ClearPaticle();

    Result_SphinxReq = kRecv.m_nOK;

}

void On_EVENT_SPHINX_ANSWER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SPHINX_ANSWER_ACK );
    SAFE_DELETE( pkBuff );
/*
    kPacket_.m_nOK, 0      // 성공
    kPacket_.m_nOK, 1      // 스핑크스 OX 이벤트 기간이 아님.
    kPacket_.m_nOK, 2      // 존재하지 않는 문제.
    kPacket_.m_nOK, 3      // 정답을 맞추지 못했음.
    kPacket_.m_nOK, 4      // 보상정보를 가져오지 못했음.
    kPacket_.m_nOK, 5      // 유저의 스핑크스 정보를 불러오지 못했음.
    kPacket_.m_nOK, -98    // 아직 처리중인 작업입니다.
*/

    switch(kRecv.m_nOK)
    {
    case 0 :
        int iSphinxFace;
        if(kRecv.m_bCorrectCheck)
            iSphinxFace = KGCSphinxDlg::SEFS_ANGRY; // 스핑크스 열받는 표정
        else
            iSphinxFace = KGCSphinxDlg::SEFS_MOCK; // = 3, // 스핑크스 비웃는 표정

        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);
        g_pkUIScene->m_pkSphinxDlg->InitSphinxInfo( kRecv.m_nCorrectCount );
        g_pkUIScene->m_pkSphinxDlg->SetSphinxResult( iSphinxFace , kRecv.m_vecItem);
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();


        break;
    case 1://     1 : 스핑크스 OX 이벤트 기간이 아님.
        if ( g_pkUIScene->m_pkSphinxDlg )
            g_pkUIScene->m_pkSphinxDlg->close();

        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_SPHINX_EVENT_11 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
    case 2://     2 : 존재하지 않는 문제.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_SPHINX_EVENT_16 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 3://      3 정답을 맞추지 못했음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_SPHINX_EVENT_17 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 4://     4      // 보상정보를 가져오지 못했음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_SPHINX_EVENT_18 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 5://     4      // 유저의 스핑크스 정보를 불러오지 못했음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_SPHINX_EVENT_19 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;

    case -98://     -98 : 아직 처리중인 작업입니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SPHINX_EVENT_15 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SPHINX_EVENT_11 ), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        }

        break;

    }
    g_pkUIScene->m_pkSphinxDlg->ClearPaticle();

    Result_SphinxReq = kRecv.m_nOK;

}
void On_EVENT_CREATE_PARTY_ACK ( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPartyData );
    SAFE_DELETE( pkBuff );


    if ( kRecv.m_nOK == 0 )
    {
        g_pkChatManager->AddChatMsg( g_pkStrLoader->GetString( STR_ID_PARTY_ACCEPT),  KGCChatManager::CHAT_TYPE_ADMIN );

        SiKGCPartyManager()->SetPartyMemberList(kRecv.m_vecPartyPeople);
        
        if ( kRecv.m_dwPartyType == KPartyData::PT_NORMAL ) {
            g_pkUIScene->m_pkPartyWnd->OnPartyDlg();
            SiKGCPartyManager()->SendWaitInviteUser(kRecv.m_dwPartyType);
            return;
        }

        g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );
    
        if ( SiKGCChannelManager()->CheckChannel( CT_AUTOMATCH ) == false ) {
            g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_PARTY_CREATE ) );
        }    
    }
    else if  ( kRecv.m_nOK == 1 )
    {
        SiKGCPartyManager()->EraseInvitePartyUser(kRecv.m_kInvitee.m_dwUID);
        g_pkChatManager->AddChatMsg( g_pkStrLoader->GetString( STR_ID_PARTY_DENY ) ,  KGCChatManager::CHAT_TYPE_ADMIN );
    }

    SiKGCPartyManager()->SendWaitInviteUser(kRecv.m_dwPartyType);

}

void On_EVENT_CREATE_PARTY_ASK( WPARAM wParam, LPARAM lParam )
{ // 파티 초대를 받음
    KSerializer ks;
    ACK_DESERIALIZE( KPartyData );
    SAFE_DELETE( pkBuff );

    //kRecv.m_vecPartyPeople.front().m_strNickName; //파티장 UID, 파티 신청하는 사람
    //kRecv.m_dwInviteeUID; // 파티 신청 받은 사람 UID
    //g_kGlobalValue.m_vecPartyPeople = kRecv.m_vecPartyPeople; //파티 목록
    ////g_kGlobalValue.m_dPartyUID = kRecv.m_dwPartyUID; //파티 UID 
    if ( SiKGCPartyManager()->IsInviteState() )
    {

        SiKGCPartyManager()->SetPartyInfo(kRecv);
        
        //조건에 CheckServerType( ST_PVP )을 넣은 이유는 자동 매칭 사용시 서버타입에 ST_PVP가 포함되기 때문이다. 
        //해당 조건을 체크하지 않으면 일반서버의 아지트와 광장에서 상대방을 직접 파티에 초대할 수 없게 된다. 
        if ( (g_pkUIScene->m_pkMatchInviteUserList && g_pkUIScene->m_pkMatchInviteUserList->IsCreate() && g_kGlobalValue.ServerInfo.CheckServerType( ST_PVP ) ) ||
            (!( g_MyD3D->m_pStateMachine->GetState() == GS_MATCH ||
               g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO ||
#if defined USE_COORDI_SHOP
			   g_MyD3D->m_pStateMachine->GetState() == GS_COORDI_SHOP ||
#endif
               g_MyD3D->m_pStateMachine->GetState() == GS_SHOP_CASH ||
               g_MyD3D->m_pStateMachine->GetState() == GS_SHOP_GP ) &&
               g_kGlobalValue.ServerInfo.CheckServerType( ST_PVP ))){
            SiKGCPartyManager()->JoinParty( false );
            return;
        }

        SiKGCPartyManager()->SetInviteeUserInfo( false);
        SiKGCPartyManager()->SetInviteState( false);


        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_PARTY_INVITE , L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL );
    }
    else
    {
        g_pkChatManager->AddChatMsg( g_pkStrLoader->GetString( STR_ID_PARTY_INVITE_ERROR ),  KGCChatManager::CHAT_TYPE_ALERT );
    }

}

void On_EVENT_INVITE_PARTY_ROOM_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPartyRoomData );
    SAFE_DELETE( pkBuff );

    if ( g_MyD3D->m_pStateMachine->GetState() == GS_GAME)
    {
        if ( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_AGIT )
        {
            //	말풍선
            g_pkAgitOverlayUI->DeleteAllSayBalloon();

            // 모션제거
            g_pGraphicsHelper->UnLoadPlayerActionMotion();
            g_pGraphicsHelper->UnLoadPlayerModel();

            // 엑스트라 메시정보 제거
            g_kGlobalValue.m_ExtraMesh.ClearMeshInfo();

            SiKGCAgitGameManager()->SaveAgitObject();
            SiKGCAgitGameManager()->ClearObject();
            SiKGCAgitGameManager()->ClearPlaceCharUID();
            g_pkAgitOverlayUI->OnExitAgit();

            if( SiKGCAgitGameManager()->GetRegisterState() )
                SiKGCAgitGameManager()->UnRegisterAgitList();

            // 현재 아지트 나가고 
            g_pStateGame->OnExitGame(); 

            g_pkUIScene->EndMessageBox();
        }
    }

    SiKGCPartyManager()->GoRoom(kRecv.m_kPartyData.m_vecPartyPeople.front().m_dwUID , kRecv.m_strRoomPassword );
    g_pkUIScene->m_pkPartyWnd->OffPartyDlg();
    g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );
}

void On_EVENT_INVITE_PARTY_ASK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPartyData );
    SAFE_DELETE( pkBuff );

    if ( SiKGCPartyManager()->IsInviteState() )
    {
        SiKGCPartyManager()->SetPartyInfo(kRecv);
      
        //조건에 CheckServerType( ST_PVP )을 넣은 이유는 자동 매칭 사용시 서버타입에 ST_PVP가 포함되기 때문이다. 
        //해당 조건을 체크하지 않으면 일반서버의 아지트와 광장에서 상대방을 직접 파티에 초대할 수 없게 된다. 
        if ( (g_pkUIScene->m_pkMatchInviteUserList && g_pkUIScene->m_pkMatchInviteUserList->IsCreate() && g_kGlobalValue.ServerInfo.CheckServerType( ST_PVP ) ) ||
            (!( g_MyD3D->m_pStateMachine->GetState() == GS_MATCH ||
            g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO ||
#if defined USE_COORDI_SHOP
            g_MyD3D->m_pStateMachine->GetState() == GS_COORDI_SHOP ||
#endif
            g_MyD3D->m_pStateMachine->GetState() == GS_SHOP_CASH ||
            g_MyD3D->m_pStateMachine->GetState() == GS_SHOP_GP ) &&
            g_kGlobalValue.ServerInfo.CheckServerType( ST_PVP ))){
                SiKGCPartyManager()->JoinPartyToInvite( false );
                return;
        }
        SiKGCPartyManager()->SetInviteeUserInfo( true );
        SiKGCPartyManager()->SetInviteState( false);
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_PARTY_INVITE , L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL );
    }
    else
    {
        g_pkChatManager->AddChatMsg( g_pkStrLoader->GetString( STR_ID_PARTY_INVITE_ERROR ),  KGCChatManager::CHAT_TYPE_ALERT );
    }

}

void On_EVENT_INVITE_PARTY_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPartyData );
    SAFE_DELETE( pkBuff );
    kRecv.m_nOK;


    if ( kRecv.m_nOK == 0 )
    {
        //g_pkChatManager->AddChatMsg( g_pkStrLoader->GetString( STR_ID_TAG_MATCH_READY_HELP ),  KGCChatManager::CHAT_TYPE_ADMIN );
        g_pkChatManager->AddChatMsg( g_pkStrLoader->GetString( STR_ID_PARTY_SUCCESS ) ,  KGCChatManager::CHAT_TYPE_ADMIN );

        SiKGCPartyManager()->SetPartyMemberList(kRecv.m_vecPartyPeople);

        if ( kRecv.m_dwPartyType == KPartyData::PT_NORMAL ) {
            g_pkUIScene->m_pkPartyWnd->OnPartyDlg();
            SiKGCPartyManager()->SendWaitInviteUser(kRecv.m_dwPartyType);
            return;
        }

        g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );

        if ( SiKGCChannelManager()->CheckChannel( CT_AUTOMATCH ) == false ) {
            g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_PARTY_CREATE ) );
        }    

    }
    else if  ( kRecv.m_nOK == 1 )
    {
        SiKGCPartyManager()->EraseInvitePartyUser(kRecv.m_kInvitee.m_dwUID);
        g_pkChatManager->AddChatMsg( g_pkStrLoader->GetString( STR_ID_PARTY_DENY ) ,  KGCChatManager::CHAT_TYPE_ADMIN );
    }
    else {
        SiKGCPartyManager()->EraseInvitePartyUser(kRecv.m_kInvitee.m_dwUID);
       g_pkChatManager->AddChatMsg( g_pkStrLoader->GetString( STR_ID_PARTY_INVITE_IMPOSSIBLE ) ,  KGCChatManager::CHAT_TYPE_ADMIN );
        //kRecv.m_nOK; // 2 : 파티원이 없음(에러), 3 : 파티장 아닌데 초대요청 보냄(에러)
    }

    SiKGCPartyManager()->SendWaitInviteUser(kRecv.m_dwPartyType);

}


void On_EVENT_CHANGE_PARTY_HOST_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPartyData );
    SAFE_DELETE( pkBuff );

 

    SiKGCPartyManager()->SetPartyMemberList(kRecv.m_vecPartyPeople);
    
    if ( kRecv.m_dwPartyType == KPartyData::PT_NORMAL ) {
        g_pkUIScene->m_pkPartyWnd->UpdatePartyDlg();
        return;
    }
    g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );

}

void On_EVENT_LEAVE_PARTY_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPartyData );
    SAFE_DELETE( pkBuff );

    SiKGCPartyManager()->SetPartyMemberList(kRecv.m_vecPartyPeople);
    if ( kRecv.m_dwPartyType == KPartyData::PT_NORMAL ) {
        g_pkUIScene->m_pkPartyWnd->UpdatePartyDlg();
        return;
    }
    g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );
    //파티원이 파티를 떠날때 이거를 날려 준다.
}

void On_EVENT_LEAVE_PARTY_USER_ACK( WPARAM wParam, LPARAM lParam )
{
    // 파티 나갈 때 응답받는 것. 데이터는 없음 , enum 만 받음.
    SiKGCPartyManager()->EndParty();
    g_pkUIScene->m_pkPartyWnd->OffPartyDlg();
    g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );
}

void On_EVENT_BREAK_PARTY_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPartyData );
    SAFE_DELETE( pkBuff );

    // 파티가 해체되었다.
    // kRecv.m_vecPartyPeople 여기에는 나의 데이터만 들어있다.

    SiKGCPartyManager()->EndParty();
    if ( g_pkUIScene->m_pkPartyWnd != NULL )
        g_pkUIScene->m_pkPartyWnd->OffPartyDlg();
    g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );
}

void On_EVENT_BAN_PARTY_USER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPartyData );
    SAFE_DELETE( pkBuff );

    // 파티에서 강퇴 당했다
    SiKGCPartyManager()->EndParty();
    g_pkUIScene->m_pkPartyWnd->OffPartyDlg();
    g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );
}

void On_EVENT_OPEN_CALENDAR_BONUS_POINT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_OPEN_CALENDAR_BONUS_POINT_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK; // 결과값 0일 경우에만 갱신해주세요.
    // kRecv.m_nAddGCPoint;  // 획득한 출석포인트
    // kRecv.m_nGCPoint;     // 현재 총 출석포인트
    // kRecv.m_nInitGCPoint; // DB에서 받아온 출석포인트 초기값 (서버사용)

    if( kRecv.m_nOK == 0 )
    {
        g_pkUIScene->m_pkAttendanceCalendar->SetGCPoint( kRecv.m_nAddGCPoint );
        g_kGlobalValue.m_iGCPoint = kRecv.m_nGCPoint;

        if( g_pkUIScene->m_pkAttendanceCalendar->IsRenderOn() )
        {
            g_pkUIScene->m_pkAttendanceCalendar->SetCalendar();
        }
    }
}

// 아지트
void On_EVENT_ENTER_AGIT_ACK( WPARAM wParam, LPARAM lParam )
{
    // 아지트 입장요청 결과
    KSerializer ks;
    ACK_DESERIALIZE( KEnterAgitAck );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK;
    //     0 : 성공
    //     1 : 아지트 정보를 DB에서 받아올 수 없음.
    //     5 : 아지트 입장 정원 초과
    //     6 : 입장할 아지트는 친구만 입장 가능.
    //     7 : 입장할 아지트의 비밀번호가 틀림
    //     8 : 입장할 아지트의 정원이 초과됨.
    //     9 : 주인이 접속중이 아님.
    // kRecv.m_kInfo : 입장할 아지트 정보
    // kRecv.m_prTRServerIpPort : 해당 아지트에서 사용하는 TCP IP/Port
    // kRecv.m_prURServerIpPort : 해당 아지트에서 사용하는 UDP IP/Port
    // kRecv.m_vecRewardItem : 추가적으로 지급받은 화분 아이템
    // kRecv.m_vecEraseItem : 삭제된 화분 아이템
    // kRecv.m_mapTrainingObj : 훈련소 정보 map[훈련소ItemUID, pair[쌓인수량,수량동기화시간] ]
    // 성공시, 아지트 로딩 진행.
    Result_EnterAgitReq = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0:

        ////	현재 아지트에 접속중이라면
        //if( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_AGIT &&
        //	g_MyD3D->m_pStateMachine->GetState() == GS_GAME ) 
        //{
//			g_pkAgitOverlayUI->CloseInviteVisitUI();
//			g_pStateGame->OnExitGame(); // 내아지트에서 나온 다음
        //}

        {
            // 획득한 아이템은 인벤으로 
            for( std::vector<KItem>::iterator it = kRecv.m_vecRewardItem.begin() ; it != kRecv.m_vecRewardItem.end() ; ++it )
            {
                g_pItemMgr->m_kInventory.AddItem( *it, true);
            }

            // 제거된 아이템 처리 
            std::vector< GCITEMUID > vecErase = kRecv.m_vecEraseItem;
            g_pItemMgr->m_kInventory.RemoveItemList( vecErase );
        }

        SiKGCAgitGameManager()->SetAgitInfo( kRecv.m_kInfo );               // 아지트 정보 
        SiKGCAgitGameManager()->SetURIpPort( kRecv.m_prURServerIpPort );    // 릴레이 서버 
        SiKGCAgitGameManager()->SetTRIpPort( kRecv.m_prTRServerIpPort );    // 릴레이 서버 
        SiKGCAgitGameManager()->SetFairyTreeInfo( kRecv.m_kFairyTree );     // 요정의 나무 
        SiKGCAgitGameManager()->SetMaxChannel( kRecv.m_nAigtChannelCount );

        g_kGlobalValue.UseTCPRelay(true);

        for( std::map<GCITEMUID, KFlowerPot>::iterator mit = kRecv.m_mapFlowerPot.begin() ; mit != kRecv.m_mapFlowerPot.end() ; ++mit )
            SiKGCAgitGameManager()->SetFlowerPotInfo( mit->second );        // 화분


        for( std::map<GCITEMUID, KTrainingObj >::iterator mit = kRecv.m_mapTrainingObj.begin() ; mit != kRecv.m_mapTrainingObj.end() ; ++mit )
            SiKGCAgitGameManager()->SetTrainingObjInfo( mit->second );

        SiKGCAgitGameManager()->InitBeforeEnterAgit();
        if( kRecv.m_kInfo.m_dwUID == g_kGlobalValue.m_kUserInfo.dwUID ) {
            SiKGCAgitGameManager()->SetAgitShop();
        }

        //g_MyD3D->m_pStateMachine->GoLoading();
        // 아지트 입장일 경우 AgitGameManager에 상태를 저장 해 둔다
        if ( g_MyD3D->m_pStateMachine->GoLoading() ) {
            SiKGCAgitGameManager()->SetAgitEnterd( true );
        }

        SiKGCAgitGameManager()->SetAgitMaxCharPosCount( kRecv.m_usMaxCharPosCount ); // 캐릭터 최대 배치 개수
        break;

    case 1:
        if( false == g_pkUIScene->IsWaitMsgBox_Use(KGCUIScene::GC_MBOX_USE_AGIT_ERROR) )
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_AGIT_ENTER_ACK_ERROR_1, "i", kRecv.m_nOK ), L"", KGCUIScene::GC_MBOX_USE_AGIT_ERROR, 0, 0, true, true, true );
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_LOADING_AGIT_FAIL4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_ENTER_ACK_ERROR_6 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_ENTER_ACK_ERROR_7 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 8:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_ENTER_ACK_ERROR_8 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 9:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_ENTER_ACK_ERROR_9 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true);
        }
        break;
    }
}

void On_EVENT_ENTER_AGIT_BROAD( WPARAM wParam, LPARAM lParam )
{
    // 현재 머물고 있는 아지트에 새로운 유저가 입장하는 것을 알림.
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ENTER_AGIT_BROAD );
    SAFE_DELETE( pkBuff );
    // kRecv.m_dwAgitUID;    // 아지트UID
    // kRecv.m_kUserInfo;    // 입장한 유저 정보

    SiKGCAgitGameManager()->OnInsertUser( kRecv.m_dwAgitUID, kRecv.m_kUserInfo );
}

void On_EVENT_AGIT_LOADING_COMPLETE_ACK( WPARAM wParam, LPARAM lParam )
{
    // 아지트 로딩완료후, 입장처리 결과
    KSerializer ks;
    ACK_DESERIALIZE( KAgitLoadingCompleteAck );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK;
    //     0 : 성공
    //     2 : 입장할 아지트 정보가 정확하지 않음
    //     3 : 아지트 입장할 캐릭터 정보가 없음.
    //     4 : 입장할 아지트 정보가 없음.
    //     5 : 입장할 아지트 정원이 초과됨.
    // kRecv.m_dwAgitUID; // 입장 진행할 아지트UID
    // kRecv.m_dwUserUID; // 입장하는 유저UID
    // kRecv.m_mapAgitUser; // 아지트안에 있는 유저들 정보

    switch( kRecv.m_nOK )
    {
    case 0:
        if( SiKGCAgitGameManager()->GetAgitInfo().m_dwUID == kRecv.m_dwAgitUID && 
            g_MyD3D->m_TempPlayer.m_kUserInfo.dwUID == kRecv.m_dwUserUID ) // 한번 더 확인 하고 
        {
            SiKGCAgitGameManager()->SetAgitUserInfo( kRecv.m_mapAgitUser );
        }
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_LOADING_AGIT_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_LOADING_AGIT_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_LOADING_AGIT_FAIL3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_LOADING_AGIT_FAIL4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true);
        }
        break;
    }

    // 로딩 실패 처리
    if( 0 != kRecv.m_nOK)
    {
        // 로딩 실패 유저들이 있다면 지워준다.
        KEVENT_INFORM_USER_LEAVE_ROOM_NOT kFailUserInfo;
        kFailUserInfo.m_dwUserUID = kRecv.m_dwUserUID;
        On_DESTROY_USER(kFailUserInfo);
        KGCStateLoading* pState = (KGCStateLoading*)g_MyD3D->m_pStateMachine->GetStatePtr( GS_GAME_LOADING );
        pState->SetLoadCompleteInServer(true);
    }

    Result_AgitLoadComplete = kRecv.m_nOK;
}

void On_EVENT_LEAVE_AGIT_ACK( WPARAM wParam, LPARAM lParam )
{
    // 아지트 떠나기후, 이 패킷을 받은 후에 다른 아지트로 입장이 가능.
    Result_LeaveAgit = 0;
}

void On_EVENT_LEAVE_AGIT_BROAD( WPARAM wParam, LPARAM lParam )
{
    // 내가 머물고 있는 아지트에 있는 유저가 나감 알림.
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_LEAVE_AGIT_BROAD );
    SAFE_DELETE( pkBuff );
    // kRecv.m_dwAgitUID;    // 아지트UID
    // kRecv.m_dwUserUID;    // 떠나는 유저UID

    SiKGCAgitGameManager()->OnDestroyUser( kRecv.m_dwAgitUID, kRecv.m_dwUserUID );    
}

void On_EVENT_AGIT_MAP_CATALOGUE_ACK( WPARAM wParam, LPARAM lParam )
{
    // 구입가능한 아지트 맵 카탈로그 전달
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_AGIT_MAP_CATALOGUE_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_PayItemID;    // 맵구매시 화폐로 쓰이는 아이템ItemID (민들레)
    // kRecv.m_mapMapList;   // 맵 상품 리스트 map[MapUID,MapInfo]

    SiKGCAgitGameManager()->SetMapCatalog( kRecv );
}

void On_EVENT_BUY_AGIT_MAP_ACK( WPARAM wParam, LPARAM lParam )
{
    // 맵 구매 결과
    KSerializer ks;
    ACK_DESERIALIZE( KBuyAgitMapAck );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK;      // 성공여부
    //     0 : 성공
    //     1 : 현재 있는 아지트가 내 아지트가 아님.
    //     2 : 구매할 맵 정보가 서버에 없음.
    //     3 : 화폐 아이템이 없음.
    //     4 : 화폐 수량이 부족함.
    //     5 : 맵 구매진행할 아지트 정보가 없음.
    //     6 : 맵구매 DB처리 실패.
    //     7 : 현재 자신의 맵과 동일한 맵.
    // kRecv.m_dwMapID;  // 변경된 맵 ID
    // kRecv.m_kPayItem; // 화폐 아이템
    // kRecv.m_vecRewardItem; // 획득 아이템 아이템 std::vector<KItem>
    // kRecv.m_vecEraseItem; // 삭제 아이템 리스트 std::vector<GCITEMUID>

    switch( kRecv.m_nOK )
    {
    case 0:
        {
            // 사용된 돈 깎아주고 
            KItem* pItem = NULL;
            g_pItemMgr->FindInventoryForItemID( kRecv.m_kPayItem.m_ItemID / 10, &pItem );
            pItem->m_nCount = kRecv.m_kPayItem.m_nCount;

            if( pItem->m_nCount <= 0 )
                g_pItemMgr->RemoveInventoryItemList( pItem->m_ItemUID );

            {
                // 획득한 아이템은 인벤으로 
                for( std::vector<KItem>::iterator it = kRecv.m_vecRewardItem.begin() ; it != kRecv.m_vecRewardItem.end() ; ++it )
                {
                    g_pItemMgr->m_kInventory.AddItem( *it, true);
        }

                // 제거된 아이템 처리 
                std::vector< GCITEMUID > vecErase = kRecv.m_vecEraseItem;
                g_pItemMgr->m_kInventory.RemoveItemList( vecErase );


                // 배치 가능 오브젝트 리스트 갱신
                SiKGCAgitGameManager()->RefreshInvenObject();
                g_pkAgitOverlayUI->UpdatePlaceCollectUI();
            }
        }
        break;

    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BUY_AGIT_MAP_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BUY_AGIT_MAP_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BUY_AGIT_MAP_FAIL3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BUY_AGIT_MAP_FAIL4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BUY_AGIT_MAP_FAIL5 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BUY_AGIT_MAP_FAIL6 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BUY_AGIT_MAP_FAIL7 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true);
        }
        break;
    }

    Result_BuyAgitShop = kRecv.m_nOK;
}

void On_EVENT_CHANGE_AGIT_MAP_BROAD( WPARAM wParam, LPARAM lParam )
{
    // 현재 머물고 있는 아지트 맵 변경됨 알림.
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHANGE_AGIT_MAP_BROAD );
    SAFE_DELETE( pkBuff );
    // kRecv.m_dwAgitUID;    // 아지트UID
    // kRecv.m_dwMapID;      // 바뀐 MapID
}

void On_EVENT_SET_AGIT_OPTION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSetAgitOptionAck );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK;          // 성공여부
    //     0 : 성공
    //     1 : 현재 있는 아지트가 내 아지트가 아님.
    //     2 : 아지트명에 사용할 수 없는 단어나 있음.
    //     3 : 아지트명에 사용할 수 없는 문자가 있음.
    //     4 : 프로필에 사용할 수 없는 단어나 있음.
    //     5 : 프로필에 사용할 수 없는 문자가 있음.
    //     6 : 암호에 사용할 수 없는 문자가 있음.
    //     7 : 옵션변경할 아지트 정보가 없음.
    //     8 : 아지트명 길이제한을 초과함
    //     9 : 입장제한 인원수를 초과함
    //     10 : 정의되지않은 오픈설정
    //     11 : 패스워드 길이제한을 초과함
    //     12 : 정의되지않은 초대설정
    //     13 : 프로필 길이제한을 초과함
    //     14 : 옵션변경 DB처리 실패.
    // kRecv.m_kOption;      // 아지트옵션

    switch( kRecv.m_nOK )
    {
    case 0:
        // 성공 했으면 내가 있는 아지트 정보 갱신해준다. 
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SET_AGIT_OPTION_SUCCESS ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SET_AGIT_OPTION_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SET_AGIT_OPTION_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SET_AGIT_OPTION_FAIL3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SET_AGIT_OPTION_FAIL4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SET_AGIT_OPTION_FAIL5 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SET_AGIT_OPTION_FAIL6 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SET_AGIT_OPTION_FAIL7 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 8:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SET_AGIT_OPTION_FAIL8 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 9:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SET_AGIT_OPTION_FAIL9 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 10:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SET_AGIT_OPTION_FAIL10 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 11:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SET_AGIT_OPTION_FAIL11 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 12:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SET_AGIT_OPTION_FAIL12 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 13:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SET_AGIT_OPTION_FAIL13 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 14:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SET_AGIT_OPTION_FAIL4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SET_AGIT_OPTION_FAILED ), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        }
        break;
    }
}

void On_EVENT_AGIT_STORE_CATALOG_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_AGIT_STORE_CATALOG_ACK );
    SAFE_DELETE( pkBuff );
    // 아지트상점 아이템 리스트
    // kRecv : std::map<PAIR_USHORT_DWORD,KManufactureItem>
    // kRecv.m_mapItemList : 상점아이템 리스트 map[ pair[Index,ItemID], ItemInfo ]  std::map<PAIR_USHORT_DWORD,KManufactureItem>
    // kRecv.m_mapItemPos : 상점아이템 배치좌표 map[ pair[Index,ItemID], pair[x,y] ] std::map<PAIR_USHORT_DWORD,PAIR_INT>

	Result_AgitShopCatalog = 0;
    SiKGCAgitGameManager()->SetAgitShopCatalog( kRecv.m_mapItemList, kRecv.m_mapItemPos );
}

void On_EVENT_AGIT_STORE_MATERIAL_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_AGIT_STORE_MATERIAL_ACK );
    SAFE_DELETE( pkBuff );
    // 아지트상점 아이템 구매조건
    // kRecv : std::map<PAIR_USHORT_DWORD,std::vector<KDropItemInfo> >
    // map[ [Index,ItemID], 구매조건 ]

    SiKGCAgitGameManager()->SetAgitShopMaterial( kRecv );
}

void On_EVENT_BUY_FOR_AGIT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BUY_FOR_AGIT_ACK );
    SAFE_DELETE( pkBuff );
    // 아지트상점 아이템 구매결과
    // kRecv.m_nOK : 구매 결과
    //     0 : 성공.
    //     1 : 구매 아이템 정보가 없음.
    //     2 : 구매 아이템 재료정보가 없음.
    //     3 : 구매 재료 아이템이 인벤에 없음.
    //     4 : 구매재료 영구아이템이 없음.
    //     5 : 구매재료 수량아이템의 수량이 부족함.
    //     6 : 아지트아이템 구매시 충분한 인벤 공간이 없음.
    //     7 : 코디아이템 구매시 충분한 인벤 공간이 없음.
    //     8 : 일반 아이템 구매시 충분한 인벤 공간이 없음.
    //     9 : DB작업중 아이템 넣기 실패.
    //    10 : DB작업중 룩 아이템 변환 실패.
    //    11 : DB작업중 아지트 아이템 설정 실패.
    //    12 : 인벤토리 보유량 제한에 걸림

    //   -98 : 아직 처리중인 작업
    // kRecv.m_nGP : 현재GP량(사용안함)
    // kRecv.m_vecRewards : 획득 아이템
    // kRecv.m_vecCountMaterialItems : 소모된 수량 아이템
    // kRecv.m_vecPeriodMaterialItems : 소모된 영구 아이템

    switch( kRecv.m_nOK )
    {
    case 0: // 성공 
        {
            // 소모된 수량 아이템 
            std::vector<KItem>  vecZeroCount;
            for( std::vector<KItem>::iterator it = kRecv.m_vecCountMaterialItems.begin() ; it != kRecv.m_vecCountMaterialItems.end() ; ++it )
            {
                DWORD ItemID = static_cast<DWORD>(it->m_ItemID/10);
                g_pItemMgr->m_kInventory.FindItemByItemID( ItemID )->m_nCount = it->m_nCount;

                if( g_pItemMgr->m_kInventory.FindItemByItemID( ItemID )->m_nCount <= 0 )
                    vecZeroCount.push_back( *(g_pItemMgr->m_kInventory.FindItemByItemID( ItemID )) );

            }

            // 소모된 영구 아이템
            std::vector<KItem> vecMaterailItem;
            for( std::vector<GCITEMUID>::iterator it = kRecv.m_vecPeriodMaterialItems.begin() ; it != kRecv.m_vecPeriodMaterialItems.end() ; ++it )
            {
                vecMaterailItem.push_back( *(g_pItemMgr->m_kInventory.FindItemByItemUID( *it )) );
            }

            // 인벤토리에서 삭제 
            g_pItemMgr->m_kInventory.RemoveItemList( vecZeroCount );
            g_pItemMgr->m_kInventory.RemoveItemList( vecMaterailItem );
        }

        // 아이템 추가 
        for( std::vector<KItem>::iterator it = kRecv.m_vecRewards.begin() ; it != kRecv.m_vecRewards.end() ; ++it )
        {
            g_pItemMgr->m_kInventory.AddItem( *it, true);
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_BUY_POINT_ITEM_SUCCESS, "l", g_pItemMgr->GetItemName(static_cast<DWORD>(it->m_ItemID/10)) ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        }

        // 배치 가능 오브젝트 리스트 갱신
        SiKGCAgitGameManager()->RefreshInvenObject();
        SiKGCAgitGameManager()->BuyDummyObject();
        g_pkAgitOverlayUI->UpdatePlaceCollectUI();

        //	상점 UI 갱신
        g_pkAgitOverlayUI->UpdatShopPage();

        // 씨앗 수 UI 갱신
        g_pkAgitOverlayUI->UpdateMoneyInfo();
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BUY_AGIT_ITEM_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BUY_AGIT_ITEM_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BUY_AGIT_ITEM_FAIL3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BUY_AGIT_ITEM_FAIL4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BUY_AGIT_ITEM_FAIL5 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 6:
    case 7:
    case 8:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BUY_AGIT_ITEM_FAIL6 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 9:
    case 10:
    case 11:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BUY_AGIT_ITEM_FAIL7 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 12:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(  STR_ID_BUY_AGIT_ITEM_FAIL8 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true);
        }
    }
    
    // 구매 실패 시 미리 배치중이었다면 지워준다. 
    if( kRecv.m_nOK != 0 && SiKGCAgitGameManager()->IsPrePlace() )
        SiKGCAgitGameManager()->RemoveDummyObject();

    Result_BuyAgitShop = kRecv.m_nOK;
}

void On_EVENT_SELL_FOR_AGIT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SELL_FOR_AGIT_ACK );
    SAFE_DELETE(pkBuff);
    // kRecv.m_nOK;          // 성공유무
    //     0, 성공
    //     1, 판매할 아이템 리스트가 비었음.
    //     2, 인벤토리에 해당 아이템이 없음.
    //     3, 아지트 물품이 아님.
    //     4, 아이템 판매 서버처리 실패.
    //     5, 아이템 판매 DB처리 실패.
    //     6, 화분 아이템은 판매할 수 없음.
    // kRecv.m_vecRewardItem;// 판매로 인해 획득한 아이템 (처리 성공시,인벤토리에 넣을 것)
    // kRecv.m_vecSellItem;  // 판매된 아이템 리스트 (처리 성공시,인벤토리에서 제거)
    // kRecv.m_vecEraseItem; // 제거된 아이템 리스트 (처리 성공시,인벤토리에서 제거)
    // kRecv.m_mapFailInfo;  // 판매실패한 아이템 리스트 map[ ItemUID, 실패값(kRecv.m_nOK의 에러값과 동일) ]

    switch( kRecv.m_nOK )
    {
    case 0:
        {
        // 판매로 획득한 아이템은 인벤으로 
        for( std::vector<KItem>::iterator it = kRecv.m_vecRewardItem.begin() ; it != kRecv.m_vecRewardItem.end() ; ++it )
        {
            g_pItemMgr->m_kInventory.AddItem( *it, true);
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_SELL_AGIT_OBJECT_SUCCESS, "l", g_pItemMgr->GetItemName(static_cast<DWORD>(it->m_ItemID/10)) ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        }

        // 우측에 표시되는 별사탕 수량 갱신
        g_pkAgitOverlayUI->UpdateMoneyInfo();

        // 판매/제거된 아이템 처리 
        std::vector< GCITEMUID > vecSell = kRecv.m_vecSellItem;
        g_pItemMgr->m_kInventory.RemoveItemList( vecSell );

        std::vector< GCITEMUID > vecErase = kRecv.m_vecEraseItem;
        g_pItemMgr->m_kInventory.RemoveItemList( vecErase );


        // 배치 가능 오브젝트 리스트 갱신
        SiKGCAgitGameManager()->RefreshInvenObject();
        g_pkAgitOverlayUI->UpdatePlaceCollectUI();
        g_pkAgitOverlayUI->ShowAgitPlaceCollectUI(true);

        }
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_ITEM_SELL_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_ITEM_SELL_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_ITEM_SELL_FAIL3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_ITEM_SELL_FAIL4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_ITEM_SELL_FAIL5 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_ITEM_SELL_FAIL6 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true);
        }
    }

    // 판매 창은 꺼준다.
    g_pkAgitOverlayUI->ShowAgitSellBox(false, std::make_pair(0,0));
    Result_BuyAgitShop = kRecv.m_nOK;
}

void On_EVENT_SEED_FLOWER_POT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSeedFlowerPotAck );
    SAFE_DELETE(pkBuff);
    // 씨앗심기 결과
    // kRecv.m_nOK;          // 성공유무
    //     0, 성공
    //     1, 현재 있는 아지트가 내 아지트가 아님.
    //     2, 심고자 하는 화분을 가지고있지 않음.
    //     3, 씨앗 아이템이 없음.
    //     4, 씨앗심을 아지트 정보가 없음.
    //     5, 정의되지 않은 씨앗심기 타입.
    //     6, 화분 아이템이 아님.
    //     7, 캐쉬화분 개수제한에 걸림.
    //     8, 일반화분 개수제한에 걸림.
    //     9, 씨앗 아이템이 아니다.
    //     10, 씨앗 개수가 부족하다.
    //     11, 화분초기화 DB처리 실패.
    //     12, 씨앗심기 DB처리 실패.
    // kRecv.m_kPotInfo;     // 화분 정보
    // kRecv.m_kSeedItem;    // 씨앗 아이템정보


    switch( kRecv.m_nOK )
    {
    case 0:
        {
            // 화분 정보 세팅하고 씨앗 감소시켜 줍니다. 
            SiKGCAgitGameManager()->SetFlowerPotInfo( kRecv.m_kPotInfo );
            SiKGCAgitGameManager()->SetSeedInfo( &kRecv.m_kSeedItem );
            g_pkAgitOverlayUI->ShowSeedPlant( false );

            // 씨앗 수 UI 갱신
            g_KDSound.Play( "984032" );
            g_pkAgitOverlayUI->UpdateMoneyInfo();
        }   
        break;

    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
        break;
    }

}

void On_EVENT_CHANGE_FLOWER_POT_STATE_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHANGE_FLOWER_POT_STATE_BROAD );
    SAFE_DELETE(pkBuff);
    // 화분상태 변경알림
    // kRecv.m_dwAgitUID;    // 아지트UID
    // kRecv.m_kFlowerPot;   // 바뀐 화분정보

    // 현재 있는 아지트면 
    if( SiKGCAgitGameManager()->GetAgitUID() == kRecv.m_dwAgitUID )
        SiKGCAgitGameManager()->SetFlowerPotInfo( kRecv.m_kFlowerPot );
}

void On_EVENT_HARVEST_FLOWER_POT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KHarvestFlowerPotAck );
    SAFE_DELETE(pkBuff);
    // 수확하기 결과
    // kRecv.m_nOK;          // 성공유무
    //     0, 성공
    //     1, 현재 있는 아지트가 내 아지트가 아님.
    //     2, 수확할 화분을 가지고있지 않음.
    //     3, 수확을 진행할 아지트 정보가 없음.
    //     4, 수확할 화분정보가 없음.
    //     5, 수확가능한 상태가 아니다.
    //     6, 수확가능한 시간이 아니다.
    //     7, 정의되지 않은 씨앗심기 타입.
    //     8, 수확할 꽃의 정보가 서버와 다름.
    //     9, 화분초기화 DB처리 실패.
    // kRecv.m_kPotInfo;     // 화분 정보
    // kRecv.m_kFlowerItem;  // 민들레 아이템정보
    // kRecv.m_nFlowerCount; // 획득한 민들레 개수
    // kRecv.m_nBonusFlowerCount; // 획득한 보너스 민들레 개수
    // kRecv.m_vecItem;      // 획득한 아이템.

    switch( kRecv.m_nOK )
    {
    case 0:
        {
        // 수확한 아이템 인벤에 넣어 주고 
        for( std::vector<KItem>::iterator it = kRecv.m_vecItem.begin() ; it != kRecv.m_vecItem.end() ; ++it )
            g_pItemMgr->m_kInventory.AddItem( *it, true);

        // 수확 끝난 화분 초기화 
        SiKGCAgitGameManager()->SetFlowerPotInfo( kRecv.m_kPotInfo );
        
        // 별사탕 수 UI 갱신 
        g_pkAgitOverlayUI->UpdateMoneyInfo();

            // 별사탕 획득 모션
            PLAYER *pPlayer = g_MyD3D->GetPlayerByUID( kRecv.m_dwAgitUID );
            if( pPlayer )
            {
                int iMontionID = MID_AZIT_STAR_GRIL;
                if( SEX_MAN == g_kGlobalValue.IsSexCharacter( pPlayer->GetCurrentChar().iCharType ) )
                    iMontionID = MID_AZIT_STAR_MEN;
                pPlayer->SetPlayerState( iMontionID );
                pPlayer->SetFrameIndex( 0 );
            }
        }
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_HARVEST_FLOWER_POT_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_HARVEST_FLOWER_POT_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_HARVEST_FLOWER_POT_FAIL3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_HARVEST_FLOWER_POT_FAIL4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_HARVEST_FLOWER_POT_FAIL5 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_HARVEST_FLOWER_POT_FAIL6 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_HARVEST_FLOWER_POT_FAIL7 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 8:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_HARVEST_FLOWER_POT_FAIL8 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 9:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_HARVEST_FLOWER_POT_FAIL9 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true);
        }
        break;
    }
}

void On_EVENT_AGIT_STAY_BONUS_DROP_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KAgitBonusDrop );
    SAFE_DELETE(pkBuff);
    // 남의 아지트 체제시간으로 씨앗 아이템 드랍받음
    // kRecv.m_dwAgitUID;    // 아지트UID
    // kRecv.m_tmDropTime;   // 지급받은 시간
    // kRecv.m_nDropCount;   // 지급받은 수량
    // kRecv.m_vecItem;      // 지급할 보상 아이템.리스트.

    g_pItemMgr->SetDurationItem( kRecv.m_vecItem );
    g_pkAgitOverlayUI->UpdateMoneyInfo();
}

void On_EVENT_AGIT_CHAT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KAgitChatAck );
    SAFE_DELETE(pkBuff);
    // 아지트 채팅 결과
    // kRecv.m_nOK; // 성공유무
    //     0, 성공
    //     1, 아지트 상태가 아니다.
    //     2, 채팅주기가 짧음.
    //     3, 메세지가 비어있음.
    //     4, 칼라채팅할 조건이 안된다.
    //     5, 운영자가 아닌데 영자채팅 요청.
    //     6, 정의되지않은 아지트채팅 타입.
    //     7, 채팅 블럭 상태임.

}

void On_EVENT_AGIT_CHAT_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KChatData );
    SAFE_DELETE(pkBuff);
    // 아지트 채팅 받음
    // kRecv : 전달받은 채팅 데이터 (KChatData)

    if ( true == g_kGlobalValue.IsBlockUser( kRecv.m_strSenderNick ) ||
         true == SiKFriendShip()->IsBlockFriend( kRecv.m_strSenderNick ) )
        return;

    g_pkChatManager->ChatMsgProc( kRecv.m_strSenderNickColor, kRecv.m_strSenderNick, kRecv.m_strChatMsg, kRecv.m_cChatType, kRecv.m_dwChatColor );

    SiKD3DEmoticonString()->clear();
    if( false == SiKD3DEmoticonString()->IsEmoticonHasMessage( kRecv.m_strChatMsg ) )
    {
        g_pkUIScene->m_pkAgitOverlayUI->SetBalloonMsg(kRecv.m_strChatMsg, kRecv.m_dwSenderUID,(KChatData::ENUM_CHAT_TYPE)kRecv.m_cChatType, kRecv.m_dwChatColor);
    }

    SAFE_DELETE( pkBuff );
}

void On_EVENT_AGIT_BAN_USER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KAgitBanUserAck );
    SAFE_DELETE(pkBuff);
    // 아지트 추방요청 결과
    // kRecv.m_nOK; // 성공유무
    //     0, 성공
    //     1, 현재 있는 아지트가 내 아지트가 아님.
    //     2, 추방처리할 아지트 정보가 없음.
    //     3, 추방할 유저가 내 아지트에 없음.
    // kRecv.m_dwAgitUID; // 아지트UID
    // kRecv.m_dwBanUserUID; // 추방할 유저UID

    switch( kRecv.m_nOK )
    {
    case 0:
        g_pkUIScene->m_pkAgitOverlayUI->DeleteBalloonMsg(kRecv.m_dwBanUserUID);
        break;

    case 1:
        break;

    case 2:
        break;

    case 3:
        // 서버에는 접속 정보 없다 -> 아지트 안에서 리소스 정리만 해 주자 
        SiKGCAgitGameManager()->OnDestroyUser( kRecv.m_dwAgitUID, kRecv.m_dwBanUserUID );
        break;
    }
}

void On_EVENT_AGIT_BAN_USER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( DWORD );
    SAFE_DELETE(pkBuff);
    // 아지트 추방당함 알림
    // kRecv : 추방당한 아지트UID

    // 추방이여 
    SiKGCAgitGameManager()->OnBanUser( kRecv );
}

void On_EVENT_SET_AGIT_OBJECT_POS_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSetAgitObjectPosAck );
    SAFE_DELETE(pkBuff);
    // 오브젝트 배치결과
    // kRecv.m_nOK; // 성공유무
    //     0, 성공
    //     1, 현재 있는 아지트가 내 아지트가 아님.
    //     2, 배치하려는 오브젝트 아이템이 인벤토리에 없음.
    //     3, 오브젝트 아이템이 아님.
    //     4, 오브젝트 배치할 아지트 정보가 없음.
    //     5, 오브젝트 배치 DB처리 실패.
    // kRecv.m_dwAgitUID; // 아지트UID
    // kRecv.m_vecObject; // 오브젝트 배치정보

    switch( kRecv.m_nOK )
    {
    case 0:
        break;

    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_OBJECT_POS_SAVE_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_OBJECT_POS_SAVE_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_OBJECT_POS_SAVE_FAIL3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_OBJECT_POS_SAVE_FAIL4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_OBJECT_POS_SAVE_FAIL5 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true);
        }
        break;
    }

    if( kRecv.m_nOK != 0 )
    {
        // 다 회수 하고 에디트 이전 위치로 돌립니다. 
        SiKGCAgitGameManager()->RollBackBeforeEdit();
}
}

void On_EVENT_CHANGE_AGIT_OBJECT_POS_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHANGE_AGIT_OBJECT_POS_BROAD );
    SAFE_DELETE(pkBuff);
    // 오브젝트 배치변경 알림
    // kRecv.m_dwAgitUID; // 아지트UID
    // kRecv.m_vecObject; // 오브젝트 배치정보

    if( SiKGCAgitGameManager()->GetAgitInfo().m_dwUID != kRecv.m_dwAgitUID ) {
        // 올바른 아지트가 아님.
        return;
    }

    SiKGCAgitGameManager()->UpdateAgitObjectPos( kRecv.m_vecObject );
}

void On_EVENT_AGIT_FRIEND_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSimpleAgitPageList );
    SAFE_DELETE(pkBuff);
    // 친구아지트 리스트 전달
    // kRecv.m_dwUserUID : 유저UID
    // kRecv.m_mapPageList : map[PageNum, vector[KAgitPageInfo] ]

    std::vector<KAgitPageInfo> vecAgitInfo;
    
    std::map<int,KSerBuffer>::iterator pos = kRecv.m_mapPageList.begin();
    std::map<int,KSerBuffer>::iterator end = kRecv.m_mapPageList.end();

    for( ; pos != end; ++pos )
    {
        std::vector<KAgitPageInfo> vecPage;

        KSerBuffer buffer = pos->second;
        buffer.UnCompress();

        ks.BeginReading( &buffer );
        ks.Get( vecPage );
        ks.EndReading();

        std::copy( vecPage.begin(), vecPage.end(), std::back_inserter( vecAgitInfo ));
    }
    
    g_pkAgitOverlayUI->SetFriendAgitList( vecAgitInfo );
}

void On_EVENT_AGIT_TOP_RANK_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSimpleAgitPageList );
    SAFE_DELETE(pkBuff);
    // 인기아지트 리스트 전달
    // kRecv.m_dwUserUID : 유저UID
    // kRecv.m_mapPageList : map[PageNum, vector[KAgitPageInfo] ]


    std::vector<KAgitPageInfo> vecAgitInfo;

    std::map<int,KSerBuffer>::iterator pos = kRecv.m_mapPageList.begin();
    std::map<int,KSerBuffer>::iterator end = kRecv.m_mapPageList.end();

    for( ; pos != end; ++pos )
    {
        std::vector<KAgitPageInfo> vecPage;

        KSerBuffer buffer = pos->second;
        buffer.UnCompress();

        ks.BeginReading( &buffer );
        ks.Get( vecPage );
        ks.EndReading();

        std::copy( vecPage.begin(), vecPage.end(), std::back_inserter( vecAgitInfo ));
    }

    g_pkAgitOverlayUI->SetRankAgitList( vecAgitInfo );
}

void On_EVENT_AGIT_FAVORITE_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSimpleAgitPageList );
    SAFE_DELETE(pkBuff);
    // 아지트 즐겨찾기 리스트 전달
    // kRecv.m_dwUserUID : 유저UID
    // kRecv.m_mapPageList : map[PageNum, vector[KAgitPageInfo] ]


    std::vector<KAgitPageInfo> vecAgitInfo;

    std::map<int,KSerBuffer>::iterator pos = kRecv.m_mapPageList.begin();
    std::map<int,KSerBuffer>::iterator end = kRecv.m_mapPageList.end();

    for( ; pos != end; ++pos )
    {
        std::vector<KAgitPageInfo> vecPage;

        KSerBuffer buffer = pos->second;
        buffer.UnCompress();

        ks.BeginReading( &buffer );
        ks.Get( vecPage );
        ks.EndReading();

        std::copy( vecPage.begin(), vecPage.end(), std::back_inserter( vecAgitInfo ));
    }

    g_pkAgitOverlayUI->SetFavoriteAgitList( vecAgitInfo );
}

void On_EVENT_AGIT_ADD_FAVORITE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KAgitAddFavoriteAck );
    SAFE_DELETE(pkBuff);
    // 아지트 즐겨찾기 추가결과
    // kRecv.m_nOK : 성공유무
    //     0: 성공
    //     1: 내 아지트를 즐겨찾기할 수 없음.
    //     2: 즐겨찾기할 아지트 정보가 없다.
    //     3: 내 아지트 정보가 없다.
    //     4: 이미 즐겨찾기에 등록된 아지트.
    //     5: 더이상 즐겨찾기에 등록할 수 없음.
    //     6: 즐겨찾기 추가 DB작업 실패.
    // kRecv.m_kAgitInfo : 추가된 아지트정보

    switch( kRecv.m_nOK )
    {
    case 0:
        g_pkChatManager->AddChatMsg( g_pkStrLoader->GetString( STR_ID_ADD_FAVORITE_AGIT_SUCCESS ) );
        break;

    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ADD_FAVORITE_AGIT_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ADD_FAVORITE_AGIT_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ADD_FAVORITE_AGIT_FAIL3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ADD_FAVORITE_AGIT_FAIL4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ADD_FAVORITE_AGIT_FAIL5 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ADD_FAVORITE_AGIT_FAIL6 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true);
        }
        break;
    }
}

void On_EVENT_AGIT_REMOVE_FAVORITE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KAgitUserParamAck );
    SAFE_DELETE(pkBuff);
    // 아지트 즐겨찾기 제거결과
    // kRecv.m_nOK : 성공유무
    //     0: 성공
    //     7: 즐겨찾기 목록에 없음.
    //     8: 즐겨찾기 제거 DB작업 실패.
    // kRecv.m_dwAgitUID : 제거된 아지트UID

    switch( kRecv.m_nOK )
    {
    case 0:
        //	리스트 갱신
        g_pkAgitOverlayUI->ReqUpdateFavorityPage();
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_REMOVE_FAVORITE_AGIT_FAIL1 ),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );		
        break;
    case 8:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_REMOVE_FAVORITE_AGIT_FAIL2 ),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true);
        }
        break;
    }
}

void On_EVENT_REGISTER_AGIT_PAGE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KRegisterAgitPageAck );
    SAFE_DELETE(pkBuff);
    // 아지트 리스트에 등록결과
    // kRecv.m_nOK :  성공 유무
    //     0 : 성공
    //     1 : 자기 아지트에서만 아지트 페이지에 등록할 수 있음.
    //     2 : 페이지에 등록하려는 아지트 정보가 없음.
    //     3 : 이미 페이지에 등록되어 있음.
    //     4 : 페이지 등록중 DB처리 실패.
    //     5 : 페이지 등록중 서버처리 실패.
    // kRecv.m_usRoomID : 내아지트의 페이지 RoomID
    // kRecv.m_kAgitOption : 변경된 아지트 옵션

    switch( kRecv.m_nOK )
    {
    case 0:
        // 성공했으면 정보 창 갱신
        g_pkAgitOverlayUI->UpdateAgitInfo();
        break;

    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_REGISTER_AGIT_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_REGISTER_AGIT_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 3:
//      g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_REGISTER_AGIT_FAIL3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_REGISTER_AGIT_FAIL4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_REGISTER_AGIT_FAIL5 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true);
        }
        break;
    }
}

void On_EVENT_UNREGISTER_AGIT_PAGE_ACK( WPARAM wParam, LPARAM lParam )
{
    // 아지트 리스트에 등록해제알림.
}

void On_EVENT_AGIT_PAGE_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KAgitPageList );
    SAFE_DELETE(pkBuff);
    // 아지트 리스트 페이지 전달
    // kRecv.m_nSID : 아지트 채널ID
    // kRecv.m_bOpen: 공개만 보기
    // kRecv.m_bNotFull: 꽉차지않은것만 보기
    // kRecv.m_usMinUser: n명 이상 보기(기본값:0)
    // kRecv.m_usPageNum: 현재 페이지
    // kRecv.m_usMaxPageNum: 최대 페이지
    // kRecv.m_buffCompList: std::vector<KAgitPageInfo>

    std::vector<KAgitPageInfo> vecPage;
    kRecv.m_buffCompList.UnCompress();
    ks.BeginReading( &kRecv.m_buffCompList );
    ks.Get( vecPage );
    ks.EndReading();

    g_pkAgitOverlayUI->ShowAgitList( true );
    g_pkAgitOverlayUI->SetRegisterAgitList( kRecv, vecPage );
}

void On_EVENT_BROWNIE_STORE_CATALOG_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BROWNIE_STORE_CATALOG_ACK );
    SAFE_DELETE( pkBuff );
    // 도우미상점 아이템 리스트
    // kRecv : std::map<PAIR_USHORT_DWORD,KManufactureItem>
    // kRecv.m_mapItemList : 상점아이템 리스트 map[ pair[Index,ItemID], ItemInfo ]  std::map<PAIR_USHORT_DWORD,KManufactureItem>
    // kRecv.m_mapItemPos : 상점아이템 배치좌표 map[ pair[Index,ItemID], pair[x,y] ] std::map<PAIR_USHORT_DWORD,PAIR_INT>
}

void On_EVENT_BROWNIE_STORE_MATERIAL_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BROWNIE_STORE_MATERIAL_ACK );
    SAFE_DELETE( pkBuff );
    // 도우미상점 아이템 구매조건
    // kRecv : std::map<PAIR_USHORT_DWORD,std::vector<KDropItemInfo> >
    // map[ [Index,ItemID], 구매조건 ]
}

void On_EVENT_BUY_FOR_BROWNIE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BUY_FOR_BROWNIE_ACK );
    SAFE_DELETE( pkBuff );
    // 아지트상점 아이템 구매결과
    // kRecv.m_nOK : 구매 결과
    //     0 : 성공.
    //     1 : 구매 아이템 정보가 없음.
    //     2 : 구매 아이템 재료정보가 없음.
    //     3 : 구매 재료 아이템이 인벤에 없음.
    //     4 : 구매재료 영구아이템이 없음.
    //     5 : 구매재료 수량아이템의 수량이 부족함.
    //     9 : DB작업중 아이템 넣기 실패.
    //    11 : DB작업중 아지트 아이템 설정 실패.
    //   -98 : 아직 처리중인 작업
    // kRecv.m_nGP : 현재GP량(사용안함)
    // kRecv.m_vecRewards : 획득 아이템
    // kRecv.m_vecCountMaterialItems : 소모된 수량 아이템
    // kRecv.m_vecPeriodMaterialItems : 소모된 영구 아이템
}

void On_EVENT_EQUIP_BROWNIE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEquipBrownieAck );
    SAFE_DELETE( pkBuff );
    // 도우미 장착아이템 변경결과
    // kRecv.m_nOK : 구매 결과
    //     0 : 성공.
    //     1 : 자기 아지트에서만 도우미 정보 변경 가능함.
    //     2 : 도우미 장착아이템이 인벤토리에 없음.
    //     3 : 장착아이템이 도우미 아이템이 아님.
    //     4 : 도우미 정보수정할 아지트정보가 없음.
    //     5 : 보유하지 않은 도우미.
    //     6 : 도우미 정보수정 DB작업 실패.
    // kRecv.m_kEquip : 도우미 장착아이템
    // kRecv.m_kBrownieInfo : 도우미 정보
}

void On_EVENT_CHANGE_BROWNIE_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHANGE_BROWNIE_BROAD );
    SAFE_DELETE( pkBuff );
    // 아지트 도우미 변경 알림
    // kRecv.m_dwAgitUID : 아지트UID
    // kRecv.m_kBrownieInfo : 변경된 도우미 정보
}

void On_EVENT_WATERING_FAIRY_TREE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KWateringFairyTreeAck );
    SAFE_DELETE( pkBuff );
    // 아지트 요정의나무 물주기 결과
    // kRecv.m_nOK : 성공유무
    //     0 : 성공
    //     1 : 자기 아지트에서만 요정의 나무 물주기 가능.
    //     2 : 물주기 진행할 아지트 정보가 없음.
    //     3 : 요정의나무 경험치 획득 실패
    //     4 : 요정의나무 레벨 증가 실패
    //     5 : 요정의나무 물주기 DB작업 실패.
    // kRecv.m_kFairyTree : 요정의 나무 정보
    switch( kRecv.m_nOK )
    {
    case 0:
        // 새로 받은 정보로 요정의나무 다시 세팅해 줍시다 
        SiKGCAgitGameManager()->SetFairyTreeInfo( kRecv.m_kFairyTree );
        break;

    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
        break;
    }
}

void On_EVENT_CHANGE_FAIRY_TREE_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHANGE_FAIRY_TREE_BROAD );
    SAFE_DELETE( pkBuff );
    // 아지트 요정의나무 변경 알림
    // kRecv.m_dwAgitUID : 아지트UID
    // kRecv.m_kFairyTree : 변경된 요정의나무 정보

    SiKGCAgitGameManager()->SetFairyTreeInfo( kRecv.m_kFairyTree, kRecv.m_dwAgitUID );
}

void On_EVENT_FAIRY_TREE_BUFF_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KFairyTreeFruitBuff );
    SAFE_DELETE( pkBuff );
    // 아지트 요정의나무 열매버프 알림
    // kRecv.m_nFruitType : 열매타입
    //     KFairyTreeConfig::FBT_NONE     = 0, // 없음
    //     KFairyTreeConfig::FBT_EXP      = 1, // Exp (서버)
    //     KFairyTreeConfig::FBT_GP       = 2, // GP (서버)
    //     KFairyTreeConfig::FBT_ATK      = 3, // 공격력
    //     KFairyTreeConfig::FBT_DEF      = 4, // 방어력
    //     KFairyTreeConfig::FBT_HP       = 5, // 생명력
    //     KFairyTreeConfig::FBT_BUFF_ALL = 6, // 공방생
    //     KFairyTreeConfig::FBT_EXP_GP   = 7, // Exp, GP
    // kRecv.m_fBuffRate : 버프효과 증가량(%)
    // kRecv.m_tmBuffTime : 버프적용되는 날짜

    SiKGCAgitGameManager()->SetFairyTreeBuffInfo( kRecv );
}

void On_EVENT_USE_FAIRY_TREE_FRUIT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KUseFairyTreeFruitAck );
    SAFE_DELETE( pkBuff );
    // 아지트 요정의나무 열매먹기 결과
    // kRecv.m_nOK : 성공여부
    //     1 : 자기 아지트에서만 요정의나무 열매먹기 가능.
    //     2 : 열매먹기 진행할 아지트 정보가 없음.
    //     3 : 이미 열매를 먹었음.
    //     4 : 먹을 수 있는 열매가 없음.
    //     5 : 열매먹기 DB작업 실패.
    // kRecv.m_kFruitBuff : 열매버프 정보

    switch( kRecv.m_nOK )
    {
    case 0:
        SiKGCAgitGameManager()->SetFairyTreeBuffInfo( kRecv.m_kFruitBuff );
        SiKGCAgitGameManager()->SetFairyTreeBuff();
        g_KDSound.Play( "984037" );
        break;

    case 1:
        break;

    case 2:
        break;

    case 3:
        break;

    case 4:
        break;

    case 5:
        break;
    }
}

void On_EVENT_FAIRY_TREE_LV_TABLE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_FAIRY_TREE_LV_TABLE_ACK );
    SAFE_DELETE( pkBuff );
    // 요정의나무 레벨별 누적경험치 테이블 map[Lv,Exp시작값]
    // kRecv : std::map<int,DWORD>

    SiKGCAgitGameManager()->SetFairyTreeLevelTable( kRecv );
}

void On_EVENT_AGIT_INIT_SEED_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KAgitBonusDrop );
    SAFE_DELETE( pkBuff );
    // 일일 씨앗개수 초기화 아이템지급 알림
    // kRecv.m_tmDropTime : 지급받은 시간
    // kRecv.m_nDropCount : 지급받은 수량
    // kRecv.m_vecItem : 지급할 보상 아이템.리스트.

    g_pItemMgr->SetDurationItem( kRecv.m_vecItem );
    g_pkAgitOverlayUI->UpdateMoneyInfo();

}
void On_EVENT_AGIT_VISITER_COUNT_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_AGIT_VISITER_COUNT_BROAD );
    SAFE_DELETE( pkBuff );
    // 아지트 방문자수 갱신 알림
    // kRecv.m_dwAgitUID : 아지트UID
    // kRecv.m_nTodayVisiterCount : 금일 방문자수
    // kRecv.m_nTotalVisiterCount : 전체 방문자수
    SiKGCAgitGameManager()->UpdateAgitVisitorCount( kRecv );

}
void On_EVENT_DROP_FLOWER_POT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KAddItemAck );
    SAFE_DELETE( pkBuff );
    // 집크기에 따른 기본화분 추가지급
    // kRecv.m_vecAddItem : 지급된 아이템

    // 내껀가??
    if( kRecv.m_dwUserUID != g_kGlobalValue.m_kUserInfo.dwUID )
        return;

    // 아이템 추가 
    for( std::vector<KItem>::iterator it = kRecv.m_vecAddItem.begin() ; it != kRecv.m_vecAddItem.end() ; ++it )
    {
        g_pItemMgr->m_kInventory.AddItem( *it, true);
}

    SiKGCAgitGameManager()->RefreshInvenObject();
}

void On_EVENT_AGIT_TUTORIAL_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_AGIT_TUTORIAL_ACK );
    SAFE_DELETE( pkBuff );
    // 아지트 튜토리얼 아이템 전달
    // kRecv.m_nOK : 결과
    //     0 : 성공
    //     1 : 이미 아지트 튜토리얼을 진행했음.
    //     2 : 아지트 튜토리얼용 아이템 DB지급 실패.
    // kRecv.m_vecItem : 지급받은 아이템


    if(kRecv.m_nOK == 0)
    {
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecItem , true);
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        for(std::vector<KItem>::iterator vIt = kRecv.m_vecItem.begin(); vIt != kRecv.m_vecItem.end();vIt++)
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, vIt->m_ItemID, 0, false, true );
}

        //	아지트 가구 인벤 및 씨앗 정보 갱신
        SiKGCAgitGameManager()->RefreshInvenObject();
        g_pkAgitOverlayUI->UpdateMoneyInfo();
    }

}

void On_EVENT_AGIT_TUTORIAL_DONE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( bool );
    SAFE_DELETE( pkBuff );
    // 아지트 튜토리얼 진행여부
    // kRecv : true 진행했음 / false 진행한적 없음.

    g_kGlobalValue.m_kLoginInfo.bGuideAzit = kRecv;
    if(false == g_kGlobalValue.m_kLoginInfo.bGuideAzit)
        KP2P::GetInstance()->Send_AgitTutorialReq();
}

void On_EVENT_INVITE_AGIT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KInviteAgitNot );
    SAFE_DELETE( pkBuff );
    // 아지트 초대 알림
    // kRecv.m_dwAgitUID : 초대할 아지트UID
    // kRecv.m_strOwnerNick : 초대한 유저의 닉네임
    // kRecv.m_dwUserUID : 초대대상 유저UID
    // kRecv.m_ucAgitOpenType : 오픈타입(0:비공개,1:공개)
    // kRecv.m_strAgitPassword : 패스워드
    // kRecv.m_bIsOwnerInvite : 아지트주인이 초대했는지(true:아지트주인이초대,false:손님이초대)

    // 초대 승낙할 경우, P2P의 Send_EnterAgitReq()를 호출해서 입장 진행하면 됨.

    // 아지트가 아닌 다른 게임 플레이 중일 때는 띄우지 않는다. 
    if( g_MyD3D->m_pStateMachine->GetState() == GS_GAME &&
        SiKGCRoomManager()->GetGameModeCategory() != GC_GMC_AGIT )
        return;

    if ( g_MyD3D->m_pStateMachine->GetState() == GS_MATCH &&
        (SiKGCMatchManager()->GetCurrentState() != KGCMatchManager::MSTATE_NONE && 
        SiKGCMatchManager()->GetCurrentState() != KGCMatchManager::MSTATE_READY_STATE ))
        return;

    // 강화 / 제작 / 해체중에도 뜨지 않도록 합니다. - 진행중 이동하면 문제 생길 위험 있음 
    if( g_pkUIScene->GetStateUI( KGCUIScene::GC_MBOX_NEW_NECKLACE_ENCHANT_DLG ) == KD3DWnd::D3DWS_ENABLED ||
        g_pkUIScene->GetStateUI( KGCUIScene::GC_MBOX_FORGE_DLG ) == KD3DWnd::D3DWS_ENABLED ||
        g_pkUIScene->GetStateUI( KGCUIScene::GC_MBOX_ENCHANT_S6_DLG ) == KD3DWnd::D3DWS_ENABLED ||
        g_pkUIScene->GetStateUI( KGCUIScene::GC_MBOX_ENCHANT_SUB_S6_DLG ) == KD3DWnd::D3DWS_ENABLED )
	{ 
            return;
	}

    // 강화 / 제작 / 해체 외에는 닫아줍니다. 
    g_pkUIScene->DestroyCurrentMsgBox();
    g_pkUIScene->DeleteAllWaitMsgBox();

    SiKGCAgitGameManager()->SetInviteAgitInfo(kRecv);
    //if(g_pkUIScene->IsRenderOn(KGCUIScene::GC_MBOX_DEPOT)){
    if( g_pkUIScene->GetCurMsgBox()->IsRenderOn() ) {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_YES_NO, 
            g_pkStrLoader->GetReplacedString( STR_ID_AGIT_INVITE_MESSAGE,  "l", kRecv.m_strOwnerNick ), L"",
            KGCUIScene::GC_MBOX_USE_INVITE_AGIT_MESSAGE, 0, 0, true, false, false, false );
        return;
    }
    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_YES_NO, 
        g_pkStrLoader->GetReplacedString( STR_ID_AGIT_INVITE_MESSAGE,  "l", kRecv.m_strOwnerNick ), L"",
        KGCUIScene::GC_MBOX_USE_INVITE_AGIT_MESSAGE, 0, 0, true, true, false, false );
}

void On_EVENT_GUESTBOOK_PAGE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KGuestBookPageList );
    SAFE_DELETE( pkBuff );
    // 낙서장 페이지 리스트 전달
    // kRecv.m_nOK; // 성공유무
    //     0 : 성공
    //     1 : 아지트 상태가 아님
    //     2 : 해당 아지트 정보가 없음
    // kRecv.m_dwAgitUID; // 아지트UID
    // kRecv.m_dwUserUID; // 유저UID
    // kRecv.m_buffCompList; // std::map<int,KGuestMsg>

    // 현재 아지트??
    if( SiKGCAgitGameManager()->GetAgitUID() != kRecv.m_dwAgitUID )
        return;

    Result_AgitGuestbookPage = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0:
        {
            std::map<int,KGuestMsg> mapMsg; // map[글번호,방명록글내용]
            kRecv.m_buffCompList.UnCompress();
            ks.BeginReading( &kRecv.m_buffCompList );
            ks.Get( mapMsg );
            ks.EndReading();

            g_pkAgitOverlayUI->SetGuestBookInfo( mapMsg );
        }
        break;

    case 1:
        break;

    case 2:
        break;
    }
}

void On_EVENT_GUESTBOOK_WRITE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KAgitUserParamAck );
    SAFE_DELETE( pkBuff );
    // 낙서장 글쓰기 결과
    // kRecv.m_nOK; // 성공유무
    //     0 : 성공
    //     1 : 아지트 상태가 아님.
    //     2 : 아지트 정보가 없음.
    //     3 : 낙서장에 추가할 글 내용이 비었음.
    //     4 : 낙서장에 추가할 글 길이가 제한보다 길다.
    //     5 : 낙서장에 추가할 글에 불량단어가 포함되어 있음.
    //     6 : 낙서장 새글쓰기 DB처리 실패.
    //    10 : 낙서장 글쓰기 시간주기가 짧다.
    //    11 : 낙서장 일일 쓰기제한.
    // kRecv.m_dwAgitUID; // 아지트UID
    // kRecv.m_dwUserUID; // 유저UID

    // 현재 아지트??? 
    if( SiKGCAgitGameManager()->GetAgitUID() != kRecv.m_dwAgitUID )
        return;

    // 에러만 처리해 주셍 
    switch( kRecv.m_nOK )
    {
    case 0:
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_WRITE_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_WRITE_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_WRITE_FAIL3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_WRITE_FAIL4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_WRITE_FAIL5 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_WRITE_FAIL6 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 10:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_WRITE_FAIL7 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 11:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_WRITE_FAIL8 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true);

        }
    }
}

void On_EVENT_GUESTBOOK_WRITE_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KGuestBookWriteBroad );
    SAFE_DELETE( pkBuff );
    // 낙서장 새글 알림
    // kRecv.m_dwAgitUID; // 아지트UID
    // kRecv.m_nNo; // 새글의 번호
    // kRecv.m_kGuestMsg; // 새글 정보

    // 현재 아지트???
    if( SiKGCAgitGameManager()->GetAgitUID() != kRecv.m_dwAgitUID )
        return;

    g_pkAgitOverlayUI->AddNewGuestbookMsg( kRecv.m_nNo, kRecv.m_kGuestMsg );
}

void On_EVENT_GUESTBOOK_DELETE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KAgitUserParamAck );
    SAFE_DELETE( pkBuff );
    // 낙서장 글삭제 결과
    // kRecv.m_nOK; // 성공유무
    //     0 : 성공
    //     1 : 아지트 상태가 아님.
    //     2 : 아지트 정보가 없음.
    //     7 : 낙서장 삭제할 글번호가 비어있음.
    //     8 : 아지트 주인이 아닌데 다른 사람의 낙서장 글을 삭제하려고 함.
    //     9 : 낙서장 글삭제 DB처리 실패.
    // kRecv.m_dwAgitUID; // 아지트UID
    // kRecv.m_dwUserUID; // 유저UID

    // 현재 아지트??
    if( SiKGCAgitGameManager()->GetAgitUID() != kRecv.m_dwAgitUID )
        return;

    // 에러만 처리해영
    switch( kRecv.m_nOK )
    {
    case 0:
        break;

    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_WRITE_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_WRITE_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_DELETE_FAIL7 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 8:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_DELETE_FAIL8 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 9:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_DELETE_FAIL9 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true);

        }
    }
}

void On_EVENT_GUESTBOOK_DELETE_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KGuestBookDeleteBroad );
    SAFE_DELETE( pkBuff );
    // 낙서장 글삭제 알림
    // kRecv.m_dwAgitUID; // 아지트UID
    // kRecv.m_setDeleteNo; // 지워진 글번호 std::set<int>

    // 현재 아지트??
    if( SiKGCAgitGameManager()->GetAgitUID() != kRecv.m_dwAgitUID )
        return;

    g_pkAgitOverlayUI->DeleteGuestBookMsg( kRecv.m_setDeleteNo );

}

void On_EVENT_STRENGTH_MATERIAL_INFO( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_STRENGTH_MATERIAL_INFO );
    SAFE_DELETE( pkBuff );
    /*
    kPacket_.m_dwDefaultMaterialIValue; // 강화 젬 소비 비용 배율정보.
    kPacket_.m_dwBreakUpMaterialValue;  // 해체 젬 소비 비용 배율정보.
    kPacket_.m_dwNormalMinLevel;  // 일반 강화석 재료 최소레벨.
    kPacket_.m_dwEpicMinLevel;    // 에픽 강화석 재료 최소레벨.
    kPacket_.m_mapStrengthMaterialInfo; // 주문서 아이템 정보.


    enum STRENGTH_TYPE
    {
        ST_STRENGTH     = 0, // 강화.
        ST_BREAKUP      = 1, // 해체.
        ST_COMPOSE      = 2, // 합성.
        ST_MAX,
    };
    enum ASSIST_TYPE
    {
    AT_NOUSE    = 0,
    AT_UPGRADE  = 1, // 강화률 상승 아이템 사용.
    AT_NOBREAK  = 2, // 파괴 방지 아이템 사용.
    AT_SPECIFIC = 3, // 특정 레벨 강화 아이템 사용.
    AT_RANDOM   = 4, // 랜덤 레벨 강화 아이템 사용.
    RT_MAX,
    };
    { { 강화, 강화상승 }, set<ItemID> }
    { { 강화, 파괴방지 }, set<ItemID> }
    { { 강화, 특정레벨강화 }, set<ItemID> }
    { { 해체, 주문서 }, set<ItemID> }
    { { 합성, 주문서 }, set<ItemID> }
    */
    if ( g_pkUIScene->m_pkEnchantSubS6Dlg )
    {
        g_pkUIScene->m_pkEnchantSubS6Dlg->SetMaterialInfo(kRecv);
    }
}

void On_EVENT_STRENGTH_EQUIP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_STRENGTH_EQUIP_ACK );
    SAFE_DELETE( pkBuff );
    /*
    kPacket_.m_nOK = 0 // 성공
    kPacket_.m_nOK = 1 // 해당 아이템 인벤토리에 없음.
    kPacket_.m_nOK = 2 // 강화석이 이미 사용중임.
    kPacket_.m_nOK = 3 // 스킬 갯수가 정의되지 않았음.
    kPacket_.m_nOK = 4 // 강화석 장착할 아이템이 영구 아이템이 아니다.
    kPacket_.m_nOK = 5 // pc방 아이템은 이용할 수 없습니다.
    kPacket_.m_nOK = 6 // 스킬 가져오기 실패.
    kPacket_.m_nOK = 7 // 강화석 장착못하는 아이템.
    kPacket_.m_nOK = -98 // 아직 처리중인 작업입니다.
    */
    // 강화석 변경 정보는 kPacket_.m_kStrengthItem 이 값에 저장되어 있음.
    
    
    switch(kRecv.m_nOK)
    {
    case 0:        
        {
            std::vector<KItem> vecItem;
            vecItem.push_back(kRecv.m_kEquipItem);
            vecItem.push_back(kRecv.m_kStrengthItem);

            g_pItemMgr->m_kInventory.AddItemList( vecItem, true);
            kRecv.m_kEquipItem.m_ItemID /= 10;

            g_pkUIScene->m_pkEnchantSubS6Dlg->SetResultEquip();

        }        
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_EQUIP_EMPTY ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );        
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_01 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_02 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_03 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_19 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_20 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_21 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PACKET_DELAY ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true);

        }
        break;
    }

    if( kRecv.m_nOK != 0 )
    {
        g_pkUIScene->m_pkEnchantSubS6Dlg->LockUI( false );
    }

}

void On_EVENT_STRENGTH_ACTION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_STRENGTH_ACTION_ACK );
    SAFE_DELETE( pkBuff );
    /*
    kPacket_.m_nOK = 0     // 성공
    kPacket_.m_nOK = 1     // 해당 아이템 인벤토리에 없음.
    kPacket_.m_nOK = 2     // 잘못된 강화석 ItemID.
    kPacket_.m_nOK = 3     // 강화 재료의 레벨이 낮음.
    kPacket_.m_nOK = 4     // 정의되지 않은 강화률 상승 아이템.
    kPacket_.m_nOK = 5     // 스크립트에 정의 되지 않은 강화 아이템의 레벨.
    kPacket_.m_nOK = 6     // 강화할려는 레벨의 확률 설정 에러.
    kPacket_.m_nOK = 7     // 설정되지 않은 특정 레벨 강화 부적.
    kPacket_.m_nOK = 8     // 특정 레벨 강화보다 현재 아이템 레벨이 같거나 높음.
    kPacket_.m_nOK = 9     // 강화석 DB 강화 에러.
    kPacket_.m_nOK = 10    // 강화석 재료 아이템 DB 삭제중 에러.
    kPacket_.m_nOK = 11    // 강화석 보조 아이템 DB 삭제중 에러.
    kPacket_.m_nOK = 12    // pc방 아이템은 재료로 사용할 수 없습니다.
    kPacket_.m_nOK = 13    // 스킬 갯수가 정의되지 않았음.
    kPacket_.m_nOK = 14    // 스킬 가져오기 실패.
    kPacket_.m_nOK = 15    // 강화석 보조 아이템 Type 설정 에러.
    kPacket_.m_nOK = 16    // 기간제 아이템이면 안됨.
    kPacket_.m_nOK = 17    // 보유 GP가 부족함.
    kPacket_.m_nOK = 18    // 강화로 요청한 아이템의 타입이 비정상적임.
    kPacket_.m_nOK = -98   // 아직 처리중인 작업입니다.

    // 강화 성공시에 강화 결과값에 대한 정의
    kPacket_.m_dwStrengthResult = 1, // 성공
    kPacket_.m_dwStrengthResult = 2, // 하락
    kPacket_.m_dwStrengthResult = 3, // 깨짐
    kPacket_.m_dwStrengthResult = 4, // 제자리
    kPacket_.m_dwStrengthResult = 5, // 초기화
    kPacket_.m_dwStrengthResult = 6, // 에픽강화석 변화.
    kPacket_.m_dwStrengthResult = 7, // 특정 레벨 변화
    };
    */
    // 강화석 변경 정보는 kPacket_.m_kStrengthItem 이 값에 저장되어 있음.
    std::vector<KItem> vecItem;
    switch(kRecv.m_nOK)
    {
    case 0:
        {
            vecItem.push_back(kRecv.m_kStrengthItem);
            vecItem.push_back(kRecv.m_kEquipItem);

            g_pItemMgr->m_kInventory.AddItemList( vecItem, true );

            //소모된 수량 아이템 갱신O
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecUseCountItem, true );

            // 소모된 영구아이템 삭제
            for( int i = 0; i < static_cast<int>(kRecv.m_vecUsePeriodItems.size()); i++ )
            {
                g_pItemMgr->m_kInventory.RemoveItem( kRecv.m_vecUsePeriodItems[i] );
                g_pItemMgr->RemoveInventoryItemList( kRecv.m_vecUsePeriodItems[i] );
            }

            g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nGP );
                
            Result_EhcnatSystem = kRecv.m_dwStrengthResult;

            if( kRecv.m_dwStrengthResult == 1 || kRecv.m_dwStrengthResult == 6 || kRecv.m_dwStrengthResult == 7 )
                g_pkUIScene->m_pkEnchantSubS6Dlg->RenderParticle(true);
            else
                g_pkUIScene->m_pkEnchantSubS6Dlg->RenderParticle(false);


            // 장착된 아이템을 갱신한다.
            SCharInfo& sCharInfo = g_kGlobalValue.m_kUserInfo.GetCurrentChar();
            if( g_pItemMgr->CheckEquipItemByItemUID( &sCharInfo, kRecv.m_kEquipItem.m_ItemUID ) )
            {
                for ( int i = 0; i < (int)sCharInfo.vecItemInfo.size(); ++i )
                {
                    if ( sCharInfo.vecItemInfo[i].dwItemUID == kRecv.m_kEquipItem.m_ItemUID )
                    {
                        sCharInfo.vecItemInfo[i] = kRecv.m_kEquipItem;
                        sCharInfo.vecItemInfo[i].iItemID /= 10;
                    }
                }
            }

            g_MyD3D->m_TempPlayer.SetMyPlayer();
            int iIndex = g_MyD3D->Get_MyPlayer();
            if ( iIndex < MAX_PLAYER_NUM && iIndex >= 0 )
            {
                g_MyD3D->MyPlayer[iIndex]->SetMyPlayer();
            }

            
        }        
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ENCHANT_EMPTY ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_04 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_05 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_06 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_08 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_09 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 8:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_10 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 9:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_11 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 10:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_12 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 11:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_13 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 16:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_PERIODITEM_ERROR ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 17:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_COST_GP_ERROR ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case -98:
    default:
        {
            std::wstring strError = g_pkStrLoader->GetString( STR_ID_PACKET_DELAY );
            strError += g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strError, L"", 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        }
        break;
    }

    if( kRecv.m_nOK != 0 )
    {
        g_pkUIScene->m_pkEnchantSubS6Dlg->LockUI( false );
    }

}

void On_EVENT_STRENGTH_BREAKUP_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_STRENGTH_BREAKUP_ACK );
    SAFE_DELETE( pkBuff );
    /*
    kPacket_.m_nOK = 0     // 성공
    kPacket_.m_nOK = 1     // 해당 아이템 인벤토리에 없음.
    kPacket_.m_nOK = 2     // 등록되지 않은 아이템 해체 주문서.
    kPacket_.m_nOK = 3     // 스크립트에 정의 되지 않은 강화 아이템의 레벨.
    kPacket_.m_nOK = 4     // 아이템 제작해제 실패.
    kPacket_.m_nOK = 5     // 강화석 DB 강화 에러.
    kPacket_.m_nOK = 6     // 강화석 재료 아이템 DB 삭제중 에러.
    kPacket_.m_nOK = 7     // 강화석 보조 아이템 DB 삭제중 에러.
    kPacket_.m_nOK = 8     // 기간제 아이템이면 해체 안됨.
    kPacket_.m_nOK = -98   // 아직 처리중인 작업입니다.

    // 해체 성공시에 해체 결과값에 대한 정의
    kPacket_.m_dwStrengthResult = 1, // 성공
    kPacket_.m_dwStrengthResult = 3, // 깨짐
    kPacket_.m_dwStrengthResult = 4, // 제자리
    };
    */
    // 강화석 변경 정보는 kPacket_.m_kStrengthItem 이 값에 저장되어 있음.
    std::vector<KItem> vecItem;
    switch(kRecv.m_nOK)
    {
    case 0:
        {
            vecItem.push_back(kRecv.m_kStrengthItem);
            vecItem.push_back(kRecv.m_kEquipItem);

            g_pItemMgr->m_kInventory.AddItemList( vecItem, true );

            //소모된 수량 아이템 갱신
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecUseCountItem, true );

            // 소모된 영구아이템 삭제
            for( int i = 0; i < static_cast<int>(kRecv.m_vecUsePeriodItems.size()); i++ )
            {
                g_pItemMgr->m_kInventory.RemoveItem( kRecv.m_vecUsePeriodItems[i] );
                g_pItemMgr->RemoveInventoryItemList( kRecv.m_vecUsePeriodItems[i] );
            }

            
            if( kRecv.m_dwBreakUpResult == 1 )
            {
                g_pkUIScene->m_pkEnchantSubS6Dlg->RenderParticle( true );
            }
            else
            {
                g_pkUIScene->m_pkEnchantSubS6Dlg->RenderParticle( false );
            }

            Result_EhcnatSystem = kRecv.m_dwBreakUpResult;

        }        
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_00 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_14 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_07 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_15 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_11 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_12 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_13 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 8:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_PERIODITEM_ERROR ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PACKET_DELAY ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
        }
        break;
    }

    if( kRecv.m_nOK != 0 )
    {
        g_pkUIScene->m_pkEnchantSubS6Dlg->LockUI( false );
    }
}

void On_EVENT_STRENGTH_COMPOSE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_STRENGTH_COMPOSE_ACK );
    SAFE_DELETE( pkBuff );
    /*
    kPacket_.m_nOK = 0     // 성공
    kPacket_.m_nOK = 1     // 해당 아이템 인벤토리에 없음.
    kPacket_.m_nOK = 2     // 정의되지 않은 합성 Type.
    kPacket_.m_nOK = 3     // 아이템 합성 실패.
    kPacket_.m_nOK = 4     // 아이템 합성 결과 적용 실패.
    kPacket_.m_nOK = 5     // 강화석 DB 강화 에러.
    kPacket_.m_nOK = 6     // 강화석 재료 아이템 DB 삭제중 에러.
    kPacket_.m_nOK = 7     // 강화석 보조 아이템 DB 삭제중 에러.
    kPacket_.m_nOK = 8     // 기간제 아이템이면 안됨.
    kPacket_.m_nOK = -98   // 아직 처리중인 작업입니다.

    // 해체 결과에 대한 부분은 신경쓰지 않아도 된다.
    */
    // 합성후의 변경된 강화석 정보는 kPacket_.m_kFirstStrengthItem 이 값에 저장되어 있음.
    std::vector<KItem> vecItem;
    switch(kRecv.m_nOK)
    {
    case 0:
        vecItem.push_back(kRecv.m_kFirstStrengthItem);

        g_pItemMgr->m_kInventory.AddItemList( vecItem, true );

        //소모된 수량 아이템 갱신
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecUseCountItem, true );

        // 소모된 영구아이템 삭제
        for( int i = 0; i < static_cast<int>(kRecv.m_vecUsePeriodItems.size()); i++ )
        {
            g_pItemMgr->m_kInventory.RemoveItem( kRecv.m_vecUsePeriodItems[i] );
            g_pItemMgr->RemoveInventoryItemList( kRecv.m_vecUsePeriodItems[i] );
        }

        g_pkUIScene->m_pkEnchantSubS6Dlg->RenderParticle(true);
        g_pkUIScene->m_pkEnchantSubS6Dlg->SetAlchemyResultItem( kRecv.m_kFirstStrengthItem.m_ItemUID );

        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ALCHEMY_EMPTY2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_16 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_17 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_18 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_11 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_12 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_ERROR_13 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case 8:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ENCHANT_SYSTEM_PERIODITEM_ERROR ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PACKET_DELAY ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
        }
        break;
    }

    if( kRecv.m_nOK != 0 )
    {
        g_pkUIScene->m_pkEnchantSubS6Dlg->LockUI( false );
    }

}

void On_EVENT_USE_TRAINING_OBJ_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KUseTrainingObjAck );
    SAFE_DELETE( pkBuff );
    // 훈련장 사용결과
    // kRecv.m_nOK : 성공유무
    //     1 : 내 아지트가 아니다.
    //     2 : 보유중인 캐릭터가 아니다.
    //     3 : 훈련소 아이템이 인벤토리에 없음.
    //     4 : 훈련소 아이템이 아니다.
    //     5 : 재료 아이템이 인벤토리에 없음.
    //     6 : 재료 아이템 수량이 부족함.
    //     7 : 아지트 정보가 없음.
    //     8 : 등록된 훈련소가 아니다.
    //     9 : 훈련할 수 있는 횟수가 없음.
    //     10 : 실제 훈련할 수 있는 횟수가 없음.
    //     11 : 훈련소 사용 DB기록 실패.
    // kRecv.m_dwUserUID : 유저UID (=아지트UID)
    // kRecv.m_nCharType : 훈련시킨 캐릭터
    // kRecv.m_kMaterialItem : 장작 아이템 정보
    // kRecv.m_biExp : 레벨값을 제외하고 계산된 경험치
    // kRecv.m_biTotalExp : 누적 경험치(전체 경험치)
    // kRecv.m_dwOldLevel : 이전 레벨
    // kRecv.m_dwLevel : 현재 레벨
    // kRecv.m_fRewardExp : 획득 경험치
    // kRecv.m_kTrainingObj : 사용한 훈련소 정보
    // kRecv.m_nUseMaterialSize : 사용한 장작개수
    // kRecv.m_kSkillInfo : 스킬포인트 정보

    switch( kRecv.m_nOK )
    {
    case 0:
        {
            // 사용한 장작 깎아 주고 
            KItem* pTile = NULL;
            g_pItemMgr->FindInventoryForItemID( kRecv.m_kMaterialItem.m_ItemID / 10 , &pTile );
            if( NULL != pTile )
                pTile->m_nCount = kRecv.m_kMaterialItem.m_nCount;

            // 해당 캐릭터 정보 바꿔주고 
            int iPlayerIndex = g_MyD3D->Get_MyPlayer();
            if( g_MyD3D->IsPlayerIndex( iPlayerIndex ) )
            {
                for( std::vector< SCharInfo >::iterator it = g_MyD3D->MyPlayer[ iPlayerIndex ]->m_kUserInfo.vecCharInfo.begin() ; it != g_MyD3D->MyPlayer[ iPlayerIndex ]->m_kUserInfo.vecCharInfo.end() ; ++it )
                {
                    if( it->iCharType == kRecv.m_nCharType )
                    {
                        it->iLevel = static_cast<int>( kRecv.m_dwLevel );
                        it->biExp = kRecv.m_biExp;
                        it->kSkillInfo = kRecv.m_kSkillInfo;

                        //if( kRecv.m_dwOldLevel < kRecv.m_dwLevel )
                        //    g_ParticleManager->LevelUpEffect( g_MyD3D->MyPlayer[ iPlayerIndex ]->GetPosition().x, g_MyD3D->MyPlayer[ iPlayerIndex ]->GetPosition().y );
                        
                        g_MyD3D->MyPlayer[ iPlayerIndex ]->UpdateGlobalUserInfo();
                    }
                }
            }

            // 훈련소 정보 갱신 해 주고 
            SiKGCAgitGameManager()->SetTrainingObjInfo( kRecv.m_kTrainingObj, false );
        }
        break;

    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_OBJECT_POS_SAVE_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHARACTER_OPEN_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_USE_TRAINING_OBJ_FAIL3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;
        
    case 4:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_USE_TRAINING_OBJ_FAIL4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_USE_TRAINING_OBJ_FAIL5 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 6:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_USE_TRAINING_OBJ_FAIL6 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 7:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_WRITE_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 8:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_USE_TRAINING_OBJ_FAIL8 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 9:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_USE_TRAINING_OBJ_FAIL9 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 10:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_USE_TRAINING_OBJ_FAIL10 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 11:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_USE_TRAINING_OBJ_FAIL11 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true );
        }
        break;

    }

    Result_UseTrainingObject = kRecv.m_nOK;
}

void On_EVENT_UPDATE_TRAINING_OBJ_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KUpdateTrainingObjBroad );
    SAFE_DELETE( pkBuff );
    // kRecv.m_dwAgitUID : 아지트UID
    // kRecv.m_kObject.m_TrainingObjUID : 훈련소 ItemUID
    // kRecv.m_kObject.m_nAccCount : 현재 쌓인 장작 개수
    // kRecv.m_kObject.m_tmDate : 마지막 갱신시간

    // 현재 아지트??
    if( SiKGCAgitGameManager()->GetAgitUID() != kRecv.m_dwAgitUID )
        return;

    SiKGCAgitGameManager()->SetTrainingObjInfo( kRecv.m_kObject );
}

void On_EVENT_INVEN_BUFF_ITEM_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_INVEN_BUFF_ITEM_LIST_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv : 인벤토리 버프 아이템 리스트 전달 vector[KInvenBuffItem]
    
    g_pItemMgr->SetInventBuffItemList( kRecv );
}

void On_EVENT_OPEN_AGIT_CHARACTER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KOpenAgitCharacterAck );
    SAFE_DELETE( pkBuff );
    // 배치캐릭터 오픈 결과
    // kRecv.m_nOK : 성공유무
    //     0 : 성공
    //     1 : 내 아지트가 아니다.
    //     2 : 보유중인 캐릭터가 아니다.
    //     3 : 오픈하기 위한 별사탕이 인벤에 없음.
    //     4 : 오픈하기 위한 별사탕 수량이 부족함.
    //     5 : 아지트 정보가 없음.
    //     6 : 캐릭터 오픈 DB처리 실패.
    //     7 : 이미 오픈된 캐릭터 타입
    // kRecv.m_dwUserUID : 유저UID(=아지트UID)
    // kRecv.m_nCharType : 오픈할 캐릭터 타입
    // kRecv.m_kFlowerItem : 민들레 아이템정보

    // 현재 아지트 아님 
    if( kRecv.m_dwUserUID != SiKGCAgitGameManager()->GetAgitUID() ) {
        return;
    }

    switch( kRecv.m_nOK ) {
        case 0: 
            {
                // 오픈 시켜주고 
                std::map< int, KAgitCharacterPos > mapCurChar = SiKGCAgitGameManager()->GetCharacterObjInfo();
                KAgitCharacterPos charPos;
                charPos.m_nCharType = kRecv.m_nCharType;
                mapCurChar[ kRecv.m_nCharType ] = charPos;
                SiKGCAgitGameManager()->SetCharacterObject( mapCurChar );

                // 별사탕 갱신
                KItem* pStar = NULL;
                g_pItemMgr->FindInventoryForItemID( kRecv.m_kFlowerItem.m_ItemID / 10, &pStar );
                if( NULL == pStar ) { 
                    return;
                }
                pStar->m_nCount = kRecv.m_kFlowerItem.m_nCount;

                g_pkAgitOverlayUI->UpdatePlaceCollectUI();
                g_pkAgitOverlayUI->UpdateMoneyInfo();
                g_pkAgitOverlayUI->RefreshCharacterTab( true );
            }
            break;

        case 1:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_OBJECT_POS_SAVE_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 2:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHARACTER_OPEN_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 3:
        case 4:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_BUY_AGIT_SHOP_NOT_ENOUGH_STAR ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 5:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_WRITE_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 6:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHARACTER_OPEN_FAIL6 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;
        case 7:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHARACTER_OPEN_FAIL7 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        default:
            {
                std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                    KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true );
            }
            break;
    }
}

void On_EVENT_SET_AGIT_CHARACTER_POS_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSetAgitCharPosAck );
    SAFE_DELETE( pkBuff );
    // 배치캐릭터 위치이동 결과
    // kRecv.m_nOK : 성공유무
    //     0 : 성공
    //     1 : 내 아지트가 아니다.
    //     2 : 보유중인 캐릭터가 아니다.
    //     5 : 아지트 정보가 없음.
    //     13 : 오픈되어있지 않은 캐릭터 타입
    //     14 : DB처리 실패.
    //     18 : 배치캐릭터 최대 배치제한수 초과.
    //     19 : 배치캐릭터 맵정보가 없음
    // kRecv.m_dwAgitUID : 아지트UID
    // kRecv.m_vecCharPos : 배치캐릭터 정보

    // 현재 아지트?
    if( SiKGCAgitGameManager()->GetAgitUID() != kRecv.m_dwAgitUID ) { 
        return;
    }

    switch( kRecv.m_nOK ) {
        case 0:
            SiKGCAgitGameManager()->UpdateAgitCharacterPos( kRecv.m_vecCharPos );
            break;

        case 1:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_OBJECT_POS_SAVE_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 2:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHARACTER_OPEN_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 5:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_WRITE_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 13:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHAR_SET_COORDI_FAIL13 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 14:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHARACTER_SER_POS_FAIL14 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 18:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHARACTER_SER_POS_FAIL18 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            SiKGCAgitGameManager()->UpdateAgitCharacterPos( kRecv.m_vecCharPos );
            break;

        case 19:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHARACTER_SER_POS_FAIL19 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;
        default:
            {
                std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                    KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true );
            }
            break;
    }
}

void On_EVENT_SET_AGIT_CHARACTER_MOTION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSetAgitCharMotionAck );
    SAFE_DELETE( pkBuff );
    // 배치캐릭터 모션변경 결과
    // kRecv.m_nOK : 성공유무
    //     0 : 성공
    //     1 : 내 아지트가 아니다.
    //     2 : 보유중인 캐릭터가 아니다.
    //     5 : 아지트 정보가 없음.
    //     13 : 오픈되어있지 않은 캐릭터 타입
    //     15 : DB처리 실패.
    // kRecv.m_dwAgitUID : 아지트UID
    // kRecv.m_kCharInfo : 배치캐릭터 정보

    // 현재 아지트?
    if( SiKGCAgitGameManager()->GetAgitUID() != kRecv.m_dwAgitUID ) {
        return;
    }

    switch( kRecv.m_nOK ) {
    case 0:
        SiKGCAgitGameManager()->UpdateAgitCharacterInfo( kRecv.m_kCharInfo );
        break;

    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_OBJECT_POS_SAVE_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHARACTER_OPEN_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_WRITE_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 13:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHAR_SET_COORDI_FAIL13 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    case 15:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHAR_ACTION_SET_FAIL15 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
        break;

    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true );
        }
        break;
    }
}

void On_EVENT_SET_AGIT_CHARACTER_COORDI_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSetAgitCharCoordiAck );
    SAFE_DELETE( pkBuff );
    // 배치캐릭터 코디변경 결과
    // kRecv.m_nOK : 성공유무
    //     0 : 성공
    //     1 : 내 아지트가 아니다.
    //     2 : 보유중인 캐릭터가 아니다.
    //     5 : 아지트 정보가 없음.
    //     8 : 장착시킬 코디 아이템을 인벤토리에서 찾을 수 없음.
    //     9 : 장착 요청할 코디정보가 비어있음.
    //     13 : 오픈되어있지 않은 캐릭터 타입
    //     16 : DB처리 실패.
    // kRecv.m_dwAgitUID : 아지트UID
    // kRecv.m_kCharInfo : 배치캐릭터 정보

    // 현재 아지트?
    if( SiKGCAgitGameManager()->GetAgitUID() != kRecv.m_dwAgitUID ) { 
        return;
    }

    switch( kRecv.m_nOK ) {
        case 0:
            SiKGCAgitGameManager()->UpdateAgitCharacterInfo( kRecv.m_kCharInfo );
            break;

        case 1:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_OBJECT_POS_SAVE_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 2:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHARACTER_OPEN_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 5:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_WRITE_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 8:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHAR_SET_COORDI_FAIL8 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 9:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHAR_SET_COORDI_FAIL9 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 13:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHAR_SET_COORDI_FAIL13 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 16:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHAR_SET_COORDI_FAIL16 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        default:
            {
                std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                    KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true );
            }
            break;

    }
}

void On_EVENT_SET_AGIT_CHARACTER_SPEECH_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSetAgitCharSpeechAck );
    SAFE_DELETE( pkBuff );
    // 배치캐릭터 대사변경 결과
    // kRecv.m_nOK : 성공유무
    //     0 : 성공
    //     1 : 내 아지트가 아니다.
    //     2 : 보유중인 캐릭터가 아니다.
    //     5 : 아지트 정보가 없음.
    //     10 : 설정할 대사정보가 비어있음.
    //     11 : 설정할 대사에 사용할 수 없는 단어가 있음.
    //     12 : 설정할 대사 길이가 제한에 걸림.
    //     13 : 오픈되어있지 않은 캐릭터 타입
    //     17 : DB처리 실패.
    // kRecv.m_dwAgitUID : 아지트UID
    // kRecv.m_kCharInfo : 배치캐릭터 정보

    // 현재 아지트?
    if( SiKGCAgitGameManager()->GetAgitUID() != kRecv.m_dwAgitUID ) { 
        return;
    }

    switch( kRecv.m_nOK ) {
        case 0:
            SiKGCAgitGameManager()->UpdateAgitCharacterInfo( kRecv.m_kCharInfo );
            break;

        case 1:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_OBJECT_POS_SAVE_FAIL1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 2:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHARACTER_OPEN_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 5:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_GUESTBOOK_WRITE_FAIL2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 10:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHAR_MENT_SET_FAIL10 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 11:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHAR_MENT_SET_FAIL11 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 12:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHAR_MENT_SET_FAIL12 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 13:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHAR_SET_COORDI_FAIL13 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        case 17:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_AGIT_CHAR_MENT_SET_FAIL17 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );
            break;

        default:
            {
                std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                    KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true );
            }
            break;
    }

}

void On_EVENT_UPDATE_AGIT_CHARACTER_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KUpdateAgitCharBroad );
    SAFE_DELETE( pkBuff );
    // 내가 있는 아지트의 배치캐릭터 상태변경 알림
    // kRecv.m_dwAgitUID : 아지트UID
    // kRecv.m_kCharInfo : 배치캐릭터 정보

    // 현재 아지트??
    if( SiKGCAgitGameManager()->GetAgitUID() != kRecv.m_dwAgitUID ) { 
        return;
    }

    SiKGCAgitGameManager()->UpdateAgitCharacterInfo( kRecv.m_kCharInfo );
}

void On_EVENT_UPDATE_AGIT_CHARACTER_POS_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KSetAgitCharPosReq );
    SAFE_DELETE( pkBuff );
    // 내가 있는 아지트의 배치캐릭터 상태변경 알림
    // kRecv.m_dwAgitUID : 아지트UID
    // kRecv.m_vecCharPos : 배치캐릭터 좌표  std::vector<KSimpleAgitCharPos>

    // 현재 아지트??
    if( SiKGCAgitGameManager()->GetAgitUID() != kRecv.m_dwAgitUID ) { 
        return;
    }

    SiKGCAgitGameManager()->UpdateAgitCharacterPos( kRecv.m_vecCharPos );    
}

void On_EVENT_SHUTDOWN_USER_DISCONNECT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SHUTDOWN_ALARM_NOT );
    SAFE_DELETE( pkBuff );
    // 셧다운제 대상유저 종료 알림
    // kRecv.m_usPrevTime; // 몇분전 알림메세지인지 (분)
    // kRecv.m_prAge; // 대상연령대 (시작나이~끝나이)
    // kRecv.m_prStartTime; // 셧다운 시작시간 (시:분)
    // kRecv.m_prEndTime; // 셧다운 끝시간 (시:분

    g_kGlobalValue.m_bShutDown = true;
    g_kGlobalValue.m_iShutDownType = 0;
}

void On_EVENT_SHUTDOWN_ALARM_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SHUTDOWN_ALARM_NOT );
    SAFE_DELETE( pkBuff );
    // 셧다운제 알림 메세지
    // kRecv.m_usPrevTime; // 몇분전 알림메세지인지 (분)
    // kRecv.m_prAge; // 대상연령대 (시작나이~끝나이)
    // kRecv.m_prStartTime; // 셧다운 시작시간 (시:분)
    // kRecv.m_prEndTime; // 셧다운 끝시간 (시:분

    std::wstring strMsg;

    int nAge = kRecv.m_prAge.second;
    int nStartHour = kRecv.m_prStartTime.first;
    int nEndHour = kRecv.m_prEndTime.first;
    int nTime = kRecv.m_usPrevTime;

    strMsg = g_pkStrLoader->GetReplacedString( STR_ID_SHUTDOWN_MSG_1, "iiii", nAge,  nStartHour, nEndHour, nTime );

    KSignBoardData kSingBoard;
    kSingBoard.m_eType = KSignBoardData::SBT_SERVER_ADMIN;
    kSingBoard.m_strMsg = strMsg;
    
    SiKGCAnnounceMgr()->ReserveAnnounce( kSingBoard );


    g_pkChatManager->AddChatMsgTo( g_MyD3D->m_pStateMachine->GetState(), strMsg,
        KGCChatManager::CHAT_TYPE_ADMIN, false, L"", 0xffff00 );
}

void On_EVENT_SURVEY_REWARD_LIST_INFO( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SURVEY_REWARD_LIST_INFO );
    SAFE_DELETE( pkBuff );
    // 설문 보상 리스트 등록
    if(g_pkUIScene->m_pkSurveyDlg)
        g_pkUIScene->m_pkSurveyDlg->SetRewardList( kRecv.m_mapSurveyReward );

}

void On_EVENT_SURVEY_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SURVEY_LIST_NOT );
    SAFE_DELETE( pkBuff );
    // 설문 질문 리스트 등록
    if(g_pkUIScene->m_pkSurveyDlg)
        g_pkUIScene->m_pkSurveyDlg->OnEventSurveyListNot( kRecv, true );
}

void On_EVENT_SURVEY_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SURVEY_REWARD_ACK );
    SAFE_DELETE( pkBuff );
    // 설문의 보상 응답
    switch ( kRecv.m_nOK ) {
        case 0: // 성공
            {
                g_pkUIScene->m_pkSurveyDlg->OnSurveyRewardAck( kRecv.m_vecReward );

                // 메시지 박스 띄우자~!!!
            }
            break;
        case 1: // 설문 조사 기간이 아님
            {
                /*g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( "설문 기간이 아님" ),
                    L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );*/
            }
            break;
        case 2: // 설문이 존재하지 않음
            {
                /*g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( "설문이 존재하지 않음" ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );*/
            }
        case 3: // 보상 리스트를 가져오지 못함
            {
                /*g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( "보상 리스트를 가져오지 못함" ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );*/
            }
            break;
        case 4: // 이미 응답한 설문임.
            {
                /*g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( "이미 응답한 설문" ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );*/
            }
            break;

        default:
            break;
    }
}
void On_EVENT_NMNETCAFE_BONUS_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_NMNETCAFE_BONUS_ACK );
    SAFE_DELETE( pkBuff );
    // 넷마블 PC방 아이템 전달
    // kRecv.m_vecReward; // PC방 지급아이템 (인벤토리 갱신 필요)
    // kRecv.m_mapPetInfo; // PC방 펫 포함 펫정보 (인벤토리 갱신 필요)
    // kRecv.m_strMsg; // PC방 메세지 (메세지 박스로 출력 필요)
    g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecReward, true);

    g_MyD3D->m_mapPetInfo.clear();
    std::map< GCITEMUID, KPetInfo >::iterator mitPet;
    for( mitPet = kRecv.m_mapPetInfo.begin(); mitPet != kRecv.m_mapPetInfo.end(); ++mitPet )
    {
        KPetInfo kPet = mitPet->second;

        // 클라이언트에서 사용하는 값으로 바꿔준다
        GCITEMUID dwPetUID =  kPet.m_dwUID;
        GCITEMID dwPetID = kPet.m_dwID / 10;
        GCITEMID dwPetCostumeID = kPet.m_kCostume.m_dwID / 10;
        GCITEMUID dwPetCostumeUID =  kPet.m_kCostume.m_dwUID;

        // 바꾼 값으로 다시 세팅
        kPet.m_dwUID = dwPetUID;
        kPet.m_dwID = dwPetID;
        kPet.m_kCostume.m_dwID = dwPetCostumeID;
        kPet.m_kCostume.m_dwUID = dwPetCostumeUID;

        // 펫 장착 아이템에 관해서도 클라이언트에서 사용하는 값으로 바꿔준다
        for( int i = 0; i < (int)kPet.m_vecEquipItem.size(); i++ )
        {
            GCITEMUID dwPetItemUID = kPet.m_vecEquipItem[i].m_dwUID;
            GCITEMID dwPetItemID = kPet.m_vecEquipItem[i].m_dwID / 10;

            kPet.m_vecEquipItem[i].m_dwUID = dwPetItemUID;
            kPet.m_vecEquipItem[i].m_dwID = dwPetItemID;
        }

        g_MyD3D->m_mapPetInfo[ kPet.m_dwUID ] = kPet;
    }

    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, kRecv.m_strMsg, L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0);
}
void On_EVENT_DUNGEON_TICKET_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DUNGEON_TICKET_LIST_NOT );
    SAFE_DELETE( pkBuff );
    // map[ModeID,던전티켓정보]
    // kRecv : std::map<int,KDungeonTicket>

    SiKGCRoomManager()->SetDungeonTicket( kRecv );
}

void On_EVENT_EXP_TABLE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_EXP_TABLE_NOT );
    SAFE_DELETE( pkBuff );
    // 게임서버 접속시, 경험치 테이블 전달 (Lv, Exp)
    // kRecv : std::map< DWORD, __int64>

    SetExpTable( kRecv );
    
}

void On_EVENT_SHA_ENABLE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );

    // kRecv == 0 이면 SHA 체크 비활성화.
    // kRecv == 1 이면 SHA 체크 활성화.

    bool bTmp = false;
    switch(kRecv)
    {
    case 0:
        bTmp = false;
        break;
    case 1:
        bTmp = true;
        break;
    }
    KSHAChecker::GetInstance()->SerbOn( bTmp );
}

void On_EVENT_GACHA_NOTICE_POPUP_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    /*KSerializer ks;
    ACK_DESERIALIZE( bool );
    SAFE_DELETE( pkBuff );

    g_pkUIScene->GetNewClearSealDlg()->SetFirstOpen( !kRecv );*/
}

void On_EVENT_GWC_RANKING_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GWC_RANKING_LIST_ACK );
    SAFE_DELETE( pkBuff );
    // 국가 랭킹 정보 요청에 대한 응답.
/*
    kPacket.m_nOK = 0        // 성공
    kPacket.m_nOK = 1        // GWC 이벤트 기간이 아님.
    kPacket.m_nOK = -98      // 아직 처리중인 작업입니다.
*/
    Result_GwcRakinglistReq = kRecv.m_nOK;
    switch (kRecv.m_nOK)
    {
    case 0:
        {
            g_pkUIScene->m_pkGwcEventdlg->SetCountryInfo( kRecv.m_mapTotalCountryInfo );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GWC_EVENT_DLG);
            break;
        }
    case 1:
        {
            //이벤트 기간이 아닙니다.
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
    default:
        {
            //알수 없는 오류
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false);
            break;
        }
    }
    
    
}

void On_EVENT_GWC_RANKING_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GWC_RANKING_REWARD_ACK );
    SAFE_DELETE( pkBuff );
    // 국가 랭킹에 대한 보상 아이템 받기.
/*
    kPacket.m_nOK = 0        // 성공
    kPacket.m_nOK = 1        // GWC 이벤트 기간이 아님.
    kPacket.m_nOK = 2        // GWC 보상 아이템 가져오기 실패.
    kPacket.m_nOK = 3        // GWC 보상 아이템 이미 받아갔음.
    kPacket.m_nOK = -98      // 아직 처리중인 작업입니다.
*/
    Result_GwcRakingRewardReq = kRecv.m_nOK;
    switch (kRecv.m_nOK)
    {
        case 0:
        {
            //g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GWC_EVENT_CATALOG);
#if defined(NATION_USA)
            for( std::vector<KItem>::iterator it = kRecv.m_vecReward.begin() ; it != kRecv.m_vecReward.end() ; ++it )
            {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, (*it).m_ItemID/10, 0, false, true );
            }

            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecReward, true);

            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();

#else
            OnItemReceive(kRecv.m_vecReward, true, true);
            
            if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
                g_pkUIScene->m_pkMyInfoScene->UpdateGameData();

#endif
            
            break;
        }
        case 1:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
        case 3:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GWC_EVENT_CATALOG);
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK , g_pkStrLoader->GetString(STR_ID_REWARD_ALREAY_RECEIVED) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
        case -98:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_ALREADY_WORKING) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false);
            break;
        }
        default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false);
            break;
        }
    }
}


void On_EVENT_JUST_IN_TIME_NEXT_TIME_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_JUST_IN_TIME_NEXT_TIME_NOT );
    SAFE_DELETE( pkBuff );
    // kRecv.m_tmJIT : 이벤트시간
    // kRecv.m_mapUserTypeEvent : map[이벤트대상(0:모든유저,1:PC방유저,2:PC방아닌유저), 이벤트대상인가?]

    // Just in time 다음 시간 받기
    // if(kRecv == 0) : 다음 이벤트 시간 없음
    // else           : 다음 시간

    // 이벤트 대상 정보가 비었으면 에러다!
    if( kRecv.m_mapUserTypeEvent.empty() ) { 
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_JIT_ERROR) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
        return;
    }

    if( kRecv.m_tmJIT == 0 )
        g_kJustInTime.SetJustInTimeState( JIT_NO_MORE_EVENT );
    else
        g_kJustInTime.SetJustInTimeState( JIT_WAIT_NEXT_TIME );

    // 시간정보는 저장
    g_kJustInTime.SetJustInTimeEventTime( kRecv.m_tmJIT );

    // 툴팁 생성
    std::map< USHORT, bool >::const_iterator mit = kRecv.m_mapUserTypeEvent.begin();
    for( ; mit != kRecv.m_mapUserTypeEvent.end() ; ++mit ) { 
        if( mit->first == 1 && mit->second == false ) { 
            g_kJustInTime.CreateJustInTimeToolTip(JIT_STRING_TYPE_NOT_PCBANG_USER);
            break;
        }
        else if( mit->first == 2 && mit->second == false ) { 
            g_kJustInTime.CreateJustInTimeToolTip(JIT_STRING_TYPE_NOT_NORMAL_USER);
            break;
        }
        else { 
            g_kJustInTime.CreateJustInTimeToolTip();
            break;
        }
    }
}

void On_EVENT_JUST_IN_TIME_ON_TIME_NOT(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_JUST_IN_TIME_ON_TIME_NOT);
    SAFE_DELETE(pkBuff);

    if (kRecv.m_bIsEventUser == false) {
        return;
    }

    g_kJustInTime.SetJustInTimeState(JIT_CLICK_ON_TO_GET_REWARD);
    g_kJustInTime.SetJustInTimeEventTime(kRecv.m_tmJIT);
    g_kJustInTime.SetRewardList(kRecv.m_vecItemList);

    if (GC_GLOBAL_DEFINE::bJustInTimeSearch)
    {
        if (g_pkUIScene->m_pkHotTimeSearchDlg->IsRenderOn())
        {
            g_pkUIScene->m_pkHotTimeSearchDlg->OnClose();
        }
    }

    g_kJustInTime.CreateJustInTimeToolTip();
}


void On_EVENT_JUST_IN_TIME_REWARD_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_JUST_IN_TIME_REWARD_ACK);
    SAFE_DELETE(pkBuff);

    switch (kRecv.m_nOK)
    {
        case 0:
        {
            OnItemReceive(kRecv.m_vecRecieveItemList, false, false);

            if (g_MyD3D->m_pStateMachine->IsStateMyInfo())
                g_pkUIScene->m_pkMyInfoScene->UpdateGameData();

            break;
        }
        case 1:
        {
            g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_PLANT_TREE_13), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, false);
            return;
        }
        case 2:
        {
            g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_REWARD_ALREAY_RECEIVED), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, false);
            break;
        }
        case -98:
        {
            g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_ALREADY_WORKING), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, false);
            break;
        }
        default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK);
            g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, false);
            break;
        }
    }

    if (kRecv.m_tmNextEvent == 0)
        g_kJustInTime.SetJustInTimeState(JIT_NO_MORE_EVENT);
    else
        g_kJustInTime.SetJustInTimeState(JIT_WAIT_NEXT_TIME);

    g_kJustInTime.SetJustInTimeEventTime(kRecv.m_tmNextEvent);

    if (kRecv.m_tmNextEvent != 0) {
        std::map< USHORT, bool >::const_iterator mit = kRecv.m_mapUserTypeEvent.begin();
        for (; mit != kRecv.m_mapUserTypeEvent.end(); ++mit) {
            if (mit->first == 1 && mit->second == false) {
                g_kJustInTime.CreateJustInTimeToolTip(JIT_STRING_TYPE_NOT_PCBANG_USER);
                break;
            }
            else if (mit->first == 2 && mit->second == false) {
                g_kJustInTime.CreateJustInTimeToolTip(JIT_STRING_TYPE_NOT_NORMAL_USER);
                break;
            }
            else {
                g_kJustInTime.CreateJustInTimeToolTip();
                break;
            }
        }
    }
    else {
        g_kJustInTime.CreateJustInTimeToolTip();
    }
}

void On_EVENT_ESCORT_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ESCORT_INFO_NOT );
    SAFE_DELETE( pkBuff );

    // 호위이벤트 정보 받기
    g_kGlobalValue.SetEscortInfo( kRecv );

}

void On_EVENT_CHARISMAS_EVENT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHARISMAS_EVENT_NOT );
    SAFE_DELETE( pkBuff );

    // 이벤트 정보 받기
#if defined( USE_CHRISTMAS_GIFT_EVENT )
    g_pkUIScene->m_pkChristmasGiftDlg->OnEventChristmasEventNot( kRecv );
#endif

}


void On_EVENT_CHARISMAS_EVENT_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHARISMAS_EVENT_INFO_ACK );
    SAFE_DELETE( pkBuff );
    // 현재 나의 정보 받기.
    /*
    kPacket.m_nOK = 0   // 성공
    kPacket.m_nOK = 1   // 크리스마스 이벤트 기간이 아님.
    kPacket.m_nOK = 2   // DB에서 데이터 이미 가져왔음.
    kPacket.m_nOK = -98 // 아직 처리중인 작업입니다.
    */
    switch (kRecv.m_nOK)
    {
        case 0:
        {
            g_pkUIScene->m_pkChristmasGiftDlg->OnEventChristmasEventInfoAck( kRecv );
            break;
        }
        case 1:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
        case 2: // 성공
        {
            g_pkUIScene->m_pkChristmasGiftDlg->OnEventChristmasEventInfoAck( kRecv );
            break;
        }
        case -98:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_ALREADY_WORKING) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false);
            break;
        }
        default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false);
            break;
        }
    }
}

void On_EVENT_CHARISMAS_EVENT_CONNECT_CHECK_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHARISMAS_EVENT_CONNECT_CHECK_ACK );
    SAFE_DELETE( pkBuff );
    // 닉네임으로 유저 UID 가져오기.
    /*
    kPacket.m_nOK = 0   // 성공
    kPacket.m_nOK = 1   // 크리스마스 이벤트 기간이 아님.
    kPacket.m_nOK = 3   // DB에서 유저 닉네임으로 UID 가져오기 실패.
    kPacket.m_nOK = -98 // 아직 처리중인 작업입니다.
    */
    switch (kRecv.m_nOK)
    {
    case 0:
        {
            g_pkUIScene->m_pkChristmasGiftDlg->GetSendGiftItemDlg()->SendGift( kRecv.m_dwUserUID );
            break;
        }
    case 1:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
    case 3:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NO_EXISTED_NICKNAME), L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
    case -98:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_ALREADY_WORKING) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false);
            break;
        }
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false);
            break;
        }
    }

}

void On_EVENT_CHARISMAS_EVENT_PRESENT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHARISMAS_EVENT_PRESENT_ACK );
    SAFE_DELETE( pkBuff );
    // 선물하기에 대한 응답.
    /*
    kPacket_.m_nOK = 0      // 성공
    kPacket_.m_nOK = 1      // 크리스마스 이벤트 기간이 아님.
    kPacket_.m_nOK = 4      // 크리스마스 재료 아이템 인벤토리 없음.
    kPacket_.m_nOK = 5      // 크리스마스 재료 아이템 갯수 부족.
    kPacket_.m_nOK = 6      // 선물할 아이템 정보 가져오기 실패.
    kPacket_.m_nOK = 7      // 선물받을 유저가 해당 서버에 없음.
    kPacket_.m_nOK = 8      // DB 선물 아이템 넣기 실패.
    kPacket_.m_nOK = 9      // 크리스마스 재료 아이템 동기화 실패.
    kPacket_.m_nOK = -98    // 아직 처리중인 작업입니다.
    */
    switch (kRecv.m_nOK)
    {
    case 0:
        {
            g_pkUIScene->m_pkChristmasGiftDlg->OnEventChristmasEventPresentAck( kRecv );
            break;
        }
    case 1:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
    case 4:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_BUY_AGIT_ITEM_FAIL3), L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
    case 5:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_BUY_AGIT_ITEM_FAIL5), L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
    case 7:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NO_USER_TO_RECIEVE_IN_THIS_SERVER), L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
    case 8:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4), L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
    case 9:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_ENCHANT_RESULT8), L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
    case -98:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_ALREADY_WORKING) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false);
            break;
        }
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false);
            break;
        }
    }
}

void On_EVENT_CHARISMAS_EVENT_PRESENT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHARISMAS_EVENT_PRESENT_NOT );
    SAFE_DELETE( pkBuff );
    // 선물 받은 유저에게 전달되는 패킷.

    // 선물은 인벤토리로
    g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecPresentItem, true );

    if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
    {
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
    }

    // 메시지를 바로 보여줄지 판단
    if( g_MyD3D->m_pStateMachine->GetState() == GS_GAME ){
        if( SiKGCRoomManager()->GetGameModeCategory() == GC_GMC_AGIT ){ // 게임모드라도 아지트에서는 그냥 띄움
            g_pkUIScene->m_pkChristmasGiftDlg->OnEventChristmasEventPresentNot( kRecv, true );
        } else {
            g_pkUIScene->m_pkChristmasGiftDlg->KeepMsg( kRecv );
        }
    } else {
        if( g_pkUIScene->GetClearSealDlg()->IsRenderOn() )            // 다른 이벤트 UI는 메시지가 뒤로 뜸, 가챠만 띄우지 않고 대기
            g_pkUIScene->m_pkChristmasGiftDlg->KeepMsg( kRecv );
        else
            g_pkUIScene->m_pkChristmasGiftDlg->OnEventChristmasEventPresentNot( kRecv, false );
    }
}

void On_EVENT_CHARISMAS_EVENT_DONATION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHARISMAS_EVENT_DONATION_ACK );
    SAFE_DELETE( pkBuff );
    // 기부하기에 대한 응답.
    /*
    kPacket.m_nOK = 0      // 성공
    kPacket.m_nOK = 1      // 크리스마스 이벤트 기간이 아님.
    kPacket.m_nOK = 4      // 크리스마스 재료 아이템 인벤토리 없음.
    kPacket.m_nOK = 5      // 크리스마스 재료 아이템 갯수 부족.
    kPacket.m_nOK = 10     // 기부갯수 보너스 포인트 정보 가져오기 실패.
    kPacket.m_nOK = 14     // 현재 유저의 보너스 포인트가 최대치임.
    kPacket.m_nOK = -98    // 아직 처리중인 작업입니다.
    */

    switch (kRecv.m_nOK)
    {
    case 0:
        {
            g_pkUIScene->m_pkChristmasGiftDlg->OnEventChristmasEventDonationAck( kRecv );
            break;
        }
    case 1:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
    case 4:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_BUY_AGIT_ITEM_FAIL3), L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
    case 5:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_BUY_AGIT_ITEM_FAIL5), L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
    case -98:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_ALREADY_WORKING) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false);
            break;
        }
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false);
            break;
        }
    }

}

void On_EVENT_CHARISMAS_EVENT_GRADE_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHARISMAS_EVENT_GRADE_REWARD_ACK );
    SAFE_DELETE( pkBuff );
    // 등급 보상 받기 정보에 대한 응답.
    /*
    kPacket.m_nOK = 0      // 성공
    kPacket.m_nOK = 1      // 크리스마스 이벤트 기간이 아님.
    kPacket.m_nOK = 8      // DB 선물 아이템 넣기 실패.
    kPacket.m_nOK = 11     // 등급 보상 가져오기 실패.
    kPacket.m_nOK = 12     // 잘못된 등급정보.
    kPacket.m_nOK = 13     // 유저의 보너스 포인트가 설정되지 않음.
    kPacket.m_nOK = -98    // 아직 처리중인 작업입니다.
    */

    switch (kRecv.m_nOK)
    {
    case 0:
        {
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecReward, true );

            if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
                g_pkUIScene->m_pkMyInfoScene->UpdateGameData();

            g_pkUIScene->m_pkChristmasGiftDlg->OnEventChristmasEventGradeRewadAck( kRecv );
            break;
        }
    case 1:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
    case 8:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
    case 11:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_PLANT_TREE_13), L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false);
            break;
        }
    case -98:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_ALREADY_WORKING) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false);
            break;
        }
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false);
            break;
        }
    }
}

// 우편함
void On_EVENT_NEW_POST_LETTER_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_NEW_POST_LETTER_INFO_NOT );
    SAFE_DELETE( pkBuff );
    // 게임서버 접속시 읽지않은 우편 유저 알림
    // kRecv.m_nNewUserLetterCount; // 새로운 유저 편지 개수
    // kRecv.m_nNewSystemLetterCount; // 새로운 시스템 편지 개수
    // kRecv.m_nTotalLetterCount; // 총 편지 개수
    // kRecv.m_vecNewLetterTitle; // 안읽은편지 제목

    if( kRecv.m_nNewUserLetterCount > 0 || kRecv.m_nNewSystemLetterCount > 0 ) { 
        SiKGCPostLetterManager()->SetNewLetter( true );
		//안 읽은 편지 갯수를 셋팅 한다. 
		SiKGCPostLetterManager()->SetTotalNotReadLetterCount(kRecv.m_nNewUserLetterCount + kRecv.m_nNewSystemLetterCount);
		
    }
}

void On_EVENT_GET_POST_LETTER_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GET_POST_LETTER_LIST_ACK );
    SAFE_DELETE( pkBuff );
    // 클라이언트에서 요청한 특정페이지 우편 리스트 전달
    // kRecv.m_nOK; // 결과값
    //    0 : 성공
    //    1 :요청한 우편함 페이지 리스트 번호가 잘못됨.
    // kRecv.m_nPostPageNo; // 페이지번호
    // kRecv.m_nTotalLetterCount; // 총 편지수
    // kRecv.m_vecPostItemTitle; // 우편 제목 리스트

    Result_PostLetter = kRecv.m_nOK;

    switch( kRecv.m_nOK ) {
        case 0:
            SiKGCPostLetterManager()->SetPageInfo( kRecv.m_nPostPageNo, kRecv.m_nTotalLetterCount, kRecv.m_vecPostItemTitle );
            SiKGCPostLetterManager()->SetTotalLetterCount( kRecv.m_nTotalLetterCount );
            break;

        case 1:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GET_POST_LETTER_LIST_ERR ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            break;

        default:
            break;
    }
}

void On_EVENT_SEND_LETTER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SEND_LETTER_ACK );
    SAFE_DELETE( pkBuff );
    // 편지보내기 결과
    // kRecv.m_nOK; // 결과값
    //     0 : 성공
    //     5 : 우편이용 블럭 유저.
    //     6 : 자기자신에게 편지를 보낼 수 없음.
    //     7 : 우편 내용 길이가 제한길이를 초과함.
    //     8 : 우편 내용에 금지어가 포함되어 있음.
    //     9 : 우편 첨부할 GP보유량 부족함.
    //     10 : 우편 첨부할 영구 아이템이 인벤토리에 없음. 
    //     12 : 우편 첨부할 영구 아이템이 영구 설정이 아님.
    //     13 : 우편 첨부할 수량 아이템이 인벤토리에 없음.
    //     14 : 우편 첨부할 수량 아이템이 영구 설정이 아님.
    //     15 : 우편 첨부할 수량 아이템의 인벤토리 보유량이 부족함.
    //     16 : PC방 아이템은 우편 첨부할 수 없음.
    //     17 : 우편을 받을 대상유저를 닉네임으로 찾을 수 없음.
    //     18 : 우편 수수료가 부족함.
    //     19 : 우편 보내기 DB처리 실패.
    //     29 : 유저우편 아이템 첨부기능이 활성화 되어있지 않은데 아이템을 첨부함.
    //     32 : 유저우편 GP 첨부기능이 활성화 되어있지 않은데 아이템을 첨부함.
    //     33 : 유저우편 첨부할 수 없는 아이템을 첨부함.
    //    -98 : 아직 처리중인 작업입니다.
    // kRecv.m_nGamePoint; // 현재 보유 GP
    // kRecv.m_vecEraseItem; // 삭제 아이템 (첨부물)
    // kRecv.m_vecDecreaseCountItem; // 감소된 수량 아이템
    // kRecv.m_nSendLetterCost; // 수수료
}

void On_EVENT_RECEIVE_LETTER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RECEIVE_LETTER_NOT );
    SAFE_DELETE( pkBuff );
    // 접속중일때 실시간 편지 알림
    // kRecv.m_dwFromUserUID; // 보낸유저 UID
    // kRecv.m_strNickName; // 보낸유저 닉네임
    // kRecv.m_strLetterTitle; // 편지제목
    // kRecv.m_cScriptType; // 편지종류

    SiKGCPostLetterManager()->SetNewLetter( true );
}

void On_EVENT_READ_LETTER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_READ_LETTER_ACK );
    SAFE_DELETE( pkBuff );
    // 편지 내용 전달
    // kRecv.m_nOK; // 결과값
    //     0 : 성공
    //     20 : 읽기요청한 우편이 없음.
    // kRecv.m_kLetter; // 편지상세내용

    Result_PostLetter = kRecv.m_nOK;

    switch ( kRecv.m_nOK )
    {
    case 0:
        SiKGCPostLetterManager()->SetReadPostLetterInfo( kRecv.m_kLetter );
		//안 읽은 편지 수가 1개 이상일 때, 한개씩 깎는다. 
		if( SiKGCPostLetterManager()->GetTotalNotReadLetterCount() > 0 )
			SiKGCPostLetterManager()->SetTotalNotReadLetterCount(SiKGCPostLetterManager()->GetTotalNotReadLetterCount() -1 );
        break;

    case 20:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_READ_LETTER_ERR ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;

    default:
        break;
    }
}

void On_EVENT_GET_ITEM_FROM_LETTER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GET_ITEM_FROM_LETTER_ACK );
    SAFE_DELETE( pkBuff );
    // 편지 첨부물 받기 결과
    // kRecv.m_nOK; // 결과값
    //     0 : 성공
    //     21 : 첨부아이템 받기 요청한 우편이 없음.
    //     22 : 첨부아이템을 이미 받아갔음.
    //     23 : GP소유 한도를 초과해 더이상 GP를 받을 수 없음.
    //     24 : 아지트아이템 첨부 받기에 충분한 인벤 공간이 없음.
    //     25 : 코디아이템 첨부 받기에 충분한 인벤 공간이 없음.
    //     26 : 일반아이템 첨부 받기에 충분한 인벤 공간이 없음.
    //     27 : 해당우편은 첨부아이템이 없음.
    //     28 : 우편 대기아이템 리스트 받아오기 DB처리 실패.
    //    -98 : 아직 처리중인 작업입니다.
    // kRecv.m_PostUID; // 편지번호
    // kRecv.m_bSystemLetter; // 시스템 우편인가
    // kRecv.m_vecReward; // 획득한 아이템
    // kRecv.m_nRewardGP; // 획득한 GP
    // kRecv.m_nCurrentGP; // 현재 GP

    switch( kRecv.m_nOK )
    {
    case 0:
        // 아이템 추가 
        for( std::vector< KItem >::iterator vit = kRecv.m_vecReward.begin() ; vit != kRecv.m_vecReward.end() ; ++vit ) {
            GCItem* pItem = g_pItemMgr->GetItemData( vit->m_ItemID / 10 );
            if( NULL == pItem ) { 
                continue;
            }

            g_pItemMgr->m_kInventory.AddItem( *vit, true );
            std::wstring strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE1, "l", pItem->strItemName );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_REPETITION_EVENT_BOX, strMsg, L"", KGCUIScene::GC_MBOX_USE_NORMAL, pItem->dwGoodsID * 10, vit->m_ItemUID, true, true );
        }

        // GP 추가
        g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nCurrentGP );
        g_MyD3D->MyPlayer[ g_MyD3D->Get_MyPlayer() ]->m_kUserInfo.GetCurrentChar().SetCurrentGP( kRecv.m_nCurrentGP );

        // 인벤토리 업데이트 
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
        g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();
        break;

    case 21:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RECV_ITEM_FROM_LETTER_ERR0 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;

    case 22:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RECV_ITEM_FROM_LETTER_ERR1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;

    case 23:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RECV_ITEM_FROM_LETTER_ERR2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;

    case 24:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RECV_ITEM_FROM_LETTER_ERR3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;

    case 25:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RECV_ITEM_FROM_LETTER_ERR4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;

    case 26:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RECV_ITEM_FROM_LETTER_ERR5 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;

    case 27:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RECV_ITEM_FROM_LETTER_ERR6 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;

    case 28:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RECV_ITEM_FROM_LETTER_ERR7 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;

    case -98:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ALREADY_WORKING ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;

    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        }
        break;
    }

    Result_PostLetter = kRecv.m_nOK;
}

void On_EVENT_DELETE_LETTER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DELETE_LETTER_ACK );
    SAFE_DELETE( pkBuff );
    // S->C. 편지 삭제 결과
    // kRecv.m_nOK; // 결과값
    //     0 : 성공
    //     30 : 삭제요청한 우편이 없음.
    //     31 : 우편삭제 DB처리 실패
    //    -98 : 아직 처리중인 작업입니다.
    // kRecv.m_vecPostUID; // 삭제된 편지번호

    switch( kRecv.m_nOK ) { 
        case 0:
            break;

        case 30:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_DELETE_LETTER_ERR0 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            break;

        case 31:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_DELETE_LETTER_ERR1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            break;

        case -98:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ALREADY_WORKING ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            break;

        default:
            {
                std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                    KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
            }
            break;
    }

    Result_PostLetter = kRecv.m_nOK;
}

void On_EVENT_RENEWAL_LETTER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RENEWAL_LETTER_ACK );
    SAFE_DELETE( pkBuff );
    // S->C. 편지함 갱신 결과
    // kRecv.m_nNewUserLetterCount; // 새로운 유저 편지 개수
    // kRecv.m_nNewSystemLetterCount; // 새로운 시스템 편지 개수
    // kRecv.m_nTotalLetterCount; // 총 편지 개수
    // kRecv.m_vecNewLetterTitle; // 안읽은편지 제목
}


void On_EVENT_ECLIPSE_TIME_EVENT_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ECLIPSE_TIME_EVENT_INFO_NOT );
    SAFE_DELETE( pkBuff );

    SiGCEclipseEventManager()->SetEventTime(kRecv.m_tmBegin,kRecv.m_tmEnd,kRecv.m_dwPeriod,kRecv.m_dwDuration);

}

void On_EVENT_ECLIPSE_PLOT_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ECLIPSE_PLOT_INFO_ACK );
    SAFE_DELETE( pkBuff );

    switch (kRecv.m_nOK)
    {
    case 0:
        {
            g_pkUIScene->m_pkEventEclipsePlotDlg->OnEventEclipsePlotInfoAck( kRecv );
            break;
        }
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false);
            break;
        }
    }

}

void On_EVENT_ECLIPSE_PLOT_TIME_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ECLIPSE_PLOT_TIME_REWARD_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK
    // 0 : 성공
    // ERR_ECLIPSE_PLOT_00, 개기일식 시간 보상 받을 수 없는 상태에서 보상 요청 옴

    switch (kRecv.m_nOK)
    {
    case 0:
        {
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecReward, true );

            if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
                g_pkUIScene->m_pkMyInfoScene->UpdateGameData();

            g_pkUIScene->m_pkEventEclipsePlotDlg->OnEventEclipsePlotTimeRewardAck( kRecv );
            break;
        }
    case NetError::ERR_ECLIPSE_PLOT_00:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_TIME) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, false, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
            break;
        }
    }

}

void On_EVENT_ECLIPSE_PLOT_TIME_REWARD_READY_NOT( WPARAM wParam, LPARAM lParam )
{
    g_pkUIScene->m_pkEventEclipsePlotDlg->OnEventEclipsePlotTimeRewardReadyNot();
}

void On_EVENT_ECLIPSE_PLOT_HUNT_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ECLIPSE_PLOT_HUNT_REWARD_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK
    // 0 : 성공
    // ERR_ECLIPSE_PLOT_01, 수집 아이템이 없는 상태에서 보상 요청함.
    // ERR_ECLIPSE_PLOT_02, 수집 아이템 수량이 모자란 상태에서 보상 요청함.
    // ERR_ECLIPSE_PLOT_03, 수집 아이템 교환 기능 OFF 상태임.
    // ERR_ECLIPSE_PLOT_04, 수집 아이템 보상시 DB 동기화 실패


    switch (kRecv.m_nOK)
    {
    case 0:
        {
            g_pkUIScene->m_pkEventEclipsePlotDlg->OnEventEclipsePlotHuntRewardAck( kRecv );
            break;
        }
    case NetError::ERR_ECLIPSE_PLOT_01:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_START_GAME_ERROR21) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, false, true );
        break;
    case NetError::ERR_ECLIPSE_PLOT_02:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_USE_TRAINING_OBJ_FAIL6) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, false, true );
        break;
    case NetError::ERR_ECLIPSE_PLOT_03:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, false, true );
        break;
    case NetError::ERR_ECLIPSE_PLOT_04:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, false, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
            break;
        }
    }

}

void On_EVENT_ECLIPSE_PLOT_FINAL_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ECLIPSE_PLOT_FINAL_REWARD_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK
    // 0 : 성공
    // ERR_ECLIPSE_PLOT_05, 최종 보상 조건이 아닌데 최종보상 요청함.
    // ERR_ECLIPSE_PLOT_06, 최종 보상을 이미 받았는데 보상 요청함.
    // ERR_ECLIPSE_PLOT_07, 최종 보상 받은 기록 DB 저장 실패.
    // ERR_ECLIPSE_PLOT_08, 최종 보상 진행도 DB 저장 실패.

    switch (kRecv.m_nOK)
    {
    case 0:
        {
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecReward, true );

            if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
                g_pkUIScene->m_pkMyInfoScene->UpdateGameData();

            g_pkUIScene->m_pkEventEclipsePlotDlg->OnEventEclipsePlotFinalRewardAck( kRecv );
            break;
        }
    case NetError::ERR_ECLIPSE_PLOT_06:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_REWARD_ALREAY_RECEIVED) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, false, true );
        break;
    case NetError::ERR_ECLIPSE_PLOT_07:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, false, true );
        break;
    case NetError::ERR_ECLIPSE_PLOT_08:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, false, true );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
            break;
        }
    }

}

void On_EVENT_ECLIPSE_COLLECT_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ECLIPSE_COLLECT_INFO_ACK );
    SAFE_DELETE( pkBuff );

    // 개기일식 고서 정보 받기에 대한 응답.
    /*
    kPacket.m_nOK = 0      // 성공
    kPacket.m_nOK = 1      // 이벤트 기간이 아님.
    kPacket.m_nOK = -98    // 아직 처리중인 작업입니다.
    */

    Result_EclipseEvent = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0:
        {
            if( g_pkUIScene->m_pkEclipseOldBooks != NULL ) {
                g_pkUIScene->m_pkEclipseOldBooks->SetAllAcquiredOldBooks( kRecv.m_bRewardEnable );
                g_pkUIScene->m_pkEclipseOldBooks->SetItemIDList( kRecv.m_setEclipseCollectItemList );
                g_pkUIScene->m_pkEclipseOldBooks->SetRewardItemInfo( kRecv.m_vecRewardItem );
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_ECLIPSE_OLD_BOOKS_DLG );
            }
            break;
        }
    case 1:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, false, true );
            break;
        }
    case -98:    
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_ALREADY_WORKING) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
            break;
        }
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
            break;
        }
    }
}

void On_EVENT_ECLIPSE_COLLECT_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ECLIPSE_COLLECT_REWARD_ACK );
    SAFE_DELETE( pkBuff );

    // 개기일식 최종 보상 정보 받기 요청.
    /*
    kPacket.m_nOK = 0      // 성공.
    kPacket.m_nOK = 1      // 고서 모으기 이벤트 기간이 아님. 
    kPacket.m_nOK = 2      // 고서 아이템이 존재 하지 않음. 
    kPacket.m_nOK = 3      // 이미 최종 보상 아이템을 받았음.
    kPacket.m_nOK = 4      // DB 보상 아이템 넣기 실패.
    kPacket.m_nOK = -98    // 아직 처리중인 작업입니다.
    */

    if( kRecv.m_nOK != 0 ) {
        g_pkUIScene->m_pkEclipseOldBooks->CheckAcquiredOldBooks();
    }

    switch( kRecv.m_nOK )
    {
    case 0:
        {
            g_pkUIScene->m_pkEclipseOldBooks->SetAllAcquiredOldBooks( true );
            g_pkUIScene->m_pkEclipseOldBooks->CheckAcquiredOldBooks();
            OnItemReceive( kRecv.m_vecItem, true, true, KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX );
            Result_EclipseEvent = INT_MAX;

            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecUseItem );

            // 인벤토리 업데이트 
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            break;
        }
    case 1:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, false, true );
            break;
        }
    case 2:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_BUY_AGIT_ITEM_FAIL3), L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, false, true );
            break;
        }
    case 3:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK , g_pkStrLoader->GetString(STR_ID_REWARD_ALREAY_RECEIVED) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, false, true );
            break;
        }
    case 4:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, false, true );
            break;
        }
    case -98:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_ALREADY_WORKING) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
            break;
        }
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
            break;
        }
    }
}

void On_EVENT_DUNGEON_CLEAR_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DUNGEON_CLEAR_REWARD_ACK );
    SAFE_DELETE( pkBuff );
    // S->C. 던전클리어보상 받기
    // kRecv.m_nOK; // 결과값
    //     0 : 성공
    //     1 : 해당하는 던전 클리어정보가 없음.
    //     2 : 해당하는 영웅던전이 없음.
    //     3 : 남은 보상개수가 부족함.
    //     4 : 보상리스트에 없는 보상을 선택했음.
    //     5 : 보상받을 아이템이 없음.
    //     6 : 보상아이템 지급 DB처리 실패.
    // kRecv.m_nModeID; // 던전ID
    // kRecv.m_vecIndexItemID; // 보상받은 아이템의 Index+ItemID
    // kRecv.m_vecReward; // 보상받은 아이템 (인벤토리에 갱신해줄 것)
    // kRecv.m_usLeftRewardCount; // 남은 보상 개수

    switch ( kRecv.m_nOK ) 
    {
    case 0: 
        {
            // 아이템 추가 
            for( std::vector< KItem >::iterator vit = kRecv.m_vecReward.begin() ; vit != kRecv.m_vecReward.end() ; ++vit ) {
                GCItem* pItem = g_pItemMgr->GetItemData( vit->m_ItemID / 10 );
                if( NULL == pItem ) { 
                    continue;
                }

                g_pItemMgr->m_kInventory.AddItem( *vit, true );
                std::wstring strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE1, "l", pItem->strItemName );
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_REPETITION_EVENT_BOX, strMsg, L"", KGCUIScene::GC_MBOX_USE_NORMAL, pItem->dwGoodsID * 10, vit->m_ItemUID, true, true );
            }

            SiKGCWorldMapManager()->SetDungeonRewardNum( static_cast<EGCGameMode>(kRecv.m_nModeID), kRecv.m_usLeftRewardCount );

            // 인벤토리 업데이트 
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
            g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();
            g_pkUIScene->m_pkHeroDungeonDlg->UpdateReward();
        }
        break;
    case 3:
        {
            std::wstring strTemp = g_pkStrLoader->GetString( STR_ID_HERO_REWARD_ERROR3 );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strTemp, L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        }
        break;
    }


}

void On_EVENT_EQUIP_LEVEL_DOWN_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_EQUIP_LEVEL_DOWN_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK; // 결과값
    //     0: 성공
    //     1 : 인벤토리에서 장비 아이템을 찾을 수 없음.
    //     2 : 인벤토리에서 재료 아이템을 찾을 수 없음.
    //     3 : 인벤토리에서 재료 아이템 수량이 부족함.
    //     4 : 장착레벨을 낮출 수 없는 아이템.
    //     5 : 더이상 장착레벨을 낮출 수 없음.
    //     6 : 선택한 재료가 재료아이템이 아니다.
    //     7 : 장착레벨 낮추기 DB작업 실패.
    //   -98 : 아직 처리중인 작업
    // kRecv.m_EquipItem; // 장착레벨 낮춘 아이템
    // kRecv.m_MaterialItem; // 재료 아이템 (수량갱신됨) // 재료 아이템 수량이 0이하일 경우, 인벤토리에서 제거해주세요.

    switch ( kRecv.m_nOK )
    {
    case 0:
        {
            g_pItemMgr->m_kInventory.AddItem( kRecv.m_EquipItem, true );
            g_pItemMgr->m_kInventory.AddItem( kRecv.m_MaterialItem, true );

            // 인벤토리 업데이트 
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
            g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();

            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_LEVEL_DOWN_OK ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
    case 3:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_LEVEL_DOWN_ERROR3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
    case 4:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_LEVEL_DOWN_ERROR4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
    case 5:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_LEVEL_DOWN_ERROR5 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        }
        break;
    }
}

void On_EVENT_MONSTER_CARD_MIX_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MONSTER_CARD_MIX_ACK );
    SAFE_DELETE( pkBuff );
    // S->C. 편지함 갱신 결과
    // kRecv.m_nOK; // 결과값
    //     0 : 성공
    //     1 : 재료 아이템이 인벤토리에 없음.
    //     2 : 재료 아이템이 몬스터 카드가 아님.
    //     3 : 재료 아이템 보유량이 부족함.
    //     4 : 재료 수량이 최소 개수를 미만.
    //     5 : 재료 수량이 최대 개수를 초과.
    //     6 : 보상할 아이템이 없음.
    //     7 : 몬스터카드 조합 DB처리 실패.
    // kRecv.m_vecDecreaseCountItem; // 감소된 수량 아이템 (해당 아이템 수량 갱신하고, 수량이 0이하면 인벤토리에서 삭제해주세요)
    // kRecv.m_vecRewards; // 획득 아이템 (수량감소 처리 후 획득 아이템 넣어주세요)


    switch ( kRecv.m_nOK ) 
    {
    case 0:
        {
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecDecreaseCountItem, true );
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewards, true );

// 			for( std::vector< KItem >::iterator vit = kRecv.m_vecRewards.begin() ; vit != kRecv.m_vecRewards.end() ; ++vit ) {
// 				GCItem* pItem = g_pItemMgr->GetItemData( vit->m_ItemID  );
// 				if( NULL == pItem ) { 
// 					continue;
// 				}
// 
// 				std::wstring strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE1, "l", pItem->strItemName );
// 				g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_REPETITION_EVENT_BOX, strMsg, L"", KGCUIScene::GC_MBOX_USE_NORMAL, pItem->dwGoodsID * 10, 1, true, true );
//			}

            if ( !kRecv.m_vecRewards.empty() )
                g_pkUIScene->m_pkMonsterCardCompose->SetResult( kRecv.m_vecRewards.begin()->m_ItemID );
            else
                g_pkUIScene->m_pkMonsterCardCompose->SetResult( 0 );

            // 인벤토리 업데이트 
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
            g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();
            
        }
        break;
    case 1:
    case 3:
        {
            g_pkUIScene->m_pkMonsterCardCompose->SetFailResult();
            std::wstring strTemp = boost::str( boost::wformat( L"%1% (%2%)" )%g_pkStrLoader->GetString( STR_ID_MONSTER_CARD_MIX_ERROR1 )%kRecv.m_nOK);
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strTemp, L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
    case 2:
    case 4:
    case 5:
        {
            g_pkUIScene->m_pkMonsterCardCompose->SetFailResult();
            std::wstring strTemp = boost::str( boost::wformat( L"%1% (%2%)" )%g_pkStrLoader->GetString( STR_ID_MONSTER_CARD_MIX_ERROR2 )%kRecv.m_nOK);
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strTemp, L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
    default:
        {
            g_pkUIScene->m_pkMonsterCardCompose->SetFailResult();
            
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        }
        break;
    }
}

void On_EVENT_USE_EXP_POTION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_USE_EXP_POTION_ACK );
    SAFE_DELETE( pkBuff );

    // S->C. 경험치 포션 사용 결과
    // kRecv.m_nOK;         // 결과값
    //     0 : 성공
    //     1 : 경험치 포션 아이템이 인벤토리에 없음
    //     2 : 경험치 포션이 아님
    //     3 : 수량이 모자람
    //     4 : 사용 가능 레벨 아님
    // kRecv.m_kItem;       // 사용 된 아이템
    // kRecv.m_dwUserUID;   // 사용한 유저의 UID
    // kRecv.m_cCharType;   // 사용한 유저의 캐릭터 타입
    // kRecv.m_kSkillInfo;  // 스킬 포인트 인포
    // kRecv.m_biExp;       // 경험치 포션 적용 후 경험치 (증가 되어야 하는 경험치 수치가 아니라 증가 된 경험치 그대로 보내고 있어요)
    // kRecv.m_biTotalExp;  // 적용 후 누적 경험치 (마찬가지로 증가 된 누적 경험치 변수 값)
    // kRecv.m_dwLv;        // 적용 후 레벨 (레벨도 동일...)
    // kRecv.m_nDuration;   // 적용 후 수량 (수량도 그냥 아이템 정보에서 수량 받아서 보내고 있어요)

    switch( kRecv.m_nOK )
    {
    case 0:
        {
            // 캐릭터 정보 얻기
            SCharInfo &sCharInfo = g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar( kRecv.m_cCharType );
            if( 0 <= sCharInfo.iCharType && sCharInfo.iCharType < GC_CHAR_NUM )
            {
                // 레벨과 경험치 갱신
                UCHAR ucOldLevel = sCharInfo.iLevel;
                GCEXPTYPE biOldExp = sCharInfo.biExp;
                sCharInfo.biExp = kRecv.m_biExp;
                sCharInfo.iLevel = static_cast<UCHAR>(kRecv.m_dwLv);
                sCharInfo.kSkillInfo = kRecv.m_kSkillInfo;

                // 글로벌 유저정보갱신
                g_MyD3D->m_TempPlayer.UpdateGlobalUserInfo();

                int iIndex = g_MyD3D->Get_MyPlayer();
                if ( iIndex < MAX_PLAYER_NUM && iIndex >= 0 )
                {
                    g_MyD3D->MyPlayer[iIndex]->SetMyPlayer();
                }
                // 대기룸에서 진입한 장비탭이라면 방원들에게 유저정보 갱신했다고 알림
                if( g_MyD3D->m_pStateMachine->IsStateRoom() || g_MyD3D->m_pStateMachine->GetState() == GS_GAME_END )
                {
                    PLAYER *pMyRoomPlayer = g_MyD3D->GetPlayerByUID( g_MyD3D->m_TempPlayer.m_kUserInfo.dwUID );
                    if( pMyRoomPlayer )
                        pMyRoomPlayer->m_kUserInfo = g_MyD3D->m_TempPlayer.m_kUserInfo;
                    KP2P::GetInstance()->Send_ChangeIndoorUserInfoReq( &(g_MyD3D->m_TempPlayer.m_kUserInfo) );

                    g_pkUIScene->RoomSceneUpdateData();
                }
                else
                {
                    g_MyD3D->m_TempPlayer.SetMyPlayer(-1);
                }

                // 아이템 수량갱신
                KItem* pkItem = g_pItemMgr->m_kInventory.FindItemByItemID( (kRecv.m_kItem.m_dwID/10) );
                if( pkItem )
                {
                    if( 0 < kRecv.m_nDuration )
                        pkItem->m_nCount = kRecv.m_nDuration;
                    else
                        g_pItemMgr->m_kInventory.RemoveItem( pkItem->m_ItemUID );
                    g_pItemMgr->UpdateUserItem( &g_kGlobalValue.m_kUserInfo );
                }

                // 장비창 갱신
                if( g_pkUIScene->m_pkMyInfoScene->m_pkStatusPanel )
                {
                    g_pkUIScene->m_pkMyInfoScene->m_pkStatusPanel->ResetInfo();
                    g_pkUIScene->m_pkMyInfoScene->m_pkStatusPanel->SetStartUserInfo();
                    g_pkUIScene->m_pkMyInfoScene->m_pkStatusPanel->SetChangeUserInfo();
                    g_pkUIScene->m_pkMyInfoScene->m_pkStatusPanel->SetText();
                }
                g_pkUIScene->m_pkMyInfoScene->UpdateData();
                g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
                g_pkUIScene->m_pkMyInfoScene->UpdateCharInfo();

                // 경험치 아이템 사용 메시지 박스 출력
                GCItem* kItem = NULL;
                kItem = g_pItemMgr->GetItemData( (kRecv.m_kItem.m_dwID/10) );
                if( kItem )
                    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_USE_EXP_POTION_OK, "li", kItem->strItemName, (sCharInfo.biExp - biOldExp)), L"" );
            }
            else
            {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( 5323 ), g_pkStrLoader->GetString( 3745 ) );
            }
        }
        break;
    case 1:
    case 2:// 시스템 오류 임
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( 5323 ), g_pkStrLoader->GetString( 3745 ) );
        break;
    case 3:// 수량이 모자람
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( 3743 ), L"" );
        break;
    case 4:// 사용 가능 레벨 아님
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_USE_LIMITE_LEVEL ), L"" );
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp );
        }
        break;
    }
}

void On_EVENT_EXP_POTION_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_EXP_POTION_LIST_ACK );
    SAFE_DELETE( pkBuff );

    // S->C. 경험치 포션 리스트 ACK
    // kRecv.m_vecItemID;    // 경험치 포션 테이블 벡터 ( 실제로는 GCITEMID만 들어있음 )

    g_pItemMgr->SetExpItemList( kRecv.m_vecItemID );
}

void On_EVENT_DEPOT_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DEPOT_INFO_ACK );
    SAFE_DELETE( pkBuff );

    SiKGCDepotManager()->SetDepotInfo(kRecv);

    if(g_pkUIScene->m_pkDepot)
        g_pkUIScene->m_pkDepot->CreateUI();
//    kRecv.m_mapDepotInfo; // map <  pair < character, tab > ,  DepotData >
    
    switch ( kRecv.m_nOK )
    {
    case NetError::NET_OK:
        // 성공
        break;
    case NetError::ERR_DEPOT_09:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_09) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    case -98:
        // 중복 패킷 요청
        break;
    default:
        break;
    }
}

void On_EVENT_DEPOT_CHAR_TAB_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DEPOT_CHAR_TAB_INFO_ACK );
    SAFE_DELETE( pkBuff );

    SiKGCDepotManager()->SetDepotCharTabInfo(kRecv);
    Result_DepotInfoByCharTabReq = 0;

    switch( kRecv.m_nOK ) 
    {
    case -98:
        // 중복 패킷 요청
        break;
    default:
        break;
    }

}

void On_EVENT_DEPOT_CHAR_TAB_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DEPOT_CHAR_TAB_INFO_ACK );
    SAFE_DELETE( pkBuff );

    SiKGCDepotManager()->SetDepotCharTabInfo(kRecv);
    Result_DepotInfoByCharTabReq = 0;

    switch( kRecv.m_nOK ) 
    {
    case -98:
        // 중복 패킷 요청
        break;
    default:
        break;
    }

}

void On_EVENT_DEPOT_INSERT_ITEM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DEPOT_INSERT_ITEM_ACK );
    SAFE_DELETE( pkBuff );

    switch(kRecv.m_nOK)
    {
    case 0:
        {
            GCItem* pItemData = g_pItemMgr->GetItemData( kRecv.m_kDepotItem.m_ItemID / 10 );
            if( pItemData->eItemType < 0 ) { // 영구 아이템인 경우 -> 인벤에서 삭제 해주고, 창고에는 추가 
                SiKGCDepotManager()->SwapPetInfo( kRecv.m_kDepotItem, g_MyD3D->m_mapPetInfo, g_MyD3D->m_mapDepotPetInfo );
                g_pItemMgr->m_kInventory.RemoveItem( kRecv.m_kDepotItem.m_ItemUID );
                SiKGCDepotManager()->DelInvenItem( kRecv.m_kDepotItem.m_ItemUID );
                SiKGCDepotManager()->AddDepotItem( kRecv.m_kDepotItem, true );
            }
            else {  // 수량 아이템 일 때 
                if( KItem::DEPOT == kRecv.m_kInvenItem.m_cInvenType ||
                    0 == kRecv.m_kInvenItem.m_nCount ) {                // 전체를 창고에 넣는 경우 
                        g_pItemMgr->m_kInventory.RemoveItem( kRecv.m_kInvenItem.m_ItemUID );    // 인벤에서 제거 
                        SiKGCDepotManager()->DelInvenItem( kRecv.m_kInvenItem.m_ItemUID );      // 창고 갱신 
                        SiKGCDepotManager()->AddDepotItem( kRecv.m_kDepotItem, true );                    
                }
                else {                                                  // 일부만 창고에 넣는 경우 
                    g_pItemMgr->m_kInventory.AddItem( kRecv.m_kInvenItem, true );                   // 인벤 수량 갱신
                    SiKGCDepotManager()->AddDepotItem( kRecv.m_kDepotItem, true );
                }
            }

            g_pkUIScene->m_pkDepot->UpdateDepotData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        }
        break;

    case NetError::ERR_DEPOT_00:
        // 아이템이 인벤토리에 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_00) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    case NetError::ERR_DEPOT_01:
        // 창고 아이템을 창고로 옮기려고 시도함.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_01) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;

    case NetError::ERR_DEPOT_02:
        //창고 슬롯이 비어있지 않음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_02) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    case NetError::ERR_DEPOT_03:
        // 인벤토리에서 창고로 옮기기 실패
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_03) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    case NetError::ERR_DEPOT_04:
        // 영구 아닌 기간제 아이템을 창고로 보관 시도함.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_04) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    case NetError::ERR_DEPOT_13:
        // 창고 정보를 아직 DB에서 불러오지 않았음
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_13) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    default:
        NetError::SetLastError(kRecv.m_nOK);
        std::wstring strerr = NetError::GetLastErrMsg();

        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strerr.c_str() , strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );

        break;
    }

    if(kRecv.m_nOK != 0){
        g_pkUIScene->m_pkDepot->SetNPCFailFace();
    }

    if( g_pkUIScene->m_pkSellCountItemDlg && g_pkUIScene->m_pkSellCountItemDlg->IsWndState( KD3DWnd::D3DWS_ENABLED ) ) { 
        g_pkUIScene->m_pkSellCountItemDlg->OnClose();
    }

    Result_DepotItemReq = kRecv.m_nOK;

}

void On_EVENT_DEPOT_DELETE_ITEM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DEPOT_DELETE_ITEM_ACK );
    SAFE_DELETE( pkBuff );

    switch(kRecv.m_nOK)
    {
    case 0:
        {    
            GCItem* pItemData = g_pItemMgr->GetItemData( kRecv.m_kInvenItem.m_ItemID / 10);
            if( pItemData->eItemType < 0 ) {     // 영구 
                SiKGCDepotManager()->SwapPetInfo( kRecv.m_kDepotItem, g_MyD3D->m_mapDepotPetInfo, g_MyD3D->m_mapPetInfo );
                SiKGCDepotManager()->DelDepotItem( kRecv.m_kDepotItem );
                g_pItemMgr->m_kInventory.AddItem( kRecv.m_kInvenItem, true );
                SiKGCDepotManager()->AddInvenItem( kRecv.m_kInvenItem.m_ItemUID );
            }
            else {  // 수량
                if( KItem::INVENTORY == kRecv.m_kDepotItem.m_cInvenType ||      
                    0 == kRecv.m_kDepotItem.m_nCount ) {    // 창고에서 해당 아이템 모두 꺼내는 경우 
                        SiKGCDepotManager()->DelDepotItem( kRecv.m_kDepotItem, true );          // 창고에서 제거 
                }
                else {      // 해당 아이템 일부만 꺼내는 경우 
                    SiKGCDepotManager()->DelDepotItem( kRecv.m_kDepotItem, true, true );    // 창고갱신
                }
                g_pItemMgr->m_kInventory.AddItem( kRecv.m_kInvenItem, true );               // 인벤갱신
                SiKGCDepotManager()->AddInvenItem( kRecv.m_kInvenItem.m_ItemUID );
            }

            g_pkUIScene->m_pkDepot->UpdateDepotData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        }
        break;
    case NetError::ERR_DEPOT_00:
        // 아이템이 인벤토리에 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_00) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    case NetError::ERR_DEPOT_04:
        // 영구 아닌 기간제 아이템을 창고로 보관 시도함.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_04) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    case NetError::ERR_DEPOT_05:
        // 창고에 없는 아이템.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_05) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    case NetError::ERR_DEPOT_06:
        //창고에서 인벤토리로 옮기기 실패
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_06) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;

    case NetError::ERR_DEPOT_07:
        //창고 아이템 타입이 아닌데 창고에서 삭제 시도 
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_07) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;

    default:
        NetError::SetLastError(kRecv.m_nOK);
        std::wstring strerr = NetError::GetLastErrMsg();
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strerr.c_str() , strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );

        break;
    }

    if(kRecv.m_nOK != 0){
        g_pkUIScene->m_pkDepot->SetNPCFailFace();
    }

    Result_DepotItemReq = kRecv.m_nOK;


}

//NetError::ERR_DEPOT_00 // 아이템이 인벤토리에 없음.
//NetError::ERR_DEPOT_02 // 창고 슬롯이 비어있지 않음.
//NetError::ERR_DEPOT_05 // 창고에 없는 아이템.
//NetError::ERR_DEPOT_08 // 창고에서 슬롯 위치 이동 실패.
void On_EVENT_DEPOT_MOVE_ITEM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DEPOT_MOVE_ITEM_ACK );
    SAFE_DELETE( pkBuff );

    switch(kRecv.m_nOK)
    {
    case 0:
        SiKGCDepotManager()->DelDepotItem(kRecv.m_kSrcItem);
        SiKGCDepotManager()->AddDepotItem(kRecv.m_kSrcItem, true);
        g_pkUIScene->m_pkDepot->UpdateDepotData();
        break;
    case NetError::ERR_DEPOT_00: // 아이템이 인벤토리에 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_00) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    case NetError::ERR_DEPOT_02: // 창고 슬롯이 비어있지 않음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_02) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    case NetError::ERR_DEPOT_05: // 창고에 없는 아이템.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_05) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    case NetError::ERR_DEPOT_08: // 창고에서 슬롯 위치 이동 실패.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_08) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    default:
        NetError::SetLastError(kRecv.m_nOK);
        std::wstring strerr = NetError::GetLastErrMsg();
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strerr.c_str() , strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );

        break;
    }

    if(kRecv.m_nOK != 0){
        g_pkUIScene->m_pkDepot->SetNPCFailFace();
    }

    Result_DepotItemReq = kRecv.m_nOK;

}

//NetError::ERR_DEPOT_00  // 아이템이 인벤토리에 없음.
//NetError::ERR_DEPOT_10  // 확장할 창고 정보가 없음.
//NetError::ERR_DEPOT_11  // 창고 최대 크기를 초과하여 확장할 수 없음.
//NetError::ERR_DEPOT_12  // 창고 확장 아이템 DB 수량 동기화 실패.

void On_EVENT_DEPOT_EXTEND_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DEPOT_EXTEND_ACK );
    SAFE_DELETE( pkBuff );

    switch(kRecv.m_nOK)
    {
    case 0:
        g_pItemMgr->m_kInventory.AddItem(kRecv.m_kUseItem, true);
        SiKGCDepotManager()->SetCharacterDepotInfo(kRecv.m_kDepot);
        g_pkUIScene->m_pkDepot->UpdateDepotData();

        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();

        if(kRecv.m_nExtendType == KDepotExtend::TAB_EXTEND){
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_SUCCESS_EXTEND_SAFE) , 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        }
        else{
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_DEPOT_SUCCESS_EXTEND_SLOT, "i", 10 ) , 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        }


        break;
    case NetError::ERR_DEPOT_00:  // 아이템이 인벤토리에 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_00) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    case NetError::ERR_DEPOT_10:  // 확장할 창고 정보가 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_10) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    case NetError::ERR_DEPOT_11:  // 창고 최대 크기를 초과하여 확장할 수 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_11) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    case NetError::ERR_DEPOT_12:  // 창고 확장 아이템 DB 수량 동기화 실패.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_12) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    case NetError::ERR_DEPOT_14:  // 창고 확장 아이템 DB 수량 동기화 실패.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_12) , 
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;

    default:
        NetError::SetLastError(kRecv.m_nOK);
        std::wstring strerr = NetError::GetLastErrMsg();
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strerr.c_str() , strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );

        break;
    }

    if(kRecv.m_nOK != 0){
        g_pkUIScene->m_pkDepot->SetNPCFailFace();
    }

    Result_DepotItemReq = kRecv.m_nOK;
}

void On_EVENT_UPDATE_DEPOT_DATA_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_UPDATE_DEPOT_DATA_ACK );
    SAFE_DELETE( pkBuff );
    
    kRecv.m_vecDepotItem; // 창고 UID 변화( before, after )
    kRecv.m_vecInvenItem; // 인벤 UID 변화 

    // 창고, 인벤 아이템을 검사하여 UID 새로 발급 된것들은 정보 교체해준다. 
    std::vector< std::pair< GCITEMUID, GCITEMUID > >::const_iterator itDepot  = kRecv.m_vecDepotItem.begin();
    for( ; itDepot != kRecv.m_vecDepotItem.end() ; ++itDepot ) { 
        KItem* pDepotItem = SiKGCDepotManager()->GetDepotItemInfo( itDepot->first );
        if( NULL == pDepotItem ) { 
            continue;
        }

        if( pDepotItem->m_ItemUID == itDepot->first && pDepotItem->m_bReserveNewUID ) {
            KItem tempItem = *pDepotItem;
            tempItem.m_ItemUID = itDepot->second;
            tempItem.m_bReserveNewUID = false;

            SiKGCDepotManager()->DelDepotItem( *pDepotItem );
            SiKGCDepotManager()->AddDepotItem( tempItem );
        }
    }

    std::vector< std::pair< GCITEMUID, GCITEMUID > >::const_iterator itInven = kRecv.m_vecInvenItem.begin();
    for( ; itInven != kRecv.m_vecInvenItem.end() ; ++itInven ) { 
        KItem* pInvenItem = g_pItemMgr->m_kInventory.FindItemByItemUID( itInven->first );
        if( NULL == pInvenItem ) { 
            continue;
        }

        if( pInvenItem->m_ItemUID == itInven->first && true == pInvenItem->m_bReserveNewUID ) { 
            KItem tempItem = *pInvenItem;
            tempItem.m_ItemUID = itInven->second;
            tempItem.m_bReserveNewUID = false;

            g_pItemMgr->m_kInventory.RemoveItem( pInvenItem->m_ItemUID );
            g_pItemMgr->m_kInventory.AddItem( tempItem );
        }
    }

    // UI업데이트 
    g_pkUIScene->m_pkDepot->UpdateDepotData();
    g_pkUIScene->m_pkMyInfoScene->UpdateData();
    g_pkUIScene->m_pkMyInfoScene->UpdateGameData();

    Result_DepotUpdateItemReq = 0;
}
void On_EVENT_JOB_MISSION_GUIDE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_JOB_MISSION_GUIDE_NOT );
    SAFE_DELETE( pkBuff );
#ifdef __PANHO__
	return;
#endif
    g_pkUIScene->m_pkTransferMissionScrollGuideDlg->SetMissionGuideInfo( kRecv );
}

void On_EVENT_ADD_SKILL_SLOT_OPEN_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ADD_SKILL_SLOT_OPEN_ACK );
    SAFE_DELETE( pkBuff );
    // S->C. 편지함 갱신 결과
    // kRecv.m_nOK; // 결과값
    //     0 : 성공
    //     1 : 재료 아이템이 인벤토리에 없음.
    //     2 : 재료 아이템이 몬스터 카드가 아님.
    //     3 : 재료 아이템 보유량이 부족함.
    //     4 : 재료 수량이 최소 개수를 미만.
    //     5 : 재료 수량이 최대 개수를 초과.
    //     6 : 보상할 아이템이 없음.
    //     7 : 몬스터카드 조합 DB처리 실패.
    // kRecv.m_vecDecreaseCountItem; // 감소된 수량 아이템 (해당 아이템 수량 갱신하고, 수량이 0이하면 인벤토리에서 삭제해주세요)
    // kRecv.m_vecRewards; // 획득 아이템 (수량감소 처리 후 획득 아이템 넣어주세요)

    // S->C. 편지함 갱신 결과
    // kRecv.m_nOK; // 결과값
    //     0 : 성공
    //     1 : 재료 아이템이 인벤토리에 없음.
    //     2 : 재료 아이템이 몬스터 카드가 아님.
    //     3 : 재료 아이템 보유량이 부족함.
    //     4 : 재료 수량이 최소 개수를 미만.
    //     5 : 재료 수량이 최대 개수를 초과.
    //     6 : 보상할 아이템이 없음.
    //     7 : 몬스터카드 조합 DB처리 실패.
    // kRecv.m_vecDecreaseCountItem; // 감소된 수량 아이템 (해당 아이템 수량 갱신하고, 수량이 0이하면 인벤토리에서 삭제해주세요)
    // kRecv.m_vecRewards; // 획득 아이템 (수량감소 처리 후 획득 아이템 넣어주세요)


    switch(kRecv.m_nOK)
    {
    case 0:
        {
            SiGCSKT()->SetOpenSkillSlotIndex( kRecv.m_mapSlotOpenInfo );
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecUseItem , true);
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData(); 
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString( STR_ID_OPEN_CHANGE_SKILL_SLOT_SUCCESS, "l", GCFUNC::GetCharName( g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar().iCharType ) )
                , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true, true );            
        }
        break;
    case 1:  // 아이템이 인벤토리에 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_DEPOT_ERR_DEPOT_00) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true );
        break;
    case 2:  // 창고 최대 크기를 초과하여 확장할 수 없음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_PLANT_TREE_04) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true );
        break;
    case 3:  
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_OPEN_CHANGE_SKILL_SLOT_ERROR_03) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true );
        break;
    case 4:  
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_OPEN_CHANGE_SKILL_SLOT_ERROR_04) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true );
        break;
    case 5:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_RECOMMEND_ERROR_MESSAGE4) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true );
        break;
    default:
        NetError::SetLastError(kRecv.m_nOK);
        std::wstring strerr = NetError::GetLastErrMsg();
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strerr.c_str() , strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, true );

        break;
    }
}

void On_EVENT_MONSTER_CARD_MIX_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MONSTER_CARD_MIX_INFO_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK :
    //  0 : 성공
    //  1 : 스크립트 정보가 비었음
    //  2 : 이벤트 기간이 아님
    // kRecv.m_mapGradePoint    : 카드등급별 포인트
    // kRecv.m_mapPointReward   : 획득 카드 그룹 확률
    // kRecv.m_mapRewardGroup   : 그룹별 카드 구성

    switch(kRecv.m_nOK)
    {
    case 0:
        g_MyD3D->m_kItemMgr.SetMonsterCardScriptInfoFromServer( kRecv );
        g_pkUIScene->m_pkMonsterCardCompose->UpdateSendReq();
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_MONSTER_CARD_COMPOSE_DLG );
        break;
    default:
        NetError::SetLastError( kRecv.m_nOK );
        std::wstring strerr = NetError::GetLastErrMsg();
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_EXPID_IMPOSSIBLE ) , strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        break;
    }
}

void On_EVENT_SKILL_UPDATE_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KChangeUserSkillBroad );
    SAFE_DELETE( pkBuff );
}


void On_EVENT_SONGKRAN_SCRIPT_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SONGKRAN_SCRIPT_INFO_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK :
    //  0 : 성공
    //  1 : 송크란 이벤트 기간이 아님.
    // kRecv.m_fPlayerCharMoveSpeed   : 유저 캐릭터 이동 속도
    // kRecv.m_fWaterBombFlyingSpeed  : 물풍선 비행 속도
    // kRecv.m_fWaterBombRange        : 물풍선 폭발 범위
    // kRecv.m_nSupplyInterval        : 물폭탄 충전 주기(간격)
    // kRecv.m_nSupplyDuration        : 물폭탄 충전 개수
    // kRecv.m_dwDailySupplyDuration  : 일일 첫 접속 충전 개수
    // kRecv.m_mapTargetInfoList      : 타겟 정보 맵
    // kRecv.m_mapGradeRewardList     : 보상 목록

	switch ( kRecv.m_nOK ) 
	{
	case 0:
		{
			SiGCSongkranEventManager()->SetInfoData( kRecv );
		}
		break;
	case 1:
		{
            if ( g_pkUIScene->m_pkSongkranDlg )
            {
                g_pkUIScene->m_pkSongkranDlg->Close();
            }
			g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_SONGKRAN_EVENT_ERROR04), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
		}
	default:
		{
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        }
        break;
    };
}


void On_EVENT_SONGKRAN_USER_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SONGKRAN_USER_INFO_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK :
    //  0 : 성공
    //  1 : 송크란 이벤트 기간이 아님.
    //  2 : DB에서 데이터 동기화 실패.
    // kRecv.m_dwScore              : 유저 현재 점수
    // kRecv.m_dwGrade              : 유저 현재 등급
    // kRecv.m_dwWaterBombDuration  : 물풍선 개수
    // kRecv.m_nAccTime             : 물풍 충전까지 기다린 시간
    // kRecv.m_bFinish              : 금일 지급 종료 여부
    
    switch ( kRecv.m_nOK ) 
    {
    case 0:
    case 2:
        {
            SiGCSongkranEventManager()->SetUserInfo( kRecv );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_SONGKRAN_DLG );
        }
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        }
        break;
    };
}

void On_EVENT_SONGKRAN_WATERBOMB_USE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SONGKRAN_WATERBOMB_USE_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK :
    //  0 : 성공
    //  1 : 송크란 이벤트 기간이 아님.
    //  3 : 물풍선교환 아이템이 인벤토리에 없음.
    //  6 : 보상을 획득해야 진행할 수 있다.
    //  8 : 한번에 최대 획득 가능한 스코어 이상을 요구함.
    // dwWaterBombDuration : 물풍선 개수
    // kRecv.m_dwScore     : 물풍선 사용 후 점수
    // kRecv.m_nAccTime    : 물풍 충전까지 기다린 시간

	switch ( kRecv.m_nOK ) 
	{
	case 0 :
		{
			SiGCSongkranEventManager()->SetBombCount( kRecv.dwWaterBombDuration );
			SiGCSongkranEventManager()->SetScore( kRecv.m_dwScore );
		}
		break;
    case 1:
        {
            if ( g_pkUIScene->m_pkSongkranDlg )
            {
                g_pkUIScene->m_pkSongkranDlg->Close();
                g_pkUIScene->m_pkWorldMapContainer->GetSonkranWaterEffect()->RenderMapEffect(false);
                g_pkUIScene->m_pkWorldMapContainer->GetSonkranWaterEffect()->ToggleRender( false );
            }
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_SONGKRAN_EVENT_ERROR04), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
	case 3:
		{
			g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_SONGKRAN_EVENT_ERROR01),
				L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
		}
		break;
	case 6:
		{
			g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_SONGKRAN_EVENT_ERROR02),
				L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);

        }
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        }
        break;
    };

    g_pkUIScene->m_pkSongkranDlg->UpdateResultScore();
}

void On_EVENT_SONGKRAN_GRADE_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SONGKRAN_GRADE_REWARD_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK :
    //  0 : 성공
    //  1 : 송크란 이벤트 기간이 아님.
    //  4 : 등급 보상 정보 가져오기 실패.
    //  5 : DB에서 보상 아이템 지급 실패.
    //  7 : 등급 보상 정보 가져오기 실패
    //  9 : DB에서 보상 아이템 지급 실패
    // 10 : 유저의 등급정보가 올바르지 않다.
    // kRecv.m_dwGrade   : 보상 받은 아이템의 등급
    // kRecv.m_vecReward : 보상 아이템 정보
    
    switch ( kRecv.m_nOK ) 
    {
    case 0 :
        {
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecReward, true );

            if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
                g_pkUIScene->m_pkMyInfoScene->UpdateGameData();

            SiGCSongkranEventManager()->SetGrade( kRecv.m_dwGrade );
            SiGCSongkranEventManager()->SetReqReward( false );

            
            for( UINT i = 0; i < (int)kRecv.m_vecReward.size(); ++i ) 
            {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_SONGKRAN_REWARD_DLG, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, kRecv.m_vecReward[i].m_ItemID * 10, 1, true, true );
            }

            g_pkUIScene->m_pkSongkranDlg->GetRewardItem();
            g_pkUIScene->m_pkSongkranDlg->UpdateRewardData();

		}
		break;
    case 1:
        {
            if ( g_pkUIScene->m_pkSongkranDlg )
            {
                g_pkUIScene->m_pkSongkranDlg->Close();
                g_pkUIScene->m_pkWorldMapContainer->GetSonkranWaterEffect()->RenderMapEffect(false);
                g_pkUIScene->m_pkWorldMapContainer->GetSonkranWaterEffect()->ToggleRender( false );
            }
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_SONGKRAN_EVENT_ERROR04), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
	default:
		{
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
            
            SiGCSongkranEventManager()->SetReqReward( false );
        }
        break;
    }
}

void On_EVENT_SONGKRAN_WATERBOMB_SUPPLY_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SONGKRAN_WATERBOMB_SUPPLY_NOT );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK :
    //  0 : PERIOD_SUPPLY           물풍선 지급 됨
    //  1 : PERIOD_SUPPLY_LAST      물풍선 지급 됨 ( 금일 물풍선 지급 종료입니다. )
    //  2 : FIRST_CONNECTION_SUPPLY 첫 접속 물풍선 지급
    // kRecv.dwWaterBombDuration : 물풍선 아이템 정보 KItemVec

    switch ( kRecv.m_nOK ) 
    {
    case 0:
        {
            SiGCSongkranEventManager()->SetBombCount( kRecv.m_dwWaterBombDuration );
            g_pkUIScene->m_pkSongkranDlg->UpdateBombCount();

            SiGCSongkranEventManager()->SetLastSupplyNot( false );

        }
        break;
    case 1:
        {
            SiGCSongkranEventManager()->SetBombCount( kRecv.m_dwWaterBombDuration );
            g_pkUIScene->m_pkSongkranDlg->UpdateBombCount();

                SiGCSongkranEventManager()->SetLastSupplyNot( true );
            
        }
        break;
    case 2:
        {
            GCItem* pItem = g_pItemMgr->GetItemData( KGCItemManager::ITEM_SONGKRAN_WATER_BOMB );
            std::wstring strMsg;

            DWORD dwCount = SiGCSongkranEventManager()->GetDailySupplyDuration();
            
            if ( pItem ) 
                strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE1, "l", pItem->strItemName );

            if ( !SiKGCChannelManager()->CheckChannel( CT_AUTOMATCH ) )
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strMsg, L"" );
        }
        break;
    default:
        break;
    }



}


void On_EVENT_SONGKRAN_WATERBOMB_EXCHANGEITEM_USE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SONGKRAN_WATERBOMB_EXCHANGEITEM_USE_ACK );
    SAFE_DELETE( pkBuff );

    // kRecv.m_nOK :
    //  0 : 성공
    //  3 : 물풍선교환 아이템이 인벤토리에 없음.
    // 11 : 풍선 교환 캐시 아이템 개수 체크 실패.
    // 12 : 풍선 교환 캐시 아이템 개수 동기화 실패.
    // 13 : 풍선 아이템 DB 갯수 갱신 실패.
    // kRecv.m_dwWaterBombDuration : 사용 후 지급 된 개수
    // kRecv.m_vecUseItem          : 사용 아이템 정보

    switch( kRecv.m_nOK ) 
    {
    case 0:
        {
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecUseItem, true );

            if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
                g_pkUIScene->m_pkMyInfoScene->UpdateGameData();

            SiGCSongkranEventManager()->SetBombCount( kRecv.m_dwWaterBombDuration );
            g_pkUIScene->m_pkSongkranDlg->UpdateBombCount();
            
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_SONGKRAN_CHANGE_ITEM), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );

        }
        break;
    case 3:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_SONGKRAN_EVENT_ERROR06),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        }
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );
        }
        break;
    }	
}

void On_EVENT_ATTEND_GET_CHAR_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ATTEND_GET_CHAR_ACK );
    SAFE_DELETE( pkBuff );

    // m_nOK 값은 무시하세요. 값 없음.
    // 여기에 들어있는 아이템을 팝업 해주면 됨. ( 설정은 1개인데 vector 에 넣음 )
    if( kRecv.m_vecRewardItem.empty() ) { 
        return;
    }

    g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewardItem , true);
    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"",KGCUIScene::GC_MBOX_USE_NORMAL,  kRecv.m_vecRewardItem[0].m_ItemID, 0, true, false );

    std::vector< KItem >::const_iterator itemItr = kRecv.m_vecRewardItem.begin();
    for( ; itemItr != kRecv.m_vecRewardItem.end() ; ++itemItr ) { 
        g_pkUIScene->m_pkItemReceiveBox->AddItem( itemItr->m_ItemUID, itemItr->m_nCount );
    }
    g_pkUIScene->m_pkItemReceiveBox->SetEnableSell( false );
    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_ITEM_RECEIVE, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );

    if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
    {
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
    }

}

void On_EVENT_ADVENTURE_MISSION_MONSTER_DATA_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ADVENTURE_MISSION_MONSTER_DATA_NOT );
    SAFE_DELETE( pkBuff );
    
    SiGCAdventureManager()->SetDungeonCollectData( kRecv );
}

void On_EVENT_ADVENTURE_USER_COLLECT_DATA_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ADVENTURE_USER_COLLECT_DATA_NOT );
    SAFE_DELETE( pkBuff );
    
    SiGCAdventureManager()->SetCollectData( kRecv );
}

void On_EVENT_ADVENTURE_DATA_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ADVENTURE_DATA_ACK );
    SAFE_DELETE( pkBuff );
    //0 : 성공
    //1: 이벤트 기간이 아님, 
    //2: 모험 이벤트 보상 정보가 없음
    //16 : 접속시 모험 이벤트 정보 가져오기 성공.
    Result_GcAdventureEvent = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0:
        {
            SiGCAdventureManager()->OnEventAdventureDataAck( kRecv );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_GC_ADVENTURE_DLG );
            break;
        }
    case 1:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, false, true );
            break;
        }
    case 2:    
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GC_ADVENTURE_REWARD_INFO_ERR ) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
            break;
        }
    case 16:
        {
            SiGCAdventureManager()->OnEventAdventureDataAck( kRecv );
            break;
        }
    default:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
            break;
        }
    }

 
}

void On_EVENT_ADVENTURE_CONTINENT_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ADVENTURE_CONTINENT_REWARD_ACK );
    SAFE_DELETE( pkBuff );
    // 0 : 성공
    // 1 : 이벤트기간이아님 
    // 2 : 모험 이벤트 보상 정보가 없음
    // 3 : 요청한대륙의보상아이템을이미받았음 
    // 4 : 모험이벤트대륙보상정보가없음 
    // 5 : 요청한대륙의보상아이템이보상리스트에없음 
    // 6 : 대륙 보상 받기 DB 실패
    // 7 : 대륙 보상 받기 DB 실패2
    // 13 : 대륙보상을받을조건이아님 

    // -98 : 아직처리중인작업입니다.

    Result_ContinentRewardReq = kRecv.m_nOK;

    switch ( kRecv.m_nOK)
    {
    case 0:
        {
            if ( kRecv.m_vecReward.begin() != kRecv.m_vecReward.end() ) {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, kRecv.m_vecReward.begin()->m_ItemID/10, 0, false, true );

                g_pkUIScene->m_pkGcAdventureDlg->LockRewardBtn();
                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecReward, true);

                if( g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO ||
                    g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO_FROM_ROOM ) {
                        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
                        g_pkUIScene->m_pkMyInfoScene->UpdateData();
                }
            }
            else
            {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
            }
            break;
        }
    case 1:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, false, true );
            break;
        }
    case 2:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_GC_ADVENTURE_REWARD_INFO_ERR ) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
            break;
        }
    case 3:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GC_ADVENTURE_ALREADY_OBTAIN) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
            break;
        }
    case 4:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GC_ADVENTURE_CONTINENT_REWARD_ERR ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
            break;
        }
    case 13:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GC_ADVENTURE_REWARD_CONDITION_ERR ) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
            break;
        }
    default:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
            break;
        }
    }

}

void On_EVENT_ADVENTURE_FINAL_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ADVENTURE_FINAL_REWARD_ACK );
    SAFE_DELETE( pkBuff );

    Result_ContinentRewardReq = kRecv.m_nOK;

    switch ( kRecv.m_nOK)
    {
    case 0:
        {
            if ( kRecv.m_vecReward.begin() != kRecv.m_vecReward.end() ) {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, kRecv.m_vecReward.begin()->m_ItemID/10, 0, true, true , false);
                g_pkUIScene->m_pkGcAdventureDlg->LockRewardBtn();
                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecReward, true);

                if( g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO ||
                    g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO_FROM_ROOM ) {
                        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
                        g_pkUIScene->m_pkMyInfoScene->UpdateData();
                }
            }
            else {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false );
            }


            SiGCAdventureManager()->OnEventAdventureDataAck( kRecv.m_kAdventureData );
            break;
        }
    case 1:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD) , L"", KGCUIScene::GC_MBOX_USE_NORMAL , 0, 0, true, true, false );
            break;
        }
    case 2:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GC_ADVENTURE_REWARD_INFO_ERR ) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false );
            break;
        }
    case 3:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GC_ADVENTURE_ALREADY_OBTAIN) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false );
            break;
        }
    case 4:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString( STR_ID_GC_ADVENTURE_CONTINENT_REWARD_ERR ) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false );
            break;
        }
    case 13:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GC_ADVENTURE_REWARD_CONDITION_ERR ) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false );
            break;
        }
    case 14:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_GC_ADVENTURE_FINAL_REWARD_ERR ) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false );
            break;
        }
    default:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false );
            break;
        }
    }

}


void On_EVENT_LEVEL_RESET_EVENT_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_LEVEL_RESET_EVENT_INFO_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK :
    //  0 : 성공
    // kRecv.m_nLevel;               // 목표 달성 레벨
    // kRecv.m_mapResetItemList;     // 리셋 아이템 리스트
    // kRecv.m_vecRewardItemList;    // 보상 리스트
    // kRecv.m_mapResetCharInfo;     //  리셋한 캐릭터정보 및 보상 여부




    switch( kRecv.m_nOK ) 
    {
    case 0 :
        {
            SiKGCLevelResetEventManager()->SetLevelResetEventInfo( kRecv );
        }
        break;
    default:
        {
        }
        break;
    }
}



void On_EVENT_LEVEL_RESET_EVENT_ITEM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_LEVEL_RESET_EVENT_ITEM_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK :
    //  0 : 성공
    //  1 : 이벤트 기간이 아닙니다.
    //  2 : 아이템이 인벤토리에 없음
    //  3 : 수량이 모자람
    //  4 : 캐릭터 초기화 DB에 업데이트 실패
    //  5 : 캐릭터 초기화 경험치 DB에 업데이트 실패
    //  6 : 캐릭터 타입이 잘못되었다.
    //  7 : 캐릭터 미션 삭제 실패
    //  8 : 아이템 개수 동기화 실패
    //  -99 : 알수 없는 오류



    switch( kRecv.m_nOK ) 
    {
    case 0 :
        {
            if ( -1 == kRecv.m_cCharType ) 
                break;

            SCharInfo &sCharInfo = g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar( kRecv.m_cCharType );
            if( sCharInfo.iCharType == kRecv.m_cCharType )
            {
                // 레벨과 경험치 갱신
                sCharInfo.biExp = kRecv.m_biExp;
                
                unsigned char cResultLevel = Exp_2_Level(sCharInfo.biExp);
                sCharInfo.iLevel = cResultLevel;
                
                sCharInfo.kSkillInfo = kRecv.m_kSkillInfo;
            }

            // 스킬 업데이트
            for(int iLoop=-1; iLoop<4; ++iLoop)
            {
                SiGCSKT()->_D_UnAllTrainSkill( (EGCCharType)kRecv.m_cCharType, iLoop );
                SiGCSKT()->_D_UnAllEquip_Skill( (EGCCharType)kRecv.m_cCharType, iLoop, SiGCSKT()->GetSetting( kRecv.m_cCharType, iLoop ) );
            }

            // 남은 스킬들 정보 받아 다시 갱신해 줍니다. 
            SiGCSKT()->Server_SetTrainedSkill( kRecv.m_mapTrainedSkill );
            g_pkUIScene->m_pkSkillTree->ThreadSafeUpdate();

            SiGCSKT()->ApplySettingToServer();


            //  코디 아이템을 갱신합니다. ( 장비 보다 먼저 갱신해야됨 ) 
            {
                g_MyD3D->m_TempPlayer.AllUnEquipCoordiItem( kRecv.m_cCharType );
            }

            //  장비 아이템을 갱신합니다.
            {
                g_MyD3D->m_TempPlayer.AllUnEquipItem( kRecv.m_cCharType );
            }

            // 글로벌 유저정보갱신
            g_MyD3D->m_TempPlayer.RemovePlayerObject();
            g_MyD3D->m_TempPlayer.UpdatePlayerResource(true);
            g_MyD3D->m_TempPlayer.UpdateGlobalUserInfo();

            int iIndex = g_MyD3D->Get_MyPlayer();
            if ( iIndex < MAX_PLAYER_NUM && iIndex >= 0 )
            {
                g_MyD3D->MyPlayer[iIndex]->SetMyPlayer();
            }

            g_MyD3D->m_TempPlayer.SetMyPlayer(-1);

            // 아이템 수량갱신
            g_pItemMgr->m_kInventory.AddItem( kRecv.m_kItem, true );
            g_pItemMgr->UpdateUserItem( &g_kGlobalValue.m_kUserInfo );


            // 장비창 갱신
            if( g_pkUIScene->m_pkMyInfoScene->m_pkStatusPanel )
            {
                g_pkUIScene->m_pkMyInfoScene->m_pkStatusPanel->ResetInfo();
                g_pkUIScene->m_pkMyInfoScene->m_pkStatusPanel->SetStartUserInfo();
                g_pkUIScene->m_pkMyInfoScene->m_pkStatusPanel->SetChangeUserInfo();
                g_pkUIScene->m_pkMyInfoScene->m_pkStatusPanel->SetText();
            }            
            

            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();            
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            g_pkUIScene->m_pkMyInfoScene->UpdateCharInfo();

            
            //  미션 삭제 
            {
                std::vector<DWORD>::iterator iter = kRecv.m_vecMissionList.begin();
                std::vector<DWORD>::iterator iter_end = kRecv.m_vecMissionList.end();

                for ( ; iter != iter_end; ++iter )
                {
                    g_kGlobalValue.m_kUserMission.DeleteMission( *iter );
                }

                g_kGlobalValue.m_kUserMission.RefreshUserMission();
                g_pkUIScene->m_pkMissionUI_S4->RefreshUI();
            }

            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_LEVER_RESET_ITEM_USE_OK ) );
        }
        break;
    case 1 : 
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NOT_EVENT_PERIOD ), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
    case 2 : 
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_LEVER_RESET_ITEM_USE_ERROR01 ), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );            
        }
        break;
    default:
        {
            std::wstring strTemp = boost::str( boost::wformat( L"%1% (%2%)" )%g_pkStrLoader->GetString( STR_UNKWON_ERROR )%kRecv.m_nOK);
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strTemp, L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
    }
}

void On_EVENT_LEVEL_RESET_EVENT_REWARD_ACK( WPARAM wParam, LPARAM lParam ) //상하이 드랍 단독
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_LEVEL_RESET_EVENT_REWARD_ACK );
    SAFE_DELETE( pkBuff );

    if ( kRecv.m_nOK == 0 )
    {
        for ( int i = 0; i < (int)kRecv.m_vecRewardItem.size(); ++i ) 
        {
            GCItem* pItem = g_pItemMgr->GetItemData( kRecv.m_vecRewardItem[i].m_ItemID / 10 );
            if( NULL == pItem ) { 
                continue;
            }

            std::wstring strMsg = g_pkStrLoader->GetString( STR_ID_LEVER_RESET_REWARD_OK );

            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_REPETITION_EVENT_BOX, strMsg, L"", KGCUIScene::GC_MBOX_USE_NORMAL, pItem->dwGoodsID * 10, 1, false, false );        
        }

        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewardItem, true );
    }
}

void On_EVENT_TEST_ADD_ITEM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_TEST_ADD_ITEM_ACK );
    SAFE_DELETE( pkBuff );

    if ( kRecv.m_nOK == 0 ) 
    {
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewardItem , true);
    }
    else
    {
#if !defined(__PATH__)
        g_pkChatManager->AddChatMsg( L"Faild AddItem", KGCChatManager::CHAT_TYPE_ALERT );
#endif
    }
}

void On_EVENT_SHUTDOWN_CHECKIN_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SHUTDOWN_CHECKIN_INFO_NOT );
    SAFE_DELETE( pkBuff );

    if( kRecv.m_bCheckInSuccess == false ) {    // 셧다운에 의해 접속 막힘 
        
        // 일단 기본 셧다운 
        g_kGlobalValue.m_bShutDown = true;
        g_kGlobalValue.m_iShutDownType = 0;

        std::vector< KShutdownInfo >::const_iterator vit = kRecv.m_vecShutdownInfo.begin();
        for( ; vit != kRecv.m_vecShutdownInfo.end() ; ++vit ) { 
            int iShutdownType = g_kGlobalValue.GetShutDownInfoType( vit->m_nShutdownCheckResult );
            if( iShutdownType != -1 ) { 
                g_kGlobalValue.m_bShutDown = true;
                g_kGlobalValue.m_iShutDownType = iShutdownType;
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_SHUTDOWN, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 5, g_kGlobalValue.m_iShutDownType, true, true );
            }
        }
    }
}

void On_EVENT_SHUTDOWN_CHECKOUT_INFO_NOT( WPARAM wParam, LPARAM lParam )       
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SHUTDOWN_CHECKOUT_INFO_NOT );
    SAFE_DELETE( pkBuff );

    switch( kRecv.m_uiNotiType ) { 
        case KEVENT_SHUTDOWN_CHECKOUT_INFO_NOT::CHECKOUT_REQ:
            g_kGlobalValue.m_bShutDown = true;
            g_kGlobalValue.m_iShutDownType = kRecv.m_uiShutdownKind;
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_SHUTDOWN, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 5, g_kGlobalValue.m_iShutDownType, true, true );
            break;

        case KEVENT_SHUTDOWN_CHECKOUT_INFO_NOT::REMAIN_TIME_NOT:
            g_kGlobalValue.AddShutDownMsg( static_cast< KShutdownInfo::EShutdownInfo >( kRecv.m_uiShutdownKind ), kRecv.m_uiRemainTime );
            break;

        default:
            break;
    }
}

void On_EVENT_OLYMPIC_SCHEDULE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_OLYMPIC_SCHEDULE_ACK );
    SAFE_DELETE( pkBuff );
    /*
    kPacket.m_nOK, 0 // 성공.
    kPacket.m_nOK, 1 // 올림픽 이벤트 기간이 아님.
    kPacket.m_nOK, -98 // 아직 처리중인 작업입니다.
    */

    switch( kRecv.m_nOK ) { 
        case 0:
            SiGCOlympicManager()->SetInfoState( true );
            SiGCOlympicManager()->SetScheduleList( kRecv.m_vecOlympicSchedule );
            break;

        case 1:
            break;

        case -98:
            break;

        default:
            break;
    }

    Result_OlympicEven_Data = kRecv.m_nOK;
}

void On_EVENT_OLYMPIC_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_OLYMPIC_INFO_ACK );
    SAFE_DELETE( pkBuff );

    // 0번과 9번의 경우에는 성공 처리를 해야 한다.
    /*
    kPacket.m_nOK, 0 // 성공.
    kPacket.m_nOK, 1 // 올림픽 이벤트 기간이 아님.
    kPacket.m_nOK, 9 // DB에서 데이터 이미 가져왔음.
    kPacket.m_nOK, 10 // 유저 TimeIndex정보 가져오기 실패.
    kPacket.m_nOK, 11 // 유저 누적 포인트 정보 가져오기 실패.
    kPacket.m_nOK, -98 // 아직 처리중인 작업입니다.
    */

    switch( kRecv.m_nOK ) { 
        case 0:
        case 9:
            SiGCOlympicManager()->SetOlympicInfo( kRecv );
            break;

        case 1:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NOT_EVENT_PERIOD ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
            break;

        case 10:
        case 11:
            g_pkUIScene->m_pkOlympicDlg->SetStartBtnState( false );
            break;

        case -98:
            break;

        default:
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, false);
            break;

    }

    Result_OlympicEven_Data = kRecv.m_nOK;
}

void On_EVENT_OLYMPIC_JOIN_GAME_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_OLYMPIC_JOIN_GAME_ACK );
    SAFE_DELETE( pkBuff );

    /*
    kPacket.m_nOK, 0 // 성공.
    kPacket.m_nOK, 1 // 올림픽 이벤트 기간이 아님.
    kPacket.m_nOK, 2 // 설정된 게임의 정보가 없음.
    kPacket.m_nOK, 7 // 올림픽 게임참여 가능한 날짜가 아님.
    kPacket.m_nOK, 8 // 올림픽 게임참여 보상 아이템 DB지급 실패.
    kPacket.m_nOK, -98 // 아직 처리중인 작업입니다.
    */

    switch ( kRecv.m_nOK )
    {
        case 0:
            SiGCOlympicManager()->OlympicStartGame( kRecv );
            break;
        case 1:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NOT_EVENT_PERIOD ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
            break;
        default:
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, false);
            break;
    }

}

void On_EVENT_OLYMPIC_ALARM_NOT( WPARAM wParam, LPARAM lParam )
{
    // 전달되는 패킷 내용없음.
    // 해당 패킷은 서버에서 30분이 되면 보내는 알림패킷으로 해당 패킷이 전달되는 시점부터
    // 30분동안 게임 플레이 가능.
    if( g_pkUIScene->m_pkOlympicDlg->IsRenderOn() ){
        g_pkUIScene->m_pkOlympicDlg->Onclose();
    }

    if( g_MyD3D->m_pStateMachine->GetState() != GS_GAME 
        || GC_GM_MINIGAME_BALLOON == SiKGCRoomManager()->GetGameMode()
        || GC_GM_MINIGAME_TREEDROP == SiKGCRoomManager()->GetGameMode()
        ) {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_OLYMPIC_GAME_ALRAM), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
    }

    SiGCOlympicManager()->OlympicQuitCurrentGame();
}

void On_EVENT_OLYMPIC_TREEDROP_RESULT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_OLYMPIC_TREEDROP_RESULT_ACK );
    SAFE_DELETE( pkBuff );

    /*
    kPacket_.m_nOK, 0 // 성공.
    kPacket_.m_nOK, 1 // 올림픽 이벤트 기간이 아님.
    kPacket_.m_nOK, 2 // 설정된 게임의 정보가 없음.
    kPacket_.m_nOK, 6 // 올림픽 누적 포인트가 최대치임.
    kPacket_.m_nOK, -98 // 아직 처리중인 작업입니다.
    */

    switch ( kRecv.m_nOK )
    {
        case 0:
        case 6:
            SiGCOlympicManager()->ShowMinigameReward();
            break;
        case 1:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NOT_EVENT_PERIOD ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
            break;
        default:
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, false);
            break;
    }
}

void On_EVENT_OLYMPIC_BALLOON_RESULT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_OLYMPIC_BALLOON_RESULT_ACK );
    SAFE_DELETE( pkBuff );

    /*
    kPacket_.m_nOK, 0 // 성공.
    kPacket_.m_nOK, 1 // 올림픽 이벤트 기간이 아님.
    kPacket_.m_nOK, 2 // 설정된 게임의 정보가 없음.
    kPacket_.m_nOK, 6 // 올림픽 누적 포인트가 최대치임.
    kPacket_.m_nOK, -98 // 아직 처리중인 작업입니다.
    */

    switch ( kRecv.m_nOK )
    {
        case 0:
        case 6:
            SiGCOlympicManager()->ShowMinigameReward();
            break;
        case 1:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NOT_EVENT_PERIOD ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
            break;
        default:
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, false);
            break;
    }
}

void On_EVENT_OLYMPIC_WATERBOMB_RESULT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_OLYMPIC_WATERBOMB_RESULT_ACK );
    SAFE_DELETE( pkBuff );

    /*
    kRecv.m_nOK, 0 // 성공.
    kRecv.m_nOK, 1 // 올림픽 이벤트 기간이 아님.
    kRecv.m_nOK, 2 // 설정된 게임의 정보가 없음.
    kRecv.m_nOK, 3 // 도전 포인트가 모자람.
    kRecv.m_nOK, 5 // 올림픽 누적 포인트 DB 갱신 실패.
    kRecv.m_nOK, 6 // 올림픽 누적 포인트가 최대치임.
    kRecv.m_nOK, 12 // 물폭탄으로 획득한 포인트 없음.
    kRecv.m_nOK, -98 // 아직 처리중인 작업입니다.
    */

    switch ( kRecv.m_nOK )
    {
    case 0:
        g_pkUIScene->m_pkOlympicSongkranDlg->ResultSongkranInfo(kRecv); 
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NOT_EVENT_PERIOD ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_SONGKRAN_EVENT_ERROR01),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        break;
    case 12:
        g_pkUIScene->m_pkOlympicSongkranDlg->ResultSongkranInfo(kRecv);
        break;
    default:
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
            KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );
        break;
    }

    g_pkUIScene->m_pkOlympicSongkranDlg->UpdateResultScore();
}

void On_EVENT_OLYMPIC_GAWIBAWIBO_RESULT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_OLYMPIC_GAWIBAWIBO_RESULT_ACK );
    SAFE_DELETE( pkBuff );

    /*
    kRecv.m_nOK, 0 // 성공.
    kRecv.m_nOK, 1 // 올림픽 이벤트 기간이 아님.
    kRecv.m_nOK, 2 // 설정된 게임의 정보가 없음.
    kRecv.m_nOK, 3 // 도전 포인트가 모자람.
    kRecv.m_nOK, 4 // 지정된 도전 포인트 정보가 없음.
    kRecv.m_nOK, 5 // 올림픽 누적 포인트 DB 갱신 실패.
    kRecv.m_nOK, 6 // 올림픽 누적 포인트가 최대치임.
    kRecv.m_nOK, -98 // 아직 처리중인 작업입니다.
    */

    switch ( kRecv.m_nOK )
    {
    case 0:
        g_pkUIScene->m_pkOlympicGawibawiboDlg->ResultGawiBawiBoGame( kRecv );
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NOT_EVENT_PERIOD ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GAWIBAWIBO_ERR_9),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        g_pkUIScene->m_pkOlympicGawibawiboDlg->SetCloseBtn();
        break;
    default:
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
            KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );        
        
        g_pkUIScene->m_pkOlympicGawibawiboDlg->SetCloseBtn();
        break;
    }
}

void On_EVENT_OLYMPIC_DICEPLAY_RESULT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_OLYMPIC_DICEPLAY_RESULT_ACK );
    SAFE_DELETE( pkBuff );

    /*
    kRecv.m_nOK, 0 // 성공.
    kRecv.m_nOK, 1 // 올림픽 이벤트 기간이 아님.
    kRecv.m_nOK, 2 // 설정된 게임의 정보가 없음.
    kRecv.m_nOK, 3 // 도전 포인트가 모자람.
    kRecv.m_nOK, 5 // 올림픽 누적 포인트 DB 갱신 실패.
    kRecv.m_nOK, 6 // 올림픽 누적 포인트가 최대치임.
    kRecv.m_nOK, -98 // 아직 처리중인 작업입니다.
    */

    switch( kRecv.m_nOK )
    {
    case 0:
        g_pkUIScene->m_pkOlympicDicePlayDlg->PlayResult( kRecv );
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_NOT_EVENT_PERIOD ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GAWIBAWIBO_ERR_9),
            L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        g_pkUIScene->m_pkOlympicDicePlayDlg->SetCloseBtn();
        break;
    default:
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
            KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, false, true );

        g_pkUIScene->m_pkOlympicDicePlayDlg->SetCloseBtn();
        break;
    }
}

void On_EVENT_OLYMPIC_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_OLYMPIC_REWARD_ACK );
    SAFE_DELETE( pkBuff );

    /*
    0 // 성공.
    1 // 올림픽 이벤트 기간이 아님.
    8 // 올림픽 게임참여 보상 아이템 DB지급 실패.
    13 // 해당 등급의 보상 받을수 없음.
    14 // 등급 보상 아이템 정보 가져오기 실패.
    -98 // 아직 처리중인 작업입니다.
    */

    switch( kRecv.m_nOK ) { 
        case 0:
            // 아이템 추가 
            for( std::vector< KItem >::iterator vit = kRecv.m_vecRewardItem.begin() ; vit != kRecv.m_vecRewardItem.end() ; ++vit ) {
                GCItem* pItem = g_pItemMgr->GetItemData( vit->m_ItemID / 10 );
                if( NULL == pItem ) { 
                    continue;
                }

                g_pItemMgr->m_kInventory.AddItem( *vit, true );
                std::wstring strMsg = g_pkStrLoader->GetReplacedString( STR_ID_ITEM_RECEIVE1, "l", pItem->strItemName );
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_REPETITION_EVENT_BOX, strMsg, L"", KGCUIScene::GC_MBOX_USE_NORMAL, pItem->dwGoodsID * 10, vit->m_ItemUID, false, true );
            }

            // 갱신
            SiGCOlympicManager()->SetRewardGrade( kRecv.m_dwGrade );
            g_pkUIScene->m_pkOlympicDlg->SetRewardSlot();

            // 인벤토리 업데이트 
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
            g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();
            
            break;
        default:
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true, false );
            break;

    }

}

void On_EVENT_OLYMPIC_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( bool );
    SAFE_DELETE( pkBuff );

    //bool == true 이벤트 기간
    SiGCOlympicManager()->SetOlympicEventAlram( kRecv );
}

void On_EVENT_GACHA_LOTTERY_ITEM_INFO_NOT(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_GACHA_LOTTERY_ITEM_INFO_NOT);
    SAFE_DELETE(pkBuff);

    g_kGlobalValue.m_mapGachaSuccessList = kRecv.m_mapGachaSuccessList;
    g_kGlobalValue.m_mapGachaFailedList = kRecv.m_mapGachaFailedList;
}

void On_EVENT_GACHA_LOTTERY_ACTION_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_GACHA_LOTTERY_ACTION_ACK);
    SAFE_DELETE(pkBuff);

    switch (kRecv.m_nOK)
    {
    case 0:

        g_pkUIScene->m_pkLottery->SetTempRewardItem(&kRecv.m_vecRewardItem);

        if (kRecv.m_dwRewardType == 0)
        {
            g_pkUIScene->m_pkLottery->SetShowImgAtSuccess(kRecv.m_DisplayItemID);
            g_pkUIScene->m_pkLottery->SetSuccessVar(true);
        }
        else if (kRecv.m_dwRewardType == 1)
        {
            g_pkUIScene->m_pkLottery->SetShowImgAtFail();
        }
        g_pItemMgr->m_kInventory.AddItem(kRecv.m_kUseLotteryItem, true);
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        KItem* pLotteryItem = NULL;
        if (g_pItemMgr->FindInventoryForItemID(ITEM_GACHA_LOTTERY, &pLotteryItem))
            g_pkUIScene->m_pkLottery->SetLotteryDuration(pLotteryItem->m_nCount);
        else
            g_pkUIScene->m_pkLottery->SetLotteryDuration(0);

        break;
    }
    Result_BuyForLottery = kRecv.m_nOK;
}

void On_EVENT_NEW_CHAR_CHOICE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_NEW_CHAR_CHOICE_ACK );
    SAFE_DELETE( pkBuff );
    /*
    kPacket_.m_nOK, 0  // 성공
    kPacket_.m_nOK, 1  // 아이템을 보유하고 있지 않음.
    kPacket_.m_nOK, 2  // 캐릭터 획득 DB 작업실패.
    kPacket_.m_nOK, 3 ); // 캐릭터 생성할 수 있는 슬롯이 부족함.
    kPacket_.m_nOK, 4 ); // 캐릭터 닉네임 중복.
    kPacket_.m_nOK, 5 ); // 캐릭터 닉네임 추가 DB 작업실패.
    kPacket_.m_nOK, 6 ); // 캐릭터 닉네임에 부적절한 단어가 포함되어 있음.
    kPacket_.m_nOK, 7 ); // 캐릭터 획득 후 DB 정보 가져오기 실패
    kPacket_.m_nOK, 8 ); // 캐릭터 획득 후 퀵슬롯이 비어있지 않음
    kPacket_.m_nOK, 9 ); // DB에서 계정이 존재하지 않음.
    kPacket_.m_nOK, 10 ); // DB에 획득할려는 캐릭터가 이미 존재함.
    kPacket_.m_nOK, 11 ); // DB에 이미 캐릭터에 슬롯번호가 있음
    kPacket_.m_nOK, 12 ); // DB에 생성할려는 슬롯에 캐릭터가 있음
    kPacket_.m_nOK, 13 ); // 캐릭터를 생성하기 위한 특정 레벨 이상의 캐릭터가 없음.
    kPacket_.m_nOK, -98 // 아직 처리중인 작업입니다.
    */

    Result_New_Character = kRecv.m_nOK;

    switch(kRecv.m_nOK)
    {
    case 0:
        {
            SCharInfo Info;
            GCFUNC::ConvertCharInfo( Info, kRecv.m_kCharacterInfo );
            g_kGlobalValue.m_kUserInfo.m_nSlotCount = kRecv.m_dwUserRemainIndexCnt;
    
            // 스킬정보 안비었으면 스킬 정보도 
            if( !kRecv.m_vecSPInfo.empty() ) { 
                Info.m_vecSPInfo = kRecv.m_vecSPInfo;

                std::vector< KSPInfo >::const_iterator itSPInfo = kRecv.m_vecSPInfo.begin();
                for( ; itSPInfo != kRecv.m_vecSPInfo.end() ; ++itSPInfo ) { 
                  SiGCSKT()->SetNewCharacterTrainedSkill( *itSPInfo );
                }
                Result_SkillSet = INT_MAX;
                SiGCSKT()->ApplySettingToServer();
                g_MyD3D->WaitForServerAck( Result_SkillSet, INT_MAX, 5000, TIME_OUT_VALUE );
                
                
                for( std::vector< KSPInfo >::iterator vitSPInfo = kRecv.m_vecSPInfo.begin(); vitSPInfo != kRecv.m_vecSPInfo.end() ; ++vitSPInfo ) { 
                    for ( std::vector< int >::iterator vitID = vitSPInfo->m_vecSkills.begin() ; vitID != vitSPInfo->m_vecSkills.end() ; ++vitID ){
                        SiGCSKT()->SetHotKeyIndexToEmpty(static_cast<char>(Info.iCharType),Info.iPromotionLevel);
                        SiGCSKT()->EquipSkill( static_cast<EGCSkillTree>(*vitID), 0);
                    }

                }
                Result_SkillSet = INT_MAX;
                SiGCSKT()->ApplySettingToServer();
                g_MyD3D->WaitForServerAck( Result_SkillSet, INT_MAX, 5000, TIME_OUT_VALUE );

                
            }

            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewardItem, true );
            g_pItemMgr->EquipBaseItem( &Info );
            g_kGlobalValue.m_kUserInfo.AddChar( Info, true );
            g_kGlobalValue.m_mapChangeWeapon.insert(std::pair<char,std::pair<bool,GCITEMUID>>(kRecv.m_kCharacterInfo.m_cCharType,std::pair<bool,GCITEMUID>(kRecv.m_kCharacterInfo.m_bChangeWeaponLock,kRecv.m_kCharacterInfo.m_kChangeWeaponItem.m_dwUID)));

            g_MyD3D->m_TempPlayer.m_kUserInfo.AddChar( Info );
            g_MyD3D->m_TempPlayer.m_kUserInfo.SetCurrentChar( Info.iCharType );

            g_MyD3D->m_TempPlayer.UpdateGlobalUserInfo();
            
            // 전용던전 관련 체크
            SiKGCPrivateDungeonManager()->CheckFirstDungeon( kRecv.m_kCharacterInfo.m_cCharType );

            g_kGlobalValue.m_iGetCharType = -1;

            GCFUNC::CharGainParticle(Info.iCharType);
            
            g_MyD3D->m_OriginalEquip = g_MyD3D->m_TempPlayer.m_kUserInfo;
            g_MyD3D->m_OriginalEquip = g_MyD3D->m_TempPlayer.m_kUserInfo;
            for(std::vector<KItem>::iterator vit = kRecv.m_vecRewardItem.begin(); vit != kRecv.m_vecRewardItem.end(); ++vit )
            {
                //여기로 UID가 들어옴
                GCItem* kItem = g_pItemMgr->GetItemData( vit->m_ItemID / 10  );
                g_pItemMgr->EquipInventoryItem(&g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar(), vit->m_ItemUID, vit->m_cItemType & KItem::TYPE_LOOK );
            }

            g_MyD3D->SendEquipItemList( &g_MyD3D->m_TempPlayer );


            int iUserIndex = g_MyD3D->Get_Player( g_kGlobalValue.m_kUserInfo.dwUID );
            if ( g_MyD3D->MyPlayer[iUserIndex] != NULL )
                g_MyD3D->MyPlayer[iUserIndex]->m_kUserInfo = g_kGlobalValue.m_kUserInfo;

            // 봉인 캐릭터 정보 갱신 
            g_kGlobalValue.m_mapSealedCharInfo = kRecv.m_kSealedCharInfoNot.m_mapSealedCharInfo;

            g_MyD3D->m_pStateMachine->GoCharSelect();
        }
        break;
    case 3:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_CREATE_CHAR_NO_SLOT_ERROR ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true );
        }
        break;
    case -4: // 부적절한 닉네임(빈칸, 탭, \', 욕설, 크기가0, 제한크기초과..등)
        {
            //MessageBox( eMessageBoxType , L"", L"", GC_MBOX_USE_NORMAL,0,0, true);
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
                g_pkStrLoader->GetString( STR_ID_NICK_NAME_INVALID_CHAR ),
                g_pkStrLoader->GetString( STR_ID_NICK_NAME_ANOTHER_USE ), KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true );

        }
        break;
    case 4: //이미 존재하고 있는 닉네임이 있음.(다른 유저가 이미 등록했음)
    case 5: // DB에 닉네임 추가시 실패( 팀명이랑 중복 문제 인듯... )
        {
            //MessageBox( eMessageBoxType , L"", L"", GC_MBOX_USE_NORMAL,0,0, true);
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
                g_pkStrLoader->GetString( STR_ID_NICK_NAME_ALREADY_EXIST ),
                g_pkStrLoader->GetString( STR_ID_NICK_NAME_ANOTHER_USE ), KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true );            
        }
        break;
    case 13:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_DIO_CHAR_CREATE_ERROR ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true );
        }
        break;
    case -5: //부적절한 길이(크기가0, 제한크기초과)
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,
                g_pkStrLoader->GetString( STR_ID_NICK_NAME_INVALID_LENGTH ),
                g_pkStrLoader->GetString( STR_ID_NICK_NAME_INVALID_LENGTH2 ), KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true );

        }
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_CHARACTER_ACQUIRE_UNKNOWN_ERROR ), strTemp );
        }
        break;
    }
}

void On_EVENT_NEW_CHAR_CARD_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_NEW_CHAR_CARD_INFO_NOT );
    SAFE_DELETE( pkBuff );

    g_pItemMgr->SetCharacterCardInfo(kRecv);
    g_pItemMgr->VerifyCharCardInfo();
}

void On_EVENT_CHAR_LEVEL_REWARD_EVENT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CHAR_LEVEL_REWARD_EVENT_NOT );
    SAFE_DELETE( pkBuff );

    if( !kRecv.m_setCharInfo.empty() ) { 
        // 아이템 넣고 
        g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewardItem, true );
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();

        // 알림 띄워주고 
        g_pkUIScene->SetLevelItemDlgInfo( GC_GLOBAL_DEFINE::iLevelItemAlram, kRecv.m_setCharInfo );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_LEVEL_ITEM_DLG );
    }
       
}

void On_EVENT_USER_CHANGE_WEAPON_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_USER_CHANGE_WEAPON_NOT );
    SAFE_DELETE( pkBuff );
    
    g_kGlobalValue.m_mapChangeWeapon.swap( kRecv );
    std::map<char,std::pair<bool,GCITEMUID> >::iterator mit = g_kGlobalValue.m_mapChangeWeapon.begin();
    for ( ; mit != g_kGlobalValue.m_mapChangeWeapon.end(); ++mit )
    {
        g_MyD3D->m_TempPlayer.m_mapSwapWeapon[(*mit).first] = std::make_pair<bool, std::pair<GCITEMID,GCITEMUID>>(false, std::make_pair/*<GCITEMID,GCITEMUID>*/((GCITEMID)0,(*mit).second.second));
    }
}

void On_EVENT_ITEM_COMPOSE_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ITEM_COMPOSE_INFO_NOT );
    SAFE_DELETE( pkBuff );

    SiGCItemCombinationManager()->OnItemComposeInfoNOT( kRecv );
    SiGCItemCombinationManager()->SetEventPeriod( true );
}

void On_EVENT_ITEM_COMPOSE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ITEM_COMPOSE_ACK );
    SAFE_DELETE( pkBuff );
    /*
    kPacket.m_nOK, 0 // 성공
    kPacket.m_nOK, 1 //  아이템 합성 이벤트 기간이 아님.
    kPacket.m_nOK, 2 //  재료 갯수가 서버 설정값이랑 틀림.
    kPacket.m_nOK, 3 //  재료 아이템이 인벤토리에 존재하지 않음.
    kPacket.m_nOK, 4 //  서버에서 설정된 재료 아이템이 아님.
    kPacket.m_nOK, 5 //  보상 아이템 정보 가져오기 실패.
    kPacket.m_nOK, 6 //  보상 아이템 DB 지급실패.
    kPacket.m_nOK, -98 // 아직 처리중인 작업입니다.
    */
    Result_Item_Combination = kRecv.m_nOK;

    switch ( kRecv.m_nOK )
    {
    case 0:
        {
            if( !kRecv.m_vecMaterialInfo.empty() ) {
                g_pItemMgr->m_kInventory.RemoveItemList( kRecv.m_vecMaterialInfo );
            }

            if ( !kRecv.m_vecReward.empty() ){

                GCITEMID itemID = 0;
                
                for( int i = 0 ; i < (int)kRecv.m_vecReward.size() ; i++){
                    itemID =  kRecv.m_vecReward[i].m_ItemID / 10;
                    g_pkUIScene->m_pkTreaureItemBox->SetItem( itemID  );
                    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, itemID, 0, false, true );
                }
                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecReward , true);
            }

            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();

            g_pkUIScene->m_pkItemCombinationDlg->InitData();
        }
        break;
    case 1:
        {
            //이벤트 기간이 아닙니다.
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( 8125 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
    case 2:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ITEM_COMBINATION_ERROR1 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            g_pkUIScene->m_pkItemCombinationDlg->InitData();
        }
        break;
    case 3:
        {
            //재료 아이템이 인벤에 없습니다.
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_USE_TRAINING_OBJ_FAIL5 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            g_pkUIScene->m_pkItemCombinationDlg->InitData();
        }
        break;
    case 4:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_ITEM_COMBINATION_ERROR2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            g_pkUIScene->m_pkItemCombinationDlg->InitData();
        }
        break;
    case 5:
        {
            //보상 정보 가져오기 실패
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PLANT_TREE_13 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            g_pkUIScene->m_pkItemCombinationDlg->InitData();
        }
        break;
    case 6:
        {
            //DB 오류
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_RECOMMEND_ERROR_MESSAGE4 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp, 
                KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, true );

            g_pkUIScene->m_pkItemCombinationDlg->InitData();
        }
        break;
    };
}

void On_EVENT_SPECIFIC_ITEM_BREAKUP_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SPECIFIC_ITEM_BREAKUP_INFO_ACK );
    SAFE_DELETE( pkBuff );

    // 아이템 해체 정보 담겨있음
    SiGCForgeManager()->SetItemBreakUpInfo( kRecv );
}

void On_EVENT_SKILL_OPENKEY_USE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SKILL_OPENKEY_USE_ACK );
    SAFE_DELETE( pkBuff );

    //     kPacket.m_nOK, 0 ); 
    //     kPacket.m_nOK, 1 ); // 존재하지않는스킬입니다. 
    //     kPacket.m_nOK, 2 ); // 이미획득한스킬입니다. 
    //     kPacket.m_nOK, 3 ); // 해당캐릭터가존재하지않음. 
    //     kPacket.m_nOK, 4 ); // 해당전직을만족하지못함. 
    //     kPacket.m_nOK, 5 ); // 레벨을만족하지못함. 
    //     kPacket.m_nOK, 6 ); // Lock이해제되지않은스킬을배우려고함. 
    //     kPacket.m_nOK, 7 ); // 스킬오픈키아이템이없음. 
    //     kPacket.m_nOK, 8 ); // 스킬오픈키로오픈가능한스킬이아님. 
    //     kPacket.m_nOK, -98 ); // 아직처리중인작업입니다.


    if( kRecv.m_nOK == 0 )
    {
        if( true == SiGCSKT()->Server_TrainSkill( kRecv.m_nSkillID ) )
        {
            SiGCSKT()->EquipSkill( (EGCSkillTree)kRecv.m_nSkillID, g_pkUIScene->m_pkSkillTree->GetSetID() );
            g_pkUIScene->m_pkSkillTree->ThreadSafeUpdate();
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_TRAINSKILL_SUCCESS ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );   
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecUseItem );
            return;
        }
        else
        {
            kRecv.m_nOK = -1;
        }
    }

    switch( kRecv.m_nOK )
    {
    case -98: // 98      처리가 지연되고 있음.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_PACKET_DELAY ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 2: // 2   이미 획득한 스킬입니다.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_ALREADY_EXIST ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 4: // 5   해당 전직을 만족하지 못함.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_TRAIN_CONDITION_ERROR2 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 5: // 6   레벨을 만족하지 못함.
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_TRAIN_CONDITION_ERROR3 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 7: // 스킬오픈키아이템이없음. 
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_TRAIN_ERROR_NOITEM ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    case 8: // 스킬오픈키로오픈가능한스킬이아님. 
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_TRAIN_IMPOSSIBLE_SKILL ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        break;
    default: // 알 수 없는 오류
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", KUserEvent::EVENT_SKILL_OPENKEY_USE_ACK, kRecv.m_nOK );	
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_TRAINSKILL_ERROR ),
                strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
            break;
        }
    }
}
void On_EVENT_MATCH_INVITE_FRIEND_LIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MATCH_INVITE_FRIEND_LIST_ACK );
    SAFE_DELETE( pkBuff );

    switch ( kRecv.m_nOK ) {
        case 0 :
            SiKGCMatchInviteManager()->SetFriendList(kRecv.m_vecMatchInviteList);
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_MATCH_INVITE_USER_LIST_BOX);
            g_pkUIScene->m_pkMatchInviteUserList->UpdateUserList(0);
            break;
        default:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_INVITE_FRIEND_LIST_ERR0));
            break;
    }

    Result_MatchPartyUserList = kRecv.m_nOK;

}

void On_EVENT_PARTY_USER_READY_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );
    // 파티원 Ready 요청시에 에러 처리( 요청보낸 파티원만 받음 )
    /*
    kPacket = -1; 보유하지 않은 캐릭터 선택해서 Ready
    */
    Result_MatchPartyReady = kRecv;

}

void On_EVENT_PARTY_USER_READY_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KPartyData );
    SAFE_DELETE( pkBuff );
    // 파티원 Ready 요청시에 전체 파티원에게 파티 변경정보 Broad

    SiKGCPartyManager()->SetPartyInfo(kRecv);
    SiKGCPartyManager()->SetPartyMemberList(kRecv.m_vecPartyPeople);
    g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );
    Result_MatchPartyReady = 0;

}

void On_EVENT_ADD_MATCH_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ADD_MATCH_ACK );
    SAFE_DELETE( pkBuff );
    // 매칭 요청후에 매칭 요청한 방장이 결과값 받음.
    /*
    kPacket.m_nOK, 0 // 성공
    kPacket.m_nOK, 2 // 존재하지 않는 캐릭터로 매칭 요청.
    kPacket.m_nOK, 3 // 파티에 방장이 멤버리스트에 없음.
    kPacket.m_nOK, 4 // 연결된 매칭 서버가 없음.
    kPacket.m_nOK, 6 // 파티장이 아닌데 매칭 요청을 했음.
    kPacket.m_nOK, 7 // 파티원이 전부 Ready상태가 아닌데 매칭 요청을 했음.
    kPacket.m_nOK, 8 // 파티원 정보가 없음.
    kPacket.m_nOK, 9 // 현재 매칭 요청가능한 시간이 아니다.
    kPacket.m_nOK, 10 // 해당 모드는 닫힌 모드이다.
    kPacket.m_nOK, -99 // 매칭 서버 등록 실패
    */

    KMatchOpenTime kOpenTime;
    switch( kRecv.m_nOK ) {
        case 0 :
            SiKGCMatchManager()->SetCurrentState(KGCMatchManager::MSTATE_WAIT_STATE);
            SiKGCMatchManager()->SetWaitMatchingTime(30,15,true);
            g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );
            break;
        case 2 :
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_ERR2));
            break;
        case 3 :
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_ERR3));
            break;
        case 4 :
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_ERR4));
            break;
        case 6 :
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_ERR5));
            break;
        case 7 :
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_ERR6));
            break;
        case 8 :
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_ERR3));
            break;
        case 9 :
            {
                if ( SiKGCMatchManager()->GetCurrentOpenTime(kOpenTime) == false )
                    return;

                std::wstring strStart = (kOpenTime.m_prBeginTime.first / 12) > 0 ? 
                    g_pkStrLoader->GetString( STR_ID_MATCH_INFO_12 ) : g_pkStrLoader->GetString( STR_ID_MATCH_INFO_11 );
                std::wstring strEnd = (kOpenTime.m_prEndTime.first / 12) > 0 ? 
                    g_pkStrLoader->GetString( STR_ID_MATCH_INFO_12 ) : g_pkStrLoader->GetString( STR_ID_MATCH_INFO_11 );

                int iStartH = (kOpenTime.m_prBeginTime.first % 12 == 0) ? 12 : (kOpenTime.m_prBeginTime.first % 12);
                int iEndH = (kOpenTime.m_prEndTime.first % 12 == 0) ? 12 : (kOpenTime.m_prEndTime.first % 12);

                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_MATCH_INFO_4, "liilii", strStart, iStartH, kOpenTime.m_prBeginTime.second, strEnd, iEndH, kOpenTime.m_prEndTime.second ) );
            }
            break;
        case -99 :
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_ERR4));
            break;
        default:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_ERR4));
            break;
    }

    Result_AddMatchReq = kRecv.m_nOK;
}

void On_EVENT_ADD_MATCH_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ADD_MATCH_BROAD );
    SAFE_DELETE( pkBuff );
    // 매칭 요청후에 파티원들이 매칭 결과에 대하여 받음.
    /*
    kPacket.m_nOK, 0 // 성공
    kPacket.m_nOK, -99 // 매칭 서버 등록 실패
    */
    switch( kRecv.m_nOK ) {
        case 0 :
            SiKGCMatchManager()->SetCurrentState(KGCMatchManager::MSTATE_WAIT_STATE);
            SiKGCMatchManager()->SetWaitMatchingTime(30,15,true);
            g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );
            break;
        case -99 :
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_ERR4));
            break;
        default:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_ERR4));
            break;
    }

}

void On_EVENT_DEL_MATCH_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );
    // 매칭 취소 요청에 대한 응답.( 매칭 취소 응답을 보낸 유저만 받음 )
    // 성공에 대해서는 EVENT_DEL_MATCH_BROAD 패킷에 함께 전달된다.
    /*
    kPacket, 4 // 연결된 매칭 서버가 없음.
    kPacket, 5 // 현재 파티가 없음.
    */

    SiKGCMatchManager()->InitMatchInfo();
    SiKGCPartyManager()->EndParty();

    g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );
    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_ERR7));

    Result_AddMatchReq = kRecv;
}

void On_EVENT_DEL_MATCH_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );
    // 매칭 취소 요청에 대하여 파장 포함 전체 파티원이 받음
    // 해당 패킷이 온다는 것은 무조건 매칭 취소가 성공했다고 보면 된다.
    SiKGCMatchManager()->InitMatchInfo();
    SiKGCPartyManager()->EndParty();

    g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );
    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_ERR7));


}

void On_EVENT_CURRENT_MATCH_MODE_COUNT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CURRENT_MATCH_MODE_COUNT_ACK );
    SAFE_DELETE( pkBuff );
    // 현재 모드의 대기 리스트 요청.
    /*
    kPacket, 0 // 성공
    kPacket, 5 // 현재 파티가 없음.
    */
    SiKGCMatchManager()->SetWaitMatchingTime(kRecv.m_nMatchModeCount,kRecv.m_nLimitMatchGroupNum,kRecv.m_bLimitMatchEnable);

}

void On_EVENT_CURRENT_MATCH_MODE_COUNT_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CURRENT_MATCH_MODE_COUNT_BROAD );
    SAFE_DELETE( pkBuff );

    SiKGCMatchManager()->SetWaitMatchingTime(kRecv.m_nMatchModeCount,kRecv.m_nLimitMatchGroupNum,kRecv.m_bLimitMatchEnable);

    // 파티원들에게 현재 모드의 요청한 대기 리스트 Broadcast.
    // 이 패킷은 실패가 없다. EVENT_CURRENT_MATCH_MODE_COUNT_REQ요청이 성공하면 무조건 온다.
}

void On_EVENT_DISCONNECT_MATCHSERVER_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );
    // 매칭 서버랑 연결 끊김이 발생하였을 때 알림 패킷.
    // 해당 패킷은 채널대기 상태에서 매칭 대기중인 유저( 솔로, 매칭파티원 )들에 한해서만 알려준다.
    // 매칭 파티가 존재한다면 파티 초기화 해주는 부분 필요.( 매칭 취소랑 동일 처리 필요 )

    SiKGCMatchManager()->InitMatchInfo();
    SiKGCPartyManager()->EndParty();
    g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );

}

void On_EVENT_FIND_MATCH_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_FIND_MATCH_NOT );
    SAFE_DELETE( pkBuff );
    // m_nOK값이 0이 아니면 매칭을 찾았는데 데이터 오류로 실패가 된 case이다.
    // 매칭을 찾고 나서 std::map 컨테이너에 현재 함께 할 파티원 리스트를 팀별로 구분해서 전달한다.

    switch ( kRecv.m_nOK ) {
        case 0 :
            SiKGCMatchManager()->SetCurrentState( KGCMatchManager::MSTATE_FIND_USER_STATE );
            SiKGCMatchManager()->SetMatchCompleteUser(kRecv.m_mapPartyMember);
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_MATCH_COMPLETE_DLG );
            g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );
            break;
        default :
            SiKGCMatchManager()->InitMatchInfo();
            SiKGCPartyManager()->EndParty();
            g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );
            break;
    }

}

void On_EVENT_ACCEPT_MATCH_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ACCEPT_MATCH_BROAD );
    SAFE_DELETE( pkBuff );
    // 매칭이 수락되고 난뒤 각 파티원들의 수락/거절 상태를 전달하고 현재 유저의 수락상태를 전달한다.
    // 수락상태는 KPartyMember.m_dwState값의 US_READY로 체크한다.
    bool bClose = true;

    switch ( kRecv.m_nOK ) {
        case 0 :
            SiKGCMatchManager()->SetMatchCompleteUser(kRecv.m_mapPartyMember);
            g_pkUIScene->m_pkMatchCompleteDlg->SetUserInfo();
            
            for ( std::map<int, std::vector<KPartyMember> >::iterator mit = kRecv.m_mapPartyMember.begin() ; mit != kRecv.m_mapPartyMember.end() ; ++mit ) {
                for ( std::vector<KPartyMember>::iterator vit = mit->second.begin() ; vit != mit->second.end() ; ++vit ) {
                    if ( vit->m_dwState != KPartyMember::US_READY ) {
                        bClose = false;
                    }
                }
            }
            g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );
            if ( bClose && !kRecv.m_mapPartyMember.empty()) { 
                SiKGCMatchManager()->SetCurrentState( KGCMatchManager::MSTATE_COMPLETE_STATE );
                g_pkUIScene->m_pkMatchCompleteDlg->OnCloseDlgDirect();
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_AUTOMATCH_LOADING);
                g_pkUIScene->m_pkAutoMatchLoading->SetUserInfo();
                SiKGCMatchManager()->SetRoomUser();
            }
            break;
        default :
            g_pkUIScene->m_pkMatchCompleteDlg->SetCancelUser(kRecv.m_dwAcceptUserUID);
            SiKGCPartyManager()->EndParty();
            SiKGCMatchManager()->InitMatchInfo();
            g_pkUIScene->m_pkMatchCompleteDlg->OnCloseDlg();
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_ERR7));
            g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );
            break;
    }
}

void On_EVENT_START_GAME_POSSIBLE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );

    // 시작 가능한지 체크하는 EVENT_START_GAME_POSSIBLE_REQ에 대한 응답.
    // 0이 아니면 아직 시작 불가능.
    Result_StartGamePossibleReq = kRecv;
}

void On_EVENT_START_GAME_FAIL_NOT( WPARAM wParam, LPARAM lParam )
{
    // 이게 오면 무조건 룸에서 나간다.
    // 정상적으로 방을 나감. (대회서버에선 RP깎아달라고 요청합니다.)
    
    if ( g_MyD3D->m_pStateMachine->GetState() == GS_ROOM ) {
        bool bSubtractRP = false;
        if( g_kGlobalValue.ServerInfo.CheckServerType( ST_INDIGO ) && g_MyD3D->GetPlayerNum() > 1 )
        {
            bSubtractRP = true;
        }

        // 2010-10-12, shmhlove, 레디 상태였다면 메시지박스와 유저상태를 변경합니다.
        if( g_kGlobalValue.m_kUserInfo.nUserState == GC_RUS_READY )
        {
            g_pkUIScene->ClearWaitMessageBox();
            g_pkUIScene->EnableMessageBox( true );
            g_kGlobalValue.m_kUserInfo.nUserState = GC_RUS_WAIT;
        }

        //m_pkRoomUserPanel->ClearUserEnchant();

        g_MyD3D->m_pStateMachine->ExitRoom( true, KFailRate::P2P_NO_ERROR, bSubtractRP );
        SiKGCRoomManager()->SetPlayedHeroDungeon(false);
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_ERR7));
    }
    else {
        SiKGCMatchManager()->InitMatchInfo();
        SiKGCPartyManager()->EndParty();
        g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_AUTO_MATCH_ERR7));
    }
}

void On_EVENT_MATCH_TIME_TABLE_NOT( WPARAM wParam, LPARAM lParam )
{
    // 대전 PVP서버에서만 현재 매칭 채널 오픈 정보 전달.
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MATCH_TIME_TABLE_NOT );
    SAFE_DELETE( pkBuff );
    
    SiKGCMatchManager()->SetMatchOpenTime(kRecv);
    g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );

}

void On_EVENT_MATCH_MODE_STATE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MATCH_MODE_STATE_ACK );
    SAFE_DELETE( pkBuff );

    SiKGCMatchManager()->SetMatchModeState(kRecv);
    g_pkUIMgr->SendEvent( KActionEvent( NULL,  KGCUIScene::D3DWE_UPDATE_MATCH ) );

}

void On_EVENT_MATCH_ALARM_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MATCH_ALARM_NOT );
    SAFE_DELETE( pkBuff );

    //enum ALARM_TYPE
    //{
    //	AT_ALARM_OPEN = 0,   // open
    //	AT_ALARM_CLOSE,      // close
    //	AT_MAX,
    //};

    //int                         m_nAlarmType;   // AlarmType
    //int                         m_nMinute;      // 출력할 시간 분
    //std::pair<int,int>          m_prOpenTime;   // 오픈시간
    //std::pair<int,int>          m_prCloseTime;  // 종료시간

    int iStrID = kRecv.m_nAlarmType == KEVENT_MATCH_ALARM_NOT::AT_ALARM_OPEN ? STR_ID_MATCH_INFO_8 : STR_ID_MATCH_INFO_9;
    
    g_pkChatManager->AddChatMsgTo( g_MyD3D->m_pStateMachine->GetState(), g_pkStrLoader->GetReplacedString(iStrID,"iiiii", 
        kRecv.m_prOpenTime.first,
        kRecv.m_prOpenTime.second,
        kRecv.m_prCloseTime.first,
        kRecv.m_prCloseTime.second,
        kRecv.m_nMinute), 
        KGCChatManager::CHAT_TYPE_ADMIN, 
        false, L"", 
        0xffff00 );
}

void On_EVENT_HERO_ITEM_UPGRADE_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
	KSerializer ks;
	ACK_DESERIALIZE( KEVENT_HERO_ITEM_UPGRADE_INFO_ACK );
	SAFE_DELETE( pkBuff );

	// std::map< std::pair<DWORD, int>, KHeroItemUpgradeInfo > KEVENT_HERO_ITEM_UPGRADE_INFO_ACK;
	// DWORD : 아이템 굿스 아이디
	// KHeroItemUpgradeInfo는 UserPacket.h에 정의 되어 있음

    g_kGlobalValue.m_kHeroDungeonInfo.SetHeroItemUpgradeInfo( kRecv );
    Result_HeroItemList = 0;
}

void On_EVENT_HERO_ITEM_UPGRADE_ACK( WPARAM wParam, LPARAM lParam )
{
 	KSerializer ks;
 	ACK_DESERIALIZE( KEVENT_HERO_ITEM_UPGRADE_ACK );
 	SAFE_DELETE( pkBuff );

    // kRecv.m_nOK :
    //  0 : 성공
    //  1 : 성공 말고는 아직 에러값 정의하지 않음...
    // kRecv.m_vecReward			: 업그레이드로 획득 한 아이템
    // kRecv.m_vecDecreaseMaterial  : 재료로 사용 된 소모(영웅 주화) 아이템
    // kRecv.m_vecDelMaterials      : 재료로 사용 된 장비 아이템
    switch( kRecv.m_nOK ) { 
        case 0:
            {
                // 소모된 수량 아이템 
                std::vector<KItem>  vecZeroCount;
                for( std::vector<KItem>::iterator it = kRecv.m_vecDecreaseMaterial.begin() ; it != kRecv.m_vecDecreaseMaterial.end() ; ++it )
                {
                    GCITEMID itemID = it->m_ItemID/10;
                    KItem* pInvenItem = g_pItemMgr->m_kInventory.FindItemByItemID( itemID );
                    if( pInvenItem == NULL ) { 
                        continue;
                    }

                    pInvenItem->m_nCount = it->m_nCount;
                    if( pInvenItem->m_nCount <= 0 ) {
                        vecZeroCount.push_back( *(pInvenItem) );
                    }
                }

                // 소모된 영구 아이템
                std::vector<KItem> vecMaterailItem;
                for( std::vector<GCITEMUID>::iterator it = kRecv.m_vecDelMaterials.begin() ; it != kRecv.m_vecDelMaterials.end() ; ++it )
                {
                    vecMaterailItem.push_back( *(g_pItemMgr->m_kInventory.FindItemByItemUID( *it )) );
                }

                // 영구아이템에 연계 되어 있던 강화석들 처리
                std::vector<KItem> vecStrengthItem;
                for( std::vector<GCITEMUID>::iterator it = kRecv.m_vecStrengthItem.begin() ; it != kRecv.m_vecStrengthItem.end() ; ++it )
                {
                    vecStrengthItem.push_back( *(g_pItemMgr->m_kInventory.FindItemByItemUID( *it )) );
                }

                // 인벤토리에서 삭제 
                g_pItemMgr->m_kInventory.RemoveItemList( vecZeroCount );
                g_pItemMgr->m_kInventory.RemoveItemList( vecMaterailItem );
                g_pItemMgr->m_kInventory.RemoveItemList( vecStrengthItem );
            }

            // 아이템 추가 
            for( std::vector<KItem>::iterator it = kRecv.m_vecReward.begin() ; it != kRecv.m_vecReward.end() ; ++it )
            {
                g_pItemMgr->m_kInventory.AddItem( *it, true);
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetReplacedString(STR_ID_HERO_ITEM_UPGRADE_SUCCESS, "l", g_pItemMgr->GetItemName( it->m_ItemID/10) ),
                    L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
            }

            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            break;

        default:
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strTemp, L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
            break;
    }

    Result_BuyForHero = kRecv.m_nOK;
}

void On_EVENT_RITAS_CHRISTMAS_USER_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RITAS_CHRISTMAS_USER_INFO_ACK );
    SAFE_DELETE( pkBuff );

    SiGCRitasChrismasManager()->SetBaseInfo(kRecv);
	Result_ReceiveChristmasUserInfo = kRecv.m_nOK;

}

void On_EVENT_RITAS_CHRISTMAS_PLAY_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RITAS_CHRISTMAS_PLAY_INFO_ACK );
    SAFE_DELETE( pkBuff );
    SiGCRitasChrismasManager()->SetPlayInfo(kRecv);

    Result_ReceiveChristmasPlayInfo = kRecv.m_nOK;
}

void On_EVENT_RITAS_CHRISTMAS_RANK_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RITAS_CHRISTMAS_RANK_INFO_ACK );
    SAFE_DELETE( pkBuff );

    SiGCRitasChrismasManager()->SetRankInfo(kRecv);

    Result_ReceiveChristmasRankInfo = kRecv.m_nOK;

}

void On_EVENT_RITAS_CHRISTMAS_STAGE_START_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RITAS_CHRISTMAS_STAGE_START_ACK );
    SAFE_DELETE( pkBuff );

    SiGCRitasChrismasManager()->SetStageStartInfo(kRecv);

    Result_ReceiveChristmasStageStart = kRecv.m_nOK;

}

void On_EVENT_RITAS_CHRISTMAS_EMPTY_BASKET_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RITAS_CHRISTMAS_EMPTY_BASKET_ACK );
    SAFE_DELETE( pkBuff );

    SiGCRitasChrismasManager()->SetEmptyBasket(kRecv);

    Result_ReceiveChristmasBasketEmpty = kRecv.m_nOK;

}

void On_EVENT_RITAS_CHRISTMAS_STAGE_END_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RITAS_CHRISTMAS_STAGE_END_ACK );
    SAFE_DELETE( pkBuff );

	SiGCRitasChrismasManager()->SetStageClearInfo(kRecv);

    Result_ReceiveChristmasStageClear = kRecv.m_nOK;

}

void On_EVENT_RITAS_CHRISTMAS_GET_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RITAS_CHRISTMAS_GET_REWARD_ACK );
    SAFE_DELETE( pkBuff );

	SiGCRitasChrismasManager()->SetRewardInfo(kRecv);

    Result_ReceiveChristmasGetReward = kRecv.m_nOK;

}


void On_EVENT_RITAS_CHRISTMAS_EXCHANGE_CONTINUE_COIN_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RITAS_CHRISTMAS_EXCHANGE_CONTINUE_COIN_ACK );
    SAFE_DELETE( pkBuff );

    Result_ReceiveChristmasExchangeContinueCoin = kRecv.m_nOK;

    SiGCRitasChrismasManager()->SetContinueCoin( kRecv );
}

void On_EVENT_RITAS_CHRISTMAS_REWARD_VIEW_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
	KSerializer ks;
	ACK_DESERIALIZE( KEVENT_RITAS_CHRISTMAS_REWARD_VIEW_INFO_ACK );
	SAFE_DELETE( pkBuff );

	Result_ReceiveChristmasRewardItemList = kRecv.m_nOK;

	SiGCRitasChrismasManager()->SetRewarItemList( kRecv );
}

void On_EVENT_MATCH_RANK_REWARD_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MATCH_RANK_REWARD_NOT );
    SAFE_DELETE( pkBuff );

    g_kGlobalValue.m_kRanking.SetAutoMatchReward( kRecv.m_mapRPRewardInfo, kRecv.m_mapWinRecordRewardInfo );
}

void On_EVENT_MY_MATCH_RANK_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KMyMatchRankInfo );
    SAFE_DELETE( pkBuff );

    g_kGlobalValue.m_kRanking.SetMyRanking( kRecv.m_mapExpRank );
    g_kGlobalValue.m_kRanking.SetMyAutoMatchRanking( kRecv.m_mapRPMatchRank, kRecv.m_mapWinRecordRank );
}

void On_EVENT_MATCH_RANK_PAGE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MATCH_RANK_PAGE_ACK );
    SAFE_DELETE( pkBuff );

    /*
    m_cRankType Define
    MRT_RP = 0, // RP 랭킹.( 전체, 캐릭터별 )
    MRT_WINRECORD, // 다승 랭킹.( 전체, 캐릭터별 )
    MRT_BEFORE_RP, // RP 랭킹.( 이전 시즌 )
    MRT_BEFORE_WINRECORD, // 다승 랭킹 ( 이전 시즌 )
    MRT_EXP, // 경험치 랭킹.( 전체, 캐릭터별 )
    MRT_MAX,

    EXP : KExpRank 구조체 사용.
    그외 : KMatchRank 구조체 사용.
    */

    Result_GuildRankingInfo_Req = kRecv.m_nOK;

    if( kRecv.m_nOK != 0 ) 
        return; //....
    
    kRecv.m_kCompBuff.UnCompress(); // 압축 풀기.

    switch ( kRecv.m_cRankType ) 
    {
    case KMatchRank::MRT_RP:
    case KMatchRank::MRT_WINRECORD:
    case KMatchRank::MRT_BEFORE_RP:
    case KMatchRank::MRT_BEFORE_WINRECORD:
        {
            std::vector< KMatchRank > vecRankData;
            ks.BeginReading( &kRecv.m_kCompBuff );
            ks.Get( vecRankData );
            ks.EndReading();

            g_kGlobalValue.m_kRanking.SetAutoMatchRanking( kRecv.m_cRankType, kRecv.m_cCharType, kRecv.m_cPageNum, vecRankData );
        }
        break;
    case KMatchRank::MRT_EXP:
        {
            // Exp 랭킹이라면
            std::vector< KExpRank > vecExpRankData;
            kRecv.m_kCompBuff.UnCompress();
            ks.BeginReading( &kRecv.m_kCompBuff );
            ks.Get( vecExpRankData );
            ks.EndReading();

            g_kGlobalValue.m_kRanking.SetRankingPage( kRecv.m_cRankType, kRecv.m_cCharType, kRecv.m_cPageNum, vecExpRankData );
        }
        break;
    };

    g_pkUIScene->m_pkRanking->Update();
}

void On_EVENT_MATCH_RANK_SEARCH_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MATCH_RANK_SEARCH_ACK );
    SAFE_DELETE( pkBuff );
	
    /*
    kPacket.m_nOK, 1 // 랭킹 조사시 닉네임이 비어 있음. 
    kPacket.m_nOK, 2 // 랭킹 조사시 닉네임에 사용할수 없는 문자 포함. 
    kPacket.m_nOK, 3 // 랭킹 조사시 없는 랭킹 타입 입니다. 
    kPacket.m_nOK, 4 // 랭킹 조사시 없는 캐릭터 타입 입니다. 
    kPacket.m_nOK, 6 // 랭킹 정보가 없음. 
    kPacket.m_nOK, 7 // 랭킹 검색 주기가 짧음.( 1초마다 한번씩 검색 가능 )
    */	


    if( kRecv.m_nOK == 0 )
    {
        switch( kRecv.m_cRankType )
        {
        case KMatchRank::MRT_RP:
        case KMatchRank::MRT_WINRECORD:
        case KMatchRank::MRT_BEFORE_RP:
        case KMatchRank::MRT_BEFORE_WINRECORD:
            g_pkUIScene->m_pkRanking->SetFindedData( kRecv.m_kMatchRank );
            break;
        case KMatchRank::MRT_EXP:
            g_pkUIScene->m_pkRanking->SetFindedData( kRecv.m_kExpRank );
            break;
        }
    }
    else
    {
        switch( kRecv.m_nOK )
        {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
            g_pkUIScene->m_pkRanking->FindErrorMsg( STR_ID_RANKING6 );
            break;
        }
    }
}

void On_EVENT_MATCH_RANK_CHANGE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MATCH_RANK_CHANGE_NOT );
    SAFE_DELETE( pkBuff );

    // 하루 특정 시간이 지나고 랭킹 정보 갱신후에 서버로부터 받는 패킷.
    g_kGlobalValue.m_kRanking.RefreshAutoMatchRanking();
}

void On_EVENT_UPDATE_ITEM_COUNT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector< KItem > );
    SAFE_DELETE( pkBuff );

    // 아이템 수량 동기화 처리
    g_pItemMgr->m_kInventory.AddItemList( kRecv, true );
}

void On_EVENT_BUFF_DONATION_LOGIN_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BUFF_DONATION_LOGIN_INFO_NOT );
    SAFE_DELETE( pkBuff );
    // kRecv.m_dwDonationItemID     : 기부 해야 하는 아이템 ID
    // kRecv.m_biTotalDonationPoint : 전체 기부 수량
    // kRecv.m_nBuffStateFlag       : 버프 상태 (-1 : 설정 안됨, 0 : 버프 해제, 1 : 버프 발동)

    SiGCBuffDonationManager()->SetBuffDonationInfo( kRecv );
}

void On_EVENT_BUFF_DONATION_TOTAL_DATA_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BUFF_DONATION_TOTAL_DATA_NOT );
    SAFE_DELETE( pkBuff );
    // kRecv.m_biTotalDonationPoint  : 전체 기부 수량
    // kRecv.m_nBuffStateFlag        : 버프 상태 (-1 : 설정 안됨, 0 : 버프 해제, 1 : 버프 발동)

    SiGCBuffDonationManager()->OnEventBuffDonationTotalDataNot( kRecv );
}

void On_EVENT_BUFF_DONATION_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_BUFF_DONATION_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK :
    //    NetError::NET_OK                     : 성공.
    //    NetError::ERR_BUFF_DONATION_ERROR_01 : 발렌타인 기부 이벤트 기간이 아님.
    //    NetError::ERR_BUFF_DONATION_ERROR_02 : 기부하려고 하는 아이템이 실제 기부 아이템이 아님.
    //    NetError::ERR_BUFF_DONATION_ERROR_03 : 기부 하려는 아이템이 내 인벤에 없음.
    //    NetError::ERR_BUFF_DONATION_ERROR_04 : 기부 요청한 수량만큼 인벤토리에 보유하고 있지 않음.
    //    NetError::ERR_BUFF_DONATION_ERROR_05 : 기부 후 교환 받는 아이템 지급 실패.
    //    NetError::ERR_BUFF_DONATION_ERROR_06 : 기부에 사용 된 아이템 차감 실패.
    //    NetError::ERR_BUFF_DONATION_ERROR_07 : 기부 데이터 기록 실패.
    // kRecv.m_nItemCount           : 기부에 사용 된 수량
    // kRecv.m_kDonationItem        : 기부로 사용 된 아이템
    // kRecv.m_vecRewardItem        : 기부 하고 교환 받은 아이템
    // kRecv.m_biTotalDonationPoint : 전체 기부 수량

    Result_ReceiveBuffDonatingReq = kRecv.m_nOK;

    switch( kRecv.m_nOK ) {
        case NetError::NET_OK :
            SiGCBuffDonationManager()->OnEventBuffDonationAck( kRecv );
            break;
        case NetError::ERR_BUFF_DONATION_ERROR_01 :
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD));
            break;
        case NetError::ERR_BUFF_DONATION_ERROR_02 :
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_CONTRIBUTION_ERROR02));
            break;
        case NetError::ERR_BUFF_DONATION_ERROR_03 :
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_CONTRIBUTION_ERROR02));
            break;
        case NetError::ERR_BUFF_DONATION_ERROR_04 :
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_CONTRIBUTION_ERROR02));
            break;
        case NetError::ERR_BUFF_DONATION_ERROR_05 :
            //g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD));
            break;
        case NetError::ERR_BUFF_DONATION_ERROR_06 :
            //g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD));
            break;
        case NetError::ERR_BUFF_DONATION_ERROR_07 :
            //g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD));
            break;
        default:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR));
            break;
    }

}

void On_EVENT_ACCUMULATE_ATTENDANCE_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ACCUMULATE_ATTENDANCE_INFO_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK :
    //    NetError::NET_OK                             : 성공.
    //    NetError::ERR_ACCUMULATE_ATTENDANCE_ERROR_01 : 누적 출석 이벤트 기간이 아님.
    // kRecv.m_bUseImmediatelyRegisterMission             : 보상 받는 즉시 미션 등록할지 여부
    // kRecv.m_mapCumulativeAttendanceRewardList          : 누적일별 보상 전체 정보(UI출력용 데이터)
    // kRecv.m_kUserAccumulateData.m_nAccumulateCount     : 유저의 현재까지 누적 된 출석 수치
    // kRecv.m_kUserAccumulateData.m_vecRewardCompleteDay : 유저가 보상을 지급 받은 날짜 리스트

    Result_ReceiveAttendanceStampInfo = kRecv.m_nOK;

    switch( kRecv.m_nOK ) {
        case NetError::NET_OK :
            SiGCAttendanceStampManager()->SetEventInfo( kRecv );
            SiGCAttendanceStampManager()->SetUIType( kRecv.m_nClientUIType );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_ATTENDANCE_STAMP_DLG );
            break;
        case NetError::ERR_ACCUMULATE_ATTENDANCE_ERROR_01 :
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD));
            break;
        default:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR));
            break;
    }
}

void On_EVENT_ACCUMULATE_ATTENDANCE_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ACCUMULATE_ATTENDANCE_REWARD_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK :
    //    NetError::NET_OK                             : 성공.
    //    NetError::ERR_ACCUMULATE_ATTENDANCE_ERROR_01 : 누적 출석 이벤트 기간이 아님.
    //    NetError::ERR_ACCUMULATE_ATTENDANCE_ERROR_02 : 보상을 요청한 날짜가 유효하지 않다.
    //    NetError::ERR_ACCUMULATE_ATTENDANCE_ERROR_03 : 이미 보상을 받은 날짜이다.
    //    NetError::ERR_ACCUMULATE_ATTENDANCE_ERROR_04 : 해당 날짜의 보상 정보가 없다.
    //    NetError::ERR_ACCUMULATE_ATTENDANCE_ERROR_05 : 누적 출석 보상 아이템 지급 실패.
    //    NetError::ERR_ACCUMULATE_ATTENDANCE_ERROR_06 : 누적 출석 보상 지급 정보 갱신 실패(보상 중복 신청 or 유저 정보 없음)
    // kRecv.m_vecRewardItem        : 보상 지급 된 아이템
    // kRecv.m_vecRewardCompleteDay : 유저가 보상을 지급 받은 날짜 리스트

    Result_ReceiveAttendanceStampReward = kRecv.m_nOK;

    switch( kRecv.m_nOK ) {
        case NetError::NET_OK :
            SiGCAttendanceStampManager()->OnEventAccumulateAttendanceRewardAck( kRecv );
            break;
        case NetError::ERR_ACCUMULATE_ATTENDANCE_ERROR_01 :
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD));
            break;
        case NetError::ERR_ACCUMULATE_ATTENDANCE_ERROR_02 :
            //g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD));
            break;
        case NetError::ERR_ACCUMULATE_ATTENDANCE_ERROR_03 :
            SiGCAttendanceStampManager()->OnEventAccumulateAttendanceRewardAck( kRecv );
            break;
        case NetError::ERR_ACCUMULATE_ATTENDANCE_ERROR_04 :
            //g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD));
            break;
        case NetError::ERR_ACCUMULATE_ATTENDANCE_ERROR_05 :
            //g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK ,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD));
            break;
        case NetError::ERR_ACCUMULATE_ATTENDANCE_ERROR_06 :
            SiGCAttendanceStampManager()->OnEventAccumulateAttendanceRewardAck( kRecv );
            break;
        default:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR));
            break;
    }
}

void On_EVENT_PET_VESTED_ITEM_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_PET_VESTED_ITEM_NOT );
    SAFE_DELETE( pkBuff );
    /*
     펫 귀속 아이템 리스트 전달.
    */

    g_kGlobalValue.m_vecVestedItemList.clear();
    g_kGlobalValue.m_vecVestedItemList = kRecv;
}

void On_ENU_CASHBACK_RATIO_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KCashbackRatioInfo );
    SAFE_DELETE( pkBuff );

    g_kGlobalValue.m_kCashbackRatioInfo = kRecv;
}

void On_EVENT_CASHBACK_RATIO_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KCashbackRatioInfo );
    SAFE_DELETE( pkBuff );

    g_kGlobalValue.m_kCashbackRatioInfo = kRecv;
}

void On_EVENT_CASHBACK_EXTRA_RATIO_INFO_ACK ( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CASHBACK_EXTRA_RATIO_INFO_ACK  );
    SAFE_DELETE( pkBuff );

    switch( kRecv.m_nOK ) {
        case 0 :
            if( kRecv.m_nVersion != -1 ) // -1이면 진행중인 첫구매 이벤트가 없음
                g_kGlobalValue.m_nCashbackRatioFirstBuying = kRecv.m_nFirstBuyRatio;
            else
                g_kGlobalValue.m_nCashbackRatioFirstBuying = 0;
            break;
        default:
            break;
    }
}

void On_EVENT_ERRAND_INIT_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ERRAND_INIT_INFO_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK :
    //    NetError::NET_OK              : 성공.
    //    NetError::ERR_ERRAND_ERROR_01 : 심부름왕 이벤트 기간이 아니다.
    // kRecv.m_nPlayTime               : 한판 플레이 시간
    // kRecv.m_nDelayTime              : 다음 플레이까지 기다려야 하는 시간
    // kRecv.m_nTimeIncreaseRate       : 심부름 한 번 성공 시 증가 하는 시간 비율
    // kRecv.m_nMaxStage               : 최대 스테이지 숫자(최대 칭찬 횟수)
    // kRecv.m_nMarryAppearInterval    : 메리 출현 주기
    // kRecv.m_nMarryKeepAliveTime     : 메리 출현 유지 시간
    // kRecv.m_mapErrandStageInfo      : 심부름 스테이지 정보 컨테이너
    // kRecv.m_vecRewardItemForDisplay : 보상 정보(디스플레이용)
    
    switch( kRecv.m_nOK )
    {
    case NetError::NET_OK:
        SiGCChallengeErrandManager()->SetErrandInfo( kRecv );
        g_pkUIScene->m_pkChallengErranDlg->HelpRewardList();

        break;
    default:
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp );
        break;
    }
}

void On_EVENT_ERRAND_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ERRAND_REWARD_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK :
    //    NetError::NET_OK              : 성공.
    //    NetError::ERR_ERRAND_ERROR_01 : 심부름왕 이벤트 기간이 아니다.
    //    NetError::ERR_ERRAND_ERROR_02 : 성공 횟수가 유효하지 않다.
    //    NetError::ERR_ERRAND_ERROR_03 : 보상 서버 처리 실패.
    //    NetError::ERR_ERRAND_ERROR_04 : 보상 아이템 DB 처리 실패.
    // kRecv.m_vecRewardItem; // 보상 지급한 아이템

    Result_ReceiveErrandReward = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
        case NetError::NET_OK:
           SiGCChallengeErrandManager()->SetRewardItem( kRecv );
           break;
        default:
           std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
           g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp );
           break;
    }
}

void On_EVENT_ERRAND_LIST_PROVIDE_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( bool );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK :

    SiGCChallengeErrandManager()->SetPlayable(kRecv);
    if ( kRecv )
    {
        // 시간 초기화
        SiGCChallengeErrandManager()->SetLastRewardTime( 0 );
    }
}

void On_EVENT_ERRAND_GAME_END_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ERRAND_GAME_END_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK :
    //    NetError::NET_OK              : 성공.
    //    NetError::ERR_ERRAND_ERROR_01 : 심부름왕 이벤트 기간이 아니다.
    //    NetError::ERR_ERRAND_ERROR_02 : 성공 횟수가 유효하지 않다.
    // kRecv.m_bPlayAble : 현재 플레이 가능한 상태인지
    // kRecv.m_bSuccess  : 칭찬 횟수가 최대치를 만족 했는지

    Result_ReceiveErrandEnd = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case NetError::NET_OK:
        SiGCChallengeErrandManager()->SetEndGame(kRecv);
        break;
    default:
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp );
        break;
    }
}
void On_EVENT_JOIN_ROOM_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KRoomInfo );
    SAFE_DELETE( pkBuff );
    /*
    방 입장시 방원 정보 받기전 룸 정보 우선 전달.
    */
	SiKGCRoomManager()->SetRecvRoomInfo(true, kRecv);	
}

void On_EVENT_ERRAND_USER_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ERRAND_USER_INFO_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv.m_nOK :
    //    NetError::NET_OK              : 성공.
    //    NetError::ERR_ERRAND_ERROR_01 : 심부름왕 이벤트 기간이 아니다.
    // kRecv.m_nRemainTime             : 유저의 다음 플레이까지 남은 시간
    // kRecv.m_bPlayable               : DelayTime이 지나서 플레이 가능한지 여부(기획서에는 시간이 지나 심부름 목록을 받는다고 되어 있음)


    switch( kRecv.m_nOK )
    {
    case NetError::NET_OK:
        SiGCChallengeErrandManager()->SetPlayable( kRecv.m_bPlayable );
        SiGCChallengeErrandManager()->SetLastRewardTime( kRecv.m_nRemainTime );

        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_CHALLENGE_ERRAND );

        break;
    default:
//        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
//        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp );
        break;
    }
}

void On_EVENT_CLIENT_CONTENTS_OPEN_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CLIENT_CONTENTS_OPEN_INFO_NOT );
    SAFE_DELETE( pkBuff );
    SiGCUpdatePlanManager()->Update_EVENT_CLIENT_CONTENTS_OPEN_INFO( kRecv );

}

void On_EVENT_CLIENT_CONTENTS_FIRST_INIT_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CLIENT_CONTENTS_FIRST_INIT_INFO_NOT );
    SAFE_DELETE( pkBuff );

    SiGCUpdatePlanManager()->Update_EVENT_CLIENT_CONTENTS_FIRST_INIT_INFO( kRecv );

}

void On_EVENT_ITEM_BUY_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KItemBuyInfo );
    SAFE_DELETE( pkBuff );

    SiGCUpdatePlanManager()->Update_EVENT_ITEM_BUY_INFO_NOT( kRecv );

}

void On_EVENT_UPDATE_EVENT_SCRIPT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( std::vector< int > );
    SAFE_DELETE( pkBuff );

    SiGCUpdatePlanManager()->Update_EVENT_UPDATE_EVENT_SCRIPT_NOT( kRecv );

}

void On_EVENT_GACHA_DATA_CHANGE_NOT(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_GACHA_DATA_CHANGE_NOT);
    SAFE_DELETE(pkBuff);


    g_kGlobalValue.m_vecGachaUseVersion.clear();
    g_kGlobalValue.m_vecGachaUseVersion = kRecv;


}

void On_EVENT_LOOK_INVENTORY_EXTEND_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_LOOK_INVENTORY_EXTEND_ACK );
    SAFE_DELETE( pkBuff );
    /*
    kPacket_.m_nOK, 0  // 성공
    kPacket_.m_nOK, 1  // 아이템 아이디가 다름
    kPacket_.m_nOK, 2  // 아이템을 보유하고 있지 않음
    kPacket_.m_nOK, 3  // 더이상 인벤토리를 확장할수 없음
    kPacket_.m_nOK, -98  // 아직 처리중인 작업입니다.
    */

    Result_ExtendInventory = kRecv.m_nOK;

    if( kRecv.m_nOK == 0 ) // 성공
    {
        g_kGlobalValue.m_iCoordiCapacity = kRecv.m_nLookItemInvenCapacity;  // 인벤 크기 갱신 
    }
}

void On_EVENT_DUNGEON_SUBJECT_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DUNGEON_SUBJECT_REWARD_ACK );
    SAFE_DELETE( pkBuff );

    //kRecv.m_nOK;
    //kRecv.m_dwLoginUID;       // 보상 요청한 유저
    //kRecv.m_dwTriggerID;      // 보상받은 과제의 트리거 ID
    //kRecv.m_dwSubjectID;      // 보상받은 과제 ID
    //kRecv.m_dwGainExp;        // 보상으로 받은 exp(받지않으면 0)
    //kRecv.m_dwGainGp;         // 보상으로 받은 gp(받지않으면 0)
    //kRecv.m_vecRewards;       // 보상으로 받은 아이템들(받지않으면 비어있음)

    switch( kRecv.m_nOK )
    {
    case NetError::NET_OK:
        SiKGCSubjectManager()->SetReward( kRecv );
        break;
    default:
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp );
        break;
    }
}

void On_EVENT_GRADUATE_CHARACTER_USER_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_GRADUATE_CHARACTER_USER_INFO_NOT );
    SAFE_DELETE( pkBuff );

    if ( kRecv.m_nOK != 0 )
        return;


    switch( kRecv.m_nSendType )
    {
    case KEVENT_GRADUATE_CHARACTER_USER_INFO_NOT::EGCUI_ON_CONNECT:
        {
            SiKGCPrivateDungeonManager()->SetNoClearChar( kRecv.m_setNonGraduateCharacters );
            SiKGCWorldMapManager()->UpdateWorldMap();
        }
        break;
    case KEVENT_GRADUATE_CHARACTER_USER_INFO_NOT::EGCUI_ON_GRADUATE:
        {
            PLAYER* pPlayer = g_MyD3D->GetMyPlayer();
            if ( pPlayer ) 
                pPlayer->m_kUserInfo.mapStagePlayable = kRecv.m_mapDifficulty;
            g_MyD3D->m_TempPlayer.m_kUserInfo.mapStagePlayable = kRecv.m_mapDifficulty;
            g_kGlobalValue.m_kUserInfo.mapStagePlayable = kRecv.m_mapDifficulty;


            SiKGCPrivateDungeonManager()->SetNoClearChar( kRecv.m_setNonGraduateCharacters );
            SiKGCPrivateDungeonManager()->SetClearRewardItem( kRecv.m_vecRewards );
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewards, true ); 
            SiKGCPrivateDungeonManager()->SetMoseState( EM_CLEAR_DUNGEON );
        }
        break;
    }
}

void On_EVENT_SYSTEM_GUIDE_COMPLETE_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SYSTEM_GUIDE_COMPLETE_INFO_NOT );
    SAFE_DELETE( pkBuff );

    g_MyD3D->m_kGuideMgr.OnEventSystemGuideCompleteInfoNot( kRecv );
}

void On_EVENT_SYSTEM_GUIDE_ITEM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SYSTEM_GUIDE_ITEM_ACK );
    SAFE_DELETE( pkBuff );

    switch( kRecv.m_nOK )
    {
    case 0 :
        OnItemReceive(kRecv.m_vecProvideItem, false, false);
        g_pkUIScene->m_pkGCGuide->SetCompleteAction( true );
        g_MyD3D->m_kGuideMgr.SendGuideCompleteInfo( g_MyD3D->m_kGuideMgr.GetCurrentGuideType() );
        break;
    default:
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp );
        break;
    }

}

void On_EVENT_SYSTEM_GUIDE_COMPLETE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );

    Result_ReceiveGuideCompleteReq = kRecv;
}

void On_EVENT_ATTRIBUTE_MIGRATION_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ATTRIBUTE_MIGRATION_INFO_ACK );
    SAFE_DELETE( pkBuff );
/*
    kPacket.m_nOK, 0  // 성공
    kPacket.m_nOK, 1  // 성장 개편 재설정 기능 사용 불가능.
    kPacket.m_nOK, 2  // 성장 개편 재설정 이벤트 기간 아님.
    kPacket.m_nOK, 3  // 성장 개편 재설정 가능 횟수 초과.
*/

    g_kGlobalValue.SetAttributeMigrationInfo( kRecv );
    Result_AttributeMigration = kRecv.m_nOK;
}

void On_EVENT_ATTRIBUTE_MIGRATION_SELECT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ATTRIBUTE_MIGRATION_SELECT_ACK );
    SAFE_DELETE( pkBuff );
/*
    kPacket.m_nOK, 0  // 성공
    kPacket.m_nOK, 1  // 성장 개편 재설정 기능 사용 불가능.
    kPacket.m_nOK, 2  // 성장 개편 재설정 이벤트 기간 아님.
    kPacket.m_nOK, 3  // 성장 개편 재설정 가능 횟수 초과.
    kPacket.m_nOK, 4  // 속성을 선택할 아이템이 인벤에 없음.
    kPacket.m_nOK, 5  // 선택된 속성은 변경 가능한 속성이 아님.
    kPacket.m_nOK, 6  // 선택한 속성이 선택 가능한 속성에 포함되지 않습니다.
    kPacket.m_nOK, 7  // 속성을 DB 에 기록 하는데 오류 발생.
    kPacket.m_nOK, -98 // 아직 처리중인 작업임.
*/


    switch( kRecv.m_nOK )
    {
    case 0:
        g_pItemMgr->m_kInventory.AddItem(kRecv.m_kItem, true);
        //아이템 추가 시켜주자!
        //g_pItemMgr->EquipInventoryItem( &g_kGlobalValue.m_kUserInfo.GetCurrentChar(), kRecv.m_kItem.m_ItemUID );
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_SELECT_ATTRIBUTE_SUCCESS_MSG),
            L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,false);
        break;
    case 1:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_SELECT_ATTRIBUTE_ERROR1),
            L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,false);
        break;
    case 2:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_SELECT_ATTRIBUTE_ERROR2),
            L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,false);
        break;
    case 3:
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_SELECT_ATTRIBUTE_ERROR3),
            L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,false);
        break;
    case 4: //
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_SELECT_ATTRIBUTE_ERROR3),
            L"",KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,false);
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_RANDOM_ATTRIBUTE_16 ),
                strTemp,KGCUIScene::GC_MBOX_USE_NORMAL,0,0,false,false);
        }
        break;
    }
    Result_SelectAttribute = kRecv.m_nOK;

}

void On_EVENT_CYOU_GET_WEB_POINT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KCYOUCashPoint );
    SAFE_DELETE( pkBuff );

    Result_CYOU_WebCash = kRecv.m_nOK;

	switch( kRecv.m_nOK ) { 
		case 0 :
			g_kGlobalValue.m_dwChinaWebCash = kRecv.m_dwCYOUPoint;
			g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
            g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();
			break;
        case NetError::ERR_NUSER_VERIFY_67:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_BILLING_CN_MESSAGE_35));
            break;
	}

}

void On_EVENT_CYOU_CASH_CHANGE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KCYOUCashPoint );
    SAFE_DELETE( pkBuff );

	switch ( kRecv.m_nOK ){
		case 0 :
			g_kGlobalValue.m_dwCash = kRecv.m_dwCashPoint;
			g_kGlobalValue.m_dwChinaWebCash = kRecv.m_dwCYOUPoint;
			g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_CHANGE_CYOU_POINT_SUCCESS));
            break;
        case NetError::ERR_CASH_BILL_06:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_CHANGE_CYOU_POINT_MAX_OVER));
			break;
        case NetError::ERR_NUSER_VERIFY_67:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_BILLING_CN_MESSAGE_35));
            break;
	}
}

void On_EVENT_CYOU_LOGIN_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );

    kRecv;
    switch( kRecv ) {
        case 0x01:
        case 0x03:
        case 0x04:
            // 로긴 화면으로 되돌아가기
            // 유저가 정상적으로 로그인되지 않았습니다. 메시지 팝업 필요.
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_BILLING_CN_MESSAGE_36));
            g_MyD3D->m_pStateMachine->GoLogin();
            break;
        case 0x05: // Database visiting error
        case 0x06: // Other error
            // 0x05 or 0x06 발생 시에 서버에서 1회 더 동일패킷을 빌링 서버로 전송하도록 구현함.
            break;
        case NetError::ERR_NUSER_VERIFY_67: // 로긴서버->빌링 서버로 패킷 전송 실패, 메시지 팝업 바람.
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_BILLING_CN_MESSAGE_35));
            break;
    }
}

void On_EVENT_CYOU_USER_HEART_BEAT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( int );
    SAFE_DELETE( pkBuff );

    switch ( kRecv ) {
        case NetError::ERR_NUSER_VERIFY_60: // ERR_NUSER_VERIFY_60, ERR_NUSER_VERIFY_61, ERR_NUSER_VERIFY_62 의 에러 메시지가 모두 다름. 재접속 필요한 것은 동일.
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_BILLING_CN_MESSAGE_38));
            g_MyD3D->m_pStateMachine->GoLogin();
            break;
        case NetError::ERR_NUSER_VERIFY_61:
            // 로그인 화면으로 보내주세요.
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_BILLING_CN_MESSAGE_39));
            g_MyD3D->m_pStateMachine->GoLogin();
            break;
        case NetError::ERR_NUSER_VERIFY_62:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_BILLING_CN_MESSAGE_40));
            g_MyD3D->m_pStateMachine->GoLogin();
            break;
        case NetError::ERR_NUSER_VERIFY_67:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_BILLING_CN_MESSAGE_35));
            break;
        case NetError::ERR_NUSER_VERIFY_68:
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_BILLING_CN_MESSAGE_39));
            g_MyD3D->m_pStateMachine->GoLogin();
            break;
    }
}

void On_EVENT_ADD_SLOT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_ADD_SLOT_ACK );
    SAFE_DELETE( pkBuff );

    /*
    kPacket_.m_nOK, 0 
    kPacket_.m_nOK, 1 // 슬롯 추가 아이템이 인벤토리에 없음.
    kPacket_.m_nOK, 2 // 슬롯 추가를 더이상 할 수 없음.
    */

    switch( kRecv.m_nOK ) 
    { 
    case 0: 
        {
            g_kGlobalValue.m_kUserInfo.m_nSlotCount = kRecv.m_dwRemainIndexCnt;
            g_pItemMgr->m_kInventory.AddItem(kRecv.m_kUseItem, true);

            if( g_MyD3D->m_pStateMachine->GetState() == GS_CHAR_SELECT )
            {
                g_pkUIScene->m_pkCharSelectScene->UpdateEmptySlot();
            }

            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_ADD_SLOT_CHECK_OK, "i", kRecv.m_nAddSlotCnt );

            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strTemp, 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );

        }
        break;
    case 1: 
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ADD_SLOT_CHECK_ERROR3 ), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        }
        break;
    case 2: 
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ADD_SLOT_CHECK_ERROR2 ), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        }
        break;
    case 4:
        {
            std::wstring strName = GCFUNC::GetCharName( g_kGlobalValue.m_kUserInfo.GetCurrentChar().iCharType );
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_ADD_SLOT_CHECK_ERROR4, "s", strName.c_str() );
            std::wstring strTemp2 = boost::str( boost::wformat( L"(%1%)-(%2%)")%wParam%kRecv.m_nOK ); 
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strTemp, strTemp2, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        }
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );

            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_MISSION_ERROR3),
                strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true );
        }
        break;
    }
}

void On_EVENT_CHANGE_CHARACTER_INFO_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_CHANGE_CHARACTER_INFO_ACK);
    SAFE_DELETE(pkBuff);

    Result_ChangeChar = kRecv.m_nOK;

    switch (kRecv.m_nOK)
    {
    case 0:
    {
        g_pItemMgr->m_kInventory.AddItemList(kRecv.m_vecInv, true);
        g_kGlobalValue.m_kUserCollectionMission.SetUserCollectionMissionList(kRecv.m_vecCollection);
        g_kGlobalValue.m_kUserMission.ClearUserMission();
        g_kGlobalValue.m_kUserMission.SetUserMissionList(kRecv.m_vecMissionSlot);
        g_kGlobalValue.m_kUserInfo.mapStagePlayable = kRecv.m_mapDifficulty;
        g_kGlobalValue.m_kUserInfo.m_vecFontVector = kRecv.m_vecFontVector;
        g_kGlobalValue.m_kUserInfo.m_iPvExp = kRecv.m_iPvExp;

        SiKGCPrivateDungeonManager()->CheckFirstDungeon(GC_CHAR_INVALID);
#ifndef DISABLE_DIMENSIONAL_PORTAL_SPLASH
        SiKGCInfinityDungeonManager()->CheckShowGuide();
#endif

        GCFUNC::ConvertPetInfo(g_MyD3D->m_mapPetInfo, kRecv.m_mapPetInfo);

        SCharInfo& kCharInfo = g_kGlobalValue.m_kUserInfo.GetCurrentChar(kRecv.m_cCharacter);
        if (kCharInfo == kRecv.m_cCharacter) {
            std::vector< KEquipItemInfo >::const_iterator it = kRecv.m_vecEquipItems.begin();
            for (; it != kRecv.m_vecEquipItems.end(); ++it) {
                if (it->m_dwUID < 0) {
                    continue;
                }

                g_pItemMgr->EquipInventoryItem(&kCharInfo, it->m_dwUID, false);
            }

            it = kRecv.m_vecLookEquips.begin();
            for (; it != kRecv.m_vecLookEquips.end(); ++it) {
                if (it->m_dwUID < 0) {
                    continue;
                }

                g_pItemMgr->EquipInventoryItem(&kCharInfo, it->m_dwUID, true);
            }

            kCharInfo.m_nInvenCapacity = kRecv.m_nInvenCapacity;
            kCharInfo.m_nCoordiCapacity = kRecv.m_nLookInvenCapacity;
            g_kGlobalValue.m_iInvenCapacity = kCharInfo.m_nInvenCapacity;
            g_kGlobalValue.m_iCoordiCapacity = kCharInfo.m_nCoordiCapacity;

            g_kGlobalValue.m_kUserInfo.SetCurrentChar(kRecv.m_cCharacter);

            auto& curChar = g_kGlobalValue.m_kUserInfo.GetCurrentChar();
            curChar.vecPetGlyphInfo.clear();

            for (auto petGlyph : kRecv.m_vecPetGlyphCharData)
            {
                KSimpleItem kItem;
                kItem.m_dwID = petGlyph.m_dwID;
                kItem.m_dwUID = petGlyph.m_dwUID;
                kItem.m_cItemType = petGlyph.m_cType;
                curChar.vecPetGlyphInfo.push_back(kItem);
            }

            curChar.dwPetGlyphSize = curChar.vecPetGlyphInfo.size();

            g_MyD3D->m_TempPlayer.m_kUserInfo = g_kGlobalValue.m_kUserInfo;
            g_kGlobalValue.m_mapChangeWeapon.insert(std::pair<char, std::pair<bool, GCITEMUID>>(kRecv.m_cCharacter, std::pair<bool, GCITEMUID>(kRecv.m_bChangeWeaponLock, kRecv.m_kChangeWeaponItem.m_dwUID)));

            g_kGlobalValue.SetSavedCharType(g_kGlobalValue.m_kUserInfo.GetCurrentChar().iCharType);
            g_kGlobalValue.SendSavedCharType();
        }
    }
    break;
    default:
        break;
    };

}

void On_EVENT_VITALITY_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_VITALITY_INFO_NOT );
    SAFE_DELETE( pkBuff );

    //int                     m_nOK;
    //int                     m_nMaxVitalityPerDay;               // 캐릭별 하루 최대 활력 수치(초기화시 지급받는 수치)
    //int                     m_nVitalityPerRechargePoint;        // 활력 충전 포인트 1을 얻기 위해 소모해야 할 활력 수치
    //int                     m_nRechargePoint;                   // 잔여 활력 충전 포인트
    //int                     m_nRechargePointCounter;            // 활력 충전용 소모한 활력 카운터
    //std::map< int, int >    m_mapRemainVitality;                // 캐릭터별 잔여 활력

    // 이 이벤트 패킷의 전달 시점
    // 1. 접속시 잔여 활력 정보 알림(S->C)
    // 2. 초기화 시간에 초기화시 잔여 활력 정보 알림(S->C)
    // 3. 활력 충전 요청시 잔여 활력 정보 알림(S->C)
    // 3의 경우에만 Result_ReceiveVitalitySystemRecharge 변수를 사용해서 응답결과를 확인하면 될 듯
    Result_ReceiveVitalitySystemRecharge = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0 :
    case NetError::ERR_VITALITY_01 : // 사용할 수 있는 재충전 포인트가 없음
    case NetError::ERR_VITALITY_02 : // 요청한 캐릭터 정보가 없음
    case NetError::ERR_VITALITY_03 : // 충전했음
    case NetError::ERR_VITALITY_04 : // 던전 시작시 활력 차감 성공
        g_kGlobalValue.SetUpdateVitalityInfo( kRecv );

        if( g_MyD3D->m_pStateMachine->GetState() == GS_WORLDMAP )
            g_pkUIScene->m_pkWorldMapContainer->SetVitalityInfo();
        else if( g_MyD3D->m_pStateMachine->GetState() == GS_CHAR_SELECT )
            g_pkUIScene->m_pkCharSelectScene->SetVitalityInfo();

        if( kRecv.m_nOK == NetError::ERR_VITALITY_03 ) {
            // 충전완료 메시지 박스
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_VITALITY_STR_6 ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
        }
        break;
    default:
        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp );
        break;
    }


}

void On_EVENT_VITALITY_CHECK_DUNGEON_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_VITALITY_CHECK_DUNGEON_INFO_NOT );
    SAFE_DELETE( pkBuff );

    g_kGlobalValue.m_mapVitalityDungeonInfo = kRecv;
}

void On_EVENT_DEPOT_RESTRICT_ITEM_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DEPOT_RESTRICT_ITEM_NOT );
    SAFE_DELETE( pkBuff );

    SiKGCDepotManager()->SetDepotRestrictItem( kRecv );
    SiKGCVirtualDepotManager()->SetDepotRestrictList( kRecv );
}

void On_EVENT_CONNECTION_GIFTBOX_FIRST_CHARACTER_GET_GIFT_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CONNECTION_GIFTBOX_FIRST_CHARACTER_GET_GIFT_NOT );
    SAFE_DELETE( pkBuff );

    //신규 캐릭터 접속 아이템 지급
    if ( !kRecv.empty())
    {
        GCITEMID itemID = 0;

        for( int i = 0 ; i < (int)kRecv.size() ; i++){
            itemID =  kRecv[i].m_ItemID / 10;
            g_pkUIScene->m_pkTreaureItemBox->SetItem( itemID  );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, itemID, 0, false, true );
        }
        g_pItemMgr->m_kInventory.AddItemList( kRecv , true);

        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        g_pkUIScene->m_pkMyInfoScene->UpdateData();
    }

}

void On_EVENT_CONNECTION_GIFTBOX_NEWUSER_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CONNECTION_GIFTBOX_NEWUSER_INFO_NOT );
    SAFE_DELETE( pkBuff );
    //enum ESendType {
    //EST_GET_GIFT_ACK    = 0,
    //EST_ON_CONNECT      = 1,
    if ( kRecv.m_nOK == 1 ) {
        SiKGCGiftBoxManager()->SetNewUserInfo( kRecv , true );
        SiKGCGiftBoxManager()->ExistNewUserReward( kRecv.m_vecNextGift , 0 );
    }
}

void On_EVENT_CONNECTION_GIFTBOX_NEWUSER_GET_GIFT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CONNECTION_GIFTBOX_NEWUSER_GET_GIFT_ACK );
    SAFE_DELETE( pkBuff );

    //ERR_CONNECTION_GIFTBOX_ERROR_01, 신규유저 대상이 아님. )
    //ERR_CONNECTION_GIFTBOX_ERROR_02, 현재 등급의 보상 정보가 없음. )
    //ERR_CONNECTION_GIFTBOX_ERROR_03, 선물상자 유저정보 갱신 중 DB기록 실패. )
    //ERR_CONNECTION_GIFTBOX_ERROR_04, 이벤트유저 선물상자 이벤트 기간이 아님. )
    //ERR_CONNECTION_GIFTBOX_ERROR_05, 현재 등급의 누적 시간이 부족함. )
    switch(kRecv.m_nOK)
    {
    case 0:
        {
            if( !kRecv.m_vecGetRewards.empty() )
            {
                SiKGCGiftBoxManager()->SetPossibleReward( 0 , false );
                GCITEMID itemID = 0;
                for( int i = 0 ; i < (int)kRecv.m_vecGetRewards.size() ; i++) {
                    itemID =  kRecv.m_vecGetRewards[i].m_ItemID;
                    g_pkUIScene->m_pkTreaureItemBox->SetTitle( g_pItemMgr->GetItemName( (kRecv.m_vecGetRewards[i].m_ItemID)/10 ).c_str() );
                    g_pkUIScene->m_pkTreaureItemBox->SetItem( itemID / 10);
                    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, itemID/10, 0, false, true );
                }
                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecGetRewards , true );

                if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
                {
                    g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
                }
            }

            if ( kRecv.m_vecNextGift.empty() ) {
                SiKGCGiftBoxManager()->SetEvent( 0, false);
                SiKGCGiftBoxManager()->SetNewUserInfo( kRecv , false );
                SiKGCGiftBoxManager()->ExistNewUserReward( kRecv.m_vecNextGift , 0 );
            }
            else
            {
                SiKGCGiftBoxManager()->SetNewUserInfo( kRecv , true );
                SiKGCGiftBoxManager()->ExistNewUserReward( kRecv.m_vecNextGift , 0 );
            }
            g_pkUIScene->m_pkGiftBox->InitNewUser();
        }
        break;
    case NetError::ERR_CONNECTION_GIFTBOX_ERROR_01:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ERR_CONNECTION_GIFTBOX_ERROR_01) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, false, true);
        }
        break;
    case NetError::ERR_CONNECTION_GIFTBOX_ERROR_02:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ERR_CONNECTION_GIFTBOX_ERROR_02) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, false, true);
        }
        break;
    case NetError::ERR_CONNECTION_GIFTBOX_ERROR_03:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ERR_CONNECTION_GIFTBOX_ERROR_03) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, false, true);
        }
        break;
    case NetError::ERR_CONNECTION_GIFTBOX_ERROR_04:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, false, true);
        }
        break;
    case NetError::ERR_CONNECTION_GIFTBOX_ERROR_05:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ERR_CONNECTION_GIFTBOX_ERROR_05) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, false, true);
        }
        break;
    default:
        NetError::SetLastError(kRecv.m_nOK);
        std::wstring strerr = NetError::GetLastErrMsg();

        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strerr.c_str() , strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, false, true);

        break;
    }

}

void On_EVENT_CONNECTION_GIFTBOX_EVENTUSER_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CONNECTION_GIFTBOX_EVENTUSER_INFO_NOT );
    SAFE_DELETE( pkBuff );

    if ( kRecv.m_nOK == 1 )
    {
        SiKGCGiftBoxManager()->SetEventUserInfo( kRecv , true );
        SiKGCGiftBoxManager()->ExistNextGiftForEvent();
    }
}

void On_EVENT_CONNECTION_GIFTBOX_EVENTUSER_GET_GIFT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_CONNECTION_GIFTBOX_EVENTUSER_GET_GIFT_ACK );
    SAFE_DELETE( pkBuff );

    switch(kRecv.m_nOK)
    {
    case 0:
        {
            if( !kRecv.m_vecGetRewards.empty() )
            {
                SiKGCGiftBoxManager()->SetPossibleReward( 1 , false );
                GCITEMID itemID = 0;
                for( int i = 0 ; i < (int)kRecv.m_vecGetRewards.size() ; i++) {
                    itemID =  kRecv.m_vecGetRewards[i].m_ItemID;
                    g_pkUIScene->m_pkTreaureItemBox->SetTitle( g_pItemMgr->GetItemName( (kRecv.m_vecGetRewards[i].m_ItemID )/10).c_str() );
                    g_pkUIScene->m_pkTreaureItemBox->SetItem( itemID / 10);
                    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_TREASURE_ITEM_BOX, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, itemID/10, 0, false, true );
                }
                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecGetRewards , true );

                if( g_MyD3D->m_pStateMachine->IsStateMyInfo() )
                {
                    g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
                }
            }

            if ( kRecv.m_vecNextGift.empty() ) {
                SiKGCGiftBoxManager()->SetEvent( 1, false);
                SiKGCGiftBoxManager()->SetEventUserInfo( kRecv , false );
                SiKGCGiftBoxManager()->ExistNewUserReward( kRecv.m_vecNextGift , 1 );
            }
            else
            {
                SiKGCGiftBoxManager()->SetEventUserInfo( kRecv , true );
                SiKGCGiftBoxManager()->ExistNewUserReward( kRecv.m_vecNextGift , 1 );
            }
            g_pkUIScene->m_pkGiftBox->InitEventReward();
        }
        break;
    case NetError::ERR_CONNECTION_GIFTBOX_ERROR_02:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ERR_CONNECTION_GIFTBOX_ERROR_02) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, false, true);
        }
        break;
    case NetError::ERR_CONNECTION_GIFTBOX_ERROR_03:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ERR_CONNECTION_GIFTBOX_ERROR_03) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, false, true);
        }
        break;
    case NetError::ERR_CONNECTION_GIFTBOX_ERROR_04:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, false, true);
        }
        break;
    case NetError::ERR_CONNECTION_GIFTBOX_ERROR_05:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ERR_CONNECTION_GIFTBOX_ERROR_05) , L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, false, true);
        }
        break;
    default:
        NetError::SetLastError(kRecv.m_nOK);
        std::wstring strerr = NetError::GetLastErrMsg();

        std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, strerr.c_str() , strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0,0, true, false, true);

        break;
    }
}

void On_EVENT_CONNECTION_GIFTBOX_NEWUSER_GET_ALARM_NOT( WPARAM wParam, LPARAM lParam )
{
    SiKGCGiftBoxManager()->SetPossibleReward( 0 , true );
}
void On_EVENT_CONNECTION_GIFTBOX_EVENTUSER_GET_ALARM_NOT( WPARAM wParam, LPARAM lParam )
{
    SiKGCGiftBoxManager()->SetPossibleReward( 1 , true );
}

void On_EVENT_JUMPING_CHAR_ACK( WPARAM wParam, LPARAM lParam )
{
    /*
    kPacket.m_nOK, 0  // 성공
    kPacket.m_nOK, 1  // 이벤트 기간이 아님.
    kPacket.m_nOK, 2  // 이미 점핑 캐릭터 보상을 받았음.
    kPacket.m_nOK, 4  // 점핑 캐릭터 보상 세팅되지 않았음.
    kPacket.m_nOK, 5  // 점핑 캐릭터 미션 클리어 정보 세팅되지 않았음.
    kPacket.m_nOK, 6  // 점핑 캐릭터 레벨보다 보유한 캐릭터 레벨이 높음.
    kPacket.m_nOK, 7 // DB 점핑 캐릭터 생성 실패.
    kPacket.m_nOK, -98  // 처리중인 작업입니다.
    */
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_JUMPING_CHAR_ACK );
    SAFE_DELETE( pkBuff );


    g_pkUIScene->m_pkJumpingCharDlg->SetButtonLock( false );

    switch( kRecv.m_nOK )
    {
    case 0:
        {
            SiKGCJumpingCharManager()->SetEnableEvent( false );

            // 캐릭터 생성시
            if ( kRecv.m_nType == KEVENT_JUMPING_CHAR_ACK::JP_CREATE )
            {
                SCharInfo Info;
                GCFUNC::ConvertCharInfo( Info, kRecv.m_kCharacterInfo );
                
                // 스킬정보 안비었으면 스킬 정보도 
                if( !kRecv.m_vecSPInfo.empty() ) { 
                    Info.m_vecSPInfo = kRecv.m_vecSPInfo;

                    std::vector< KSPInfo >::const_iterator itSPInfo = kRecv.m_vecSPInfo.begin();
                    for( ; itSPInfo != kRecv.m_vecSPInfo.end() ; ++itSPInfo ) { 
                        SiGCSKT()->SetUpdateTrainedSkill( *itSPInfo );
                    }
                }

                g_pkUIScene->m_pkSkillTree->ThreadSafeUpdate();
                SiGCSKT()->ApplySettingToServer();

                // 스킬 그룹 언락
                std::vector<int>::iterator iter_skill = kRecv.m_vecUnLockSkillGroup.begin();
                for ( ; iter_skill != kRecv.m_vecUnLockSkillGroup.end(); ++iter_skill )
                {
                    SiGCSKT()->Server_UnlockGroup( kRecv.m_kCharacterInfo.m_cCharType, (*iter_skill) );
                }

                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewardItem, true );
                g_pItemMgr->EquipBaseItem( &Info );
                g_kGlobalValue.m_kUserInfo.AddChar( Info, true );                
                g_kGlobalValue.m_mapChangeWeapon.insert(std::pair<char,std::pair<bool,GCITEMUID>>(kRecv.m_kCharacterInfo.m_cCharType,std::pair<bool,GCITEMUID>(kRecv.m_kCharacterInfo.m_bChangeWeaponLock,kRecv.m_kCharacterInfo.m_kChangeWeaponItem.m_dwUID)));

                
                // 미션 갱신 처리
                g_kGlobalValue.m_kUserMission.SetUserMissionList( kRecv.m_vecMissionSlot, false );
                g_kGlobalValue.m_kUserMission.RefreshUserMission();
                g_pkUIScene->m_pkMissionUI_S4->RefreshUI();


                //g_pIndigoSelect->Init();
                //g_pTagMatchSelect->Init();
                //memcpy( g_kGlobalValue.m_kUserInfo.aiTagSlot, g_pIndigoSelect->GetSlot(), sizeof(g_kGlobalValue.m_kUserInfo.aiTagSlot[0])*3 );

                g_MyD3D->m_TempPlayer.m_kUserInfo.AddChar( Info );
                g_MyD3D->m_TempPlayer.m_kUserInfo.SetCurrentChar( Info.iCharType );

                g_MyD3D->m_TempPlayer.UpdateGlobalUserInfo();

                // 플레이 가능한 던전 업데이트 
                g_MyD3D->m_TempPlayer.m_kUserInfo.mapStagePlayable = kRecv.m_mapDifficulty;
                g_kGlobalValue.m_kUserInfo.mapStagePlayable = kRecv.m_mapDifficulty;

                SiKGCWorldMapManager()->UpdateWorldMap();

                int iUserIndex = g_MyD3D->Get_Player( g_kGlobalValue.m_kUserInfo.dwUID );
                if ( g_MyD3D->MyPlayer[iUserIndex] != NULL )
                    g_MyD3D->MyPlayer[iUserIndex]->m_kUserInfo = g_kGlobalValue.m_kUserInfo;

                
                // 봉인 캐릭터 정보 갱신 ( 봉인 푼다. )
                std::map< int, KSealedCharInfo >::iterator iter_seal = g_kGlobalValue.m_mapSealedCharInfo.find( kRecv.m_kCharacterInfo.m_cCharType );
                if ( iter_seal != g_kGlobalValue.m_mapSealedCharInfo.end() )
                {
                    iter_seal->second.m_bIsSealed = false;
                }

                // 미졸업 캐릭터면 졸업 처리
                SiKGCPrivateDungeonManager()->DelNoClearChar( kRecv.m_kCharacterInfo.m_cCharType );
                SiKGCPrivateDungeonManager()->CheckFirstDungeon( kRecv.m_kCharacterInfo.m_cCharType );

            }
            else
            {
                SCharInfo &sCharInfo = g_MyD3D->m_TempPlayer.m_kUserInfo.GetCurrentChar( kRecv.m_kCharacterInfo.m_cCharType );
                if( sCharInfo.iCharType == kRecv.m_kCharacterInfo.m_cCharType )
                {
                    // 레벨과 경험치 갱신
                    sCharInfo.biExp = kRecv.m_kCharacterInfo.m_biExp;
                    sCharInfo.iLevel = static_cast<int>(kRecv.m_kCharacterInfo.m_dwLevel);
                    sCharInfo.iPromotionLevel = kRecv.m_kCharacterInfo.m_cPromotion;
                    sCharInfo.kSkillInfo = kRecv.m_kCharacterInfo.m_kSkillInfo;
                    sCharInfo.m_vecSPInfo = kRecv.m_vecSPInfo;
                }

                // 스킬정보 안비었으면 스킬 정보도 
                if( !kRecv.m_vecSPInfo.empty() ) { 

                    std::vector< KSPInfo >::const_iterator itSPInfo = kRecv.m_vecSPInfo.begin();
                    for( ; itSPInfo != kRecv.m_vecSPInfo.end() ; ++itSPInfo ) { 
                        SiGCSKT()->SetUpdateTrainedSkill( *itSPInfo );
                    }
                }
                g_pkUIScene->m_pkSkillTree->ThreadSafeUpdate();
                SiGCSKT()->ApplySettingToServer();

                // 스킬 그룹 언락
                std::vector<int>::iterator iter_skill = kRecv.m_vecUnLockSkillGroup.begin();
                for ( ; iter_skill != kRecv.m_vecUnLockSkillGroup.end(); ++iter_skill )
                {
                    SiGCSKT()->Server_UnlockGroup( kRecv.m_kCharacterInfo.m_cCharType, (*iter_skill) );
                }

                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewardItem, true );
                g_kGlobalValue.m_mapChangeWeapon.insert(std::pair<char,std::pair<bool,GCITEMUID>>(kRecv.m_kCharacterInfo.m_cCharType,std::pair<bool,GCITEMUID>(kRecv.m_kCharacterInfo.m_bChangeWeaponLock,kRecv.m_kCharacterInfo.m_kChangeWeaponItem.m_dwUID)));

                // 미션 갱신 처리
                g_kGlobalValue.m_kUserMission.SetUserMissionList( kRecv.m_vecMissionSlot, false );
                g_kGlobalValue.m_kUserMission.RefreshUserMission();
                g_pkUIScene->m_pkMissionUI_S4->RefreshUI();

                g_MyD3D->m_TempPlayer.m_kUserInfo.SetCurrentChar( sCharInfo.iCharType );

                g_MyD3D->m_TempPlayer.UpdateGlobalUserInfo();

                // 플레이 가능한 던전 업데이트 
                g_MyD3D->m_TempPlayer.m_kUserInfo.mapStagePlayable = kRecv.m_mapDifficulty;
                g_kGlobalValue.m_kUserInfo.mapStagePlayable = kRecv.m_mapDifficulty;

                SiKGCWorldMapManager()->UpdateWorldMap();

                int iUserIndex = g_MyD3D->Get_Player( g_kGlobalValue.m_kUserInfo.dwUID );
                if ( g_MyD3D->MyPlayer[iUserIndex] != NULL )
                    g_MyD3D->MyPlayer[iUserIndex]->m_kUserInfo = g_kGlobalValue.m_kUserInfo;


                // 봉인 캐릭터 정보 갱신 ( 봉인 푼다. )
                std::map< int, KSealedCharInfo >::iterator iter_seal = g_kGlobalValue.m_mapSealedCharInfo.find( kRecv.m_kCharacterInfo.m_cCharType );
                if ( iter_seal != g_kGlobalValue.m_mapSealedCharInfo.end() )
                {
                    iter_seal->second.m_bIsSealed = false;
                }

                // 미졸업 캐릭터면 졸업 처리
                SiKGCPrivateDungeonManager()->DelNoClearChar( kRecv.m_kCharacterInfo.m_cCharType );
                SiKGCPrivateDungeonManager()->CheckFirstDungeon( kRecv.m_kCharacterInfo.m_cCharType );
            }
            
            g_pkUIScene->m_pkJumpingCharDlg->OnClose();
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_JUMPING_CHAR_OK), L"");

            g_pkUIScene->m_pkCharSelectScene->UpdateData();
        }
        break;
        
    case 1: // 이벤트 기간이 아님.
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD), L"" );
        }
        break;
    case 2: // 이미 점핑 캐릭터 보상을 받았음.
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_JUMPING_CHAR_ERROR1), L"" );
        }
        break;
    case 6: // 점핑 캐릭터 레벨보다 보유한 캐릭터 레벨이 높음.
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_JUMPING_CHAR_ERROR3), L"" );
        }
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp );
        }
        break;
    }
}

void On_EVENT_JUMPING_CHAR_REWARD_ACK( WPARAM wParam, LPARAM lParam )
{
    /*
    kPacket_.m_nOK, 0  // 성공
    kPacket_.m_nOK, 1  // 이벤트 기간이 아님.
    kPacket_.m_nOK, 2  // 이미 점핑 캐릭터 보상을 받았음.
    kPacket_.m_nOK, 3  // 점핑 캐릭터 기본 보상 세팅되지 않았음.
    kPacket_.m_nOK, -98 // 아직 처리중인 작업입니다.
    */
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_JUMPING_CHAR_REWARD_ACK );
    SAFE_DELETE( pkBuff );

    g_pkUIScene->m_pkJumpingCharDlg->SetButtonLock( false );

    switch( kRecv.m_nOK )
    {
    case 0 : 
        {
            SiKGCJumpingCharManager()->SetEnableEvent( false );
            g_pkUIScene->m_pkJumpingCharDlg->OnClose();
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecRewardItem, true );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_JUMPING_CHAR_REWARD_OK), L"");
        }
        break;
    case 1: // 이벤트 기간이 아님.
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_NOT_EVENT_PERIOD), L"" );
        }
        break;
    case 2: // 이미 점핑 캐릭터 보상을 받았음.
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_JUMPING_CHAR_ERROR1), L"" );
        }
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp );
        }
        break;
    }
}


void On_EVENT_JUMPING_CHAR_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_JUMPING_CHAR_INFO_NOT );
    SAFE_DELETE( pkBuff );

    SiKGCJumpingCharManager()->SetEnableEvent( kRecv.m_bJumpingCharEnable );
    SiKGCJumpingCharManager()->SetJumpingLevel( kRecv.m_dwCharJumpingLevel );
    SiKGCJumpingCharManager()->SetCharList( kRecv.m_setJumpingCharList );

    if ( SiKGCJumpingCharManager()->IsEnableEvent() )
    {
        if ( g_MyD3D->m_pStateMachine->GetState() == GS_CHAR_SELECT ) 
        {
            if ( !g_pkUIScene->IsCurMsgBox_Type( KGCUIScene::GC_MBOX_JUMPING_CHAR_DLG ) || g_pkUIScene->IsWaitMsgBox( KGCUIScene::GC_MBOX_JUMPING_CHAR_DLG ) )
            {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_JUMPING_CHAR_DLG );
            }
        }
    }
}

void On_EVENT_COORDI_COMPOSE_ACK( WPARAM wParam, LPARAM lParam )
{
    /*
    kPacket_.m_nOK, 0  // 성공
    kPacket_.m_nOK, 1  // 아이템이 인벤토리에 존재하지 않음.
    kPacket_.m_nOK, 2  // 능력치 아이템이 코디가 아님.
    kPacket_.m_nOK, 3  // 외형 아이템이 코디가 아님.
    kPacket_.m_nOK, 4  // 능력치 코디 아이템에 능력치가 없음.
    kPacket_.m_nOK, 5  // 능력치 코디 아이템이 영구 아이템이 아님.
    kPacket_.m_nOK, 6  // 코디 합성 정보 DB 갱신 에러.
    kPacket_.m_nOK, 8  // 외형 코디 아이템이 영구 아이템이 아님.
    kPacket_.m_nOK, 9  // 코디 합성 주문서 없음.
    kPacket_.m_nOK, 10 // 능력치랑 코디가 동일한 아이템입니다.
    kPacket_.m_nOK, -98  // 처리중인 작업입니다.
    */
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_COORDI_COMPOSE_ACK );
    SAFE_DELETE( pkBuff );


    switch( kRecv.m_nOK )
    {
    case 0: 
        {
            g_pItemMgr->m_kInventory.RemoveItemList( kRecv.m_vecDelItem );
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecUseItem, true );
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecChangeItem, true );            


            g_pkUIScene->m_pkCoordiComposeDlg->InitUIState();
            // 인벤토리 업데이트 
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
            g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();

            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_COORDI_COMPOSE_OK), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL,0,0, true, true );
        }
        break;
    case 1:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_COORDI_COMPOSE_ERROR0), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL,0,0, true, true );
        }
        break;
    case 2:
    case 3:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_COORDI_COMPOSE_ERROR1), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL,0,0, true, true );
        }
        break;
    case 4:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_COORDI_COMPOSE_ERROR2), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL,0,0, true, true );
        }
        break;
    case 5:
    case 8:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_COORDI_COMPOSE_ERROR3), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL,0,0, true, true );
        }
        break;
    case 9:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_COORDI_COMPOSE_ERROR8), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL,0,0, true, true );
        }
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp,
                                     KGCUIScene::GC_MBOX_USE_NORMAL,0,0, true, true );
        }
        break;
    }
}

void On_EVENT_VIRTUAL_DEPOT_ITEM_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_VIRTUAL_DEPOT_ITEM_LIST_NOT );
    SAFE_DELETE( pkBuff );

    SiKGCVirtualDepotManager()->SetDepotItemList( kRecv );
    SiKGCVirtualDepotManager()->SetRecvPacket( true );


}

void On_EVENT_MOVE_ITEM_TO_INVENTORY_FROM_VIRTUAL_DEPOT_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MOVE_ITEM_TO_INVENTORY_FROM_VIRTUAL_DEPOT_ACK );
    SAFE_DELETE( pkBuff );

    Result_VirtualDepotItemListMoveInven = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case 0 :
        {
            SiKGCVirtualDepotManager()->MoveDataResualt( kRecv );
            SiKGCVirtualDepotManager()->SetItemCategory();
            SiKGCVirtualDepotManager()->SetRecvPacket( true );
            SiKGCVirtualDepotManager()->ClearMyInvenItem();
            SiKGCVirtualDepotManager()->SetUpdateUI(true);
            break;
        }
    case NetError::ERR_VIRTUAL_DEPOT_ERROR_01: // 클라이언트에서 아무 정보 요청 하지 않음 에러 코드 1 + m_ok 
        {
            SiKGCVirtualDepotManager()->ClearMyInvenItem();
            std::wstring strTemp1 = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", 1, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp1, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
            break;
        }
    default:
        {
            SiKGCVirtualDepotManager()->ClearMyInvenItem();
            std::wstring strTemp2 = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp2, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
            break;
        }
    }

}
void On_EVENT_RELAY_SERVER_STATUS_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_RELAY_SERVER_STATUS_ACK );
    SAFE_DELETE( pkBuff );

    switch( kRecv.m_nOK )
    {
    case 0:
        break;
    case 1:
        {
            SiKGCRoomManager()->SetRecvRelayServerStatus(kRecv);

            if ( SiKGCMatchManager()->GetCurrentState() == KGCMatchManager::MSTATE_COMPLETE_STATE ) {
                SiKGCMatchManager()->SetCurrentState( KGCMatchManager::MSTATE_ROOM_STATE );
            }

            // 060301. kkurrung. TCP Relay 를 위해서 p2p 안에 있는  TRUserProxy를 연결해준다.
            in_addr in;
            in.S_un.S_addr = kRecv.m_dwTRelayServerIP;
            SiKP2P()->DisConnectTCPRelay();
            if ( !SiKP2P()->m_spTRUserProxy->Connect( inet_ntoa(in), kRecv.m_usTRelayServerPort, g_kGlobalValue.ServerInfo.dwUserUID ) )
            {
                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_TCP_CONNECT_FAIL), L"" );
                SiGCClientErrorManager()->ErrorCollect( KEventErr::ERR_NETWORK, KNetWorkErr::CE_TCP_CONNECT_ERROR );           
            }

            SiKP2P()->m_spTRUserProxy->SetPingTimeoutLimit( GetRelayPingLimit() );
            SiKP2P()->m_spTRUserProxy->SetPingSendGap( GetRelayPingInterval() );


            //====================================================================================
            ((KGCStateLoading*)g_MyD3D->m_pStateMachine->GetStatePtr( GS_GAME_LOADING ))->ClearUserConnectState();

#if defined(USE_PING_STATE_UI) && !defined(USE_ONLY_TCP_RELAY) && !defined(USE_P2P_OR_TCP_RELAY)
            KP2P::GetInstance()->Send_PingInfoNot(g_kGlobalValue.GetTRAvgPing());
            KP2P::GetInstance()->Send_RoomMemberPingInfoReq();
#endif
        }
        break;
    }

}

void On_EVENT_TONG_DONATION_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_TONG_DONATION_INFO_ACK );
    SAFE_DELETE( pkBuff );

    switch( kRecv.m_nOK )
    {
    case 0:
        SiKGCContributionManager()->OnEventTongDonationInfoAck( kRecv );
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_CONTRIBUTION_DLG );
        break;
    default:
        break;
    }
}

void On_EVENT_TONG_DONATION_DONATE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_TONG_DONATION_DONATE_ACK );
    SAFE_DELETE( pkBuff );

    switch( kRecv.m_nOK )
    {
    case 0:
        SiKGCContributionManager()->OnEventTongDonationDonateAck( kRecv );
        break;
    default:
        break;
    }
}


void On_EVENT_SOSCIAL_COMMERCE_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SOSCIAL_COMMERCE_INFO_ACK );
    SAFE_DELETE( pkBuff );
    // kRecv : 소셜커머스 판매 타입별 전체 정보 컨테이너
    // std::map<int, KInformationDataOfSellType>

    Result_ReceiveSocialCommerceInfo = 0;

    SiKGCSocialCommerceManager()->SetEventInfo( kRecv );

    g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_SOCIAL_COMMERCE, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL);

}

void On_EVENT_COORDI_GRADE_UPGRADE_INFO_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_COORDI_GRADE_UPGRADE_INFO_ACK );
    SAFE_DELETE( pkBuff );

//     GCITEMID                m_GradeUpgradeItemID; // 등급 업그레이드 아이템.
//     std::map<char,int>      m_mapGradeUseCount;   // 등급 업그레이드시 아이템 사용 갯수
//     int                     m_nEnableItemType;    // 허용 ItemType.
//     std::set<GCITEMID>      m_setUpgradeBanItem;  // 업그레이드 불가 아이템.

    Result_ReceiveCoordiUpgradeInfo = 0;
    g_pItemMgr->SetCoordiUpgradeInfo( kRecv );

}

void On_EVENT_COORDI_GRADE_UPGRADE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_COORDI_GRADE_UPGRADE_ACK );
    SAFE_DELETE( pkBuff );

//     int                             m_nOK;
//     KItem                           m_kItem;        // 코디 속성 업그레이드한 아이템
//     KItem                           m_kUseItem;     // 업그레이드 재료 아이템
//     std::vector<KItem>              m_vecUseItem;   // 사용한 아이템 정보.

    /*
    kPacket_.m_nOK, 0    // 성공
    kPacket_.m_nOK, 1    // 코디 업그레이드할 아이템이 없음.
    kPacket_.m_nOK, 2    // 코디 업그레이드 재료 아이템이 없음.
    kPacket_.m_nOK, 3    // 코디 업그레이드 재료 아이템이 아님.
    kPacket_.m_nOK, 4    // 코디 아이템이 아님.
    kPacket_.m_nOK, 5    // 업그레이드할 등급에 사용 갯수가 설정되어 있지 않음.
    kPacket_.m_nOK, 6    // 변경된 속성 DB에 기록 하는데 오류 발생.
    kPacket_.m_nOK, 7    // 요청한 등급정보가 잘못되었음.
    kPacket_.m_nOK, 8    // 등급 업그레이드 불가능한 아이템임.
    kPacket_.m_nOK, 9    // 업그레이드 할려는 아이템 속성이 없음.
    */

    switch( kRecv.m_nOK )
    {
    case 0:
        {

            g_pItemMgr->m_kInventory.AddItem( kRecv.m_kItem, true );
            g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecUseItem, true );

            g_pkUIScene->m_pkCoordiUpgradeDlg->InitResultState();
            // 인벤토리 업데이트 
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            g_pkUIScene->m_pkCashShopScene->UpdateUserInfo();
            g_pkUIScene->m_pkGPShopScene->UpdateUserInfo();

            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_COORDI_COMPOSE_OK), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL,0,0, true, true );
        }
        break;
    case 1:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_COORDI_UPGRADE_ERROR0), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL,0,0, true, true );
        }
        break;
    case 2:
    case 3:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_COORDI_UPGRADE_ERROR6), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL,0,0, true, true );
        }
        break;
    case 4:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_COORDI_UPGRADE_ERROR1), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL,0,0, true, true );
        }
        break;
    case 7:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_COORDI_UPGRADE_ERROR0), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL,0,0, true, true );
        }
        break;
    case 8:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_COORDI_UPGRADE_ERROR5), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL,0,0, true, true );
        }
        break;
    case 9:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK,g_pkStrLoader->GetString(STR_ID_COORDI_UPGRADE_ERROR2), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL,0,0, true, true );
        }
        break;
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp,
                KGCUIScene::GC_MBOX_USE_NORMAL,0,0, true, true );
        }
        break;
    };
}

void On_EVENT_SKILL_SCROOL_TRAINING_ACK( WPARAM wParam, LPARAM lParam )
{
    /*
    kPacket.m_nOK, 0 // 성공
    kPacket.m_nOK, 1 // 스킬 스크롤 아이템을 가지고 있지 않음.
    kPacket.m_nOK, 2 // 스킬 스크롤 아이템 설정이 되지 않음.
    kPacket.m_nOK, 3 // 클라이언트와 서버가 알고 있는 스킬정보가 틀림.
    kPacket.m_nOK, 4 // 존재하지 않는 스킬입니다.
    kPacket.m_nOK, 5 // 이미 획득한 스킬 입니다.
    kPacket.m_nOK, 6 // 해당 캐릭터가 존재하지 않음.
    */
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SKILL_SCROOL_TRAINING_ACK );
    SAFE_DELETE( pkBuff );

    Result_ReceiveSkillScroolITemReq = 0;

    switch( kRecv.m_nOK )
    {
    case 0:
        {
            if ( !kRecv.m_vecUseItem.empty() ) {
                g_pItemMgr->m_kInventory.AddItemList( kRecv.m_vecUseItem, true );
            }

            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();

            if( true == SiGCSKT()->Server_TrainSkill( kRecv.m_nSkillID ) )
            {
                SiGCSKT()->EquipSkill( (EGCSkillTree)kRecv.m_nSkillID, g_pkUIScene->m_pkSkillTree->GetSetID() );

                ///////////////////////////////////////////////////////////////////////////////////
                // 패시브 스킬인 경우 자동장착 상태가 되므로 다른 스킬세트에도 장착시켜줘야 한다.
                const GCSkill* pSkill = SiGCSKT()->GetSkill( static_cast< EGCSkillTree >( kRecv.m_nSkillID ) );            
                if( pSkill && pSkill->m_bPassive ) {
                    for( int i = 0; i < SiGCSKT()->GetCurrentSkillSetSize(); i++ ) {
                        if( i == g_pkUIScene->m_pkSkillTree->GetSetID() ) {
                            continue;
                        }

                        SiGCSKT()->EquipSkill( (EGCSkillTree)kRecv.m_nSkillID, i );
                    }
                }
                ///////////////////////////////////////////////////////////////////////////////////
                g_pkUIScene->m_pkSkillTree->ThreadSafeUpdate();
            }
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_TRAINSKILL_SUCCESS ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
            break;
        }
    case 4:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SKILL_ALREADY_EXIST ),
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
            break;
        }
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );	
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_TRAINSKILL_ERROR ),
                strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, false );
            break;
        }
    }
}

void On_EVENT_NICKNAME_VALIDITY_CHECK_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_NICKNAME_VALIDITY_CHECK_ACK );
    SAFE_DELETE( pkBuff );

	Result_ReportNickName = kRecv.m_nOK;
    /*
    에러값 추가 예정.
    */
}

void On_EVENT_INFINITY_DUNGEON_MONSTER_SUMMON_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_INFINITY_DUNGEON_MONSTER_SUMMON_ACK );
    SAFE_DELETE( pkBuff );

    /*
    무한 던전에서 몬스터 소환 실패시 방장에게 전달됨
    kRecv: 1: 무한던전이 아닌데 무한던전 몬스터 소환 요청
    kRecv: 2: 무한던전 몬스터 소환 해킹 감지(소환 주기가 너무 빠른지, 한번에 너무 많이 소환하는지 확인)
    */


    switch( kRecv )
    {
    case 1: 
    case 2:

        break;
    default:
        break;
    };
}

void On_EVENT_INFINITY_DUNGEON_MONSTER_SUMMON_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_INFINITY_DUNGEON_MONSTER_SUMMON_BROAD );
    SAFE_DELETE( pkBuff );

    /*
    무한 던전에서 몬스터 소환 성공시 모든 방원들에게 방송됨
    소환 실패시 EVENT_INFINITY_DUNGEON_MONSTER_SUMMON_ACK가 방장에게만 전달됨
    */

    // 방장은 소환 요청 
    if( g_kGlobalValue.m_kUserInfo.bHost ) { 
        SiKGCInfinityDungeonManager()->GenMonster( kRecv.m_vecSummonedMonsters );
    }

    // 각 파티원들 랭크정보 
    g_pkQuestManager->SetInfinityDungeonPartyRank( kRecv.m_nCurrentTopRank );
    g_pkQuestManager->SetInfinityDungeonMonsterLevel( kRecv.m_vecSummonedMonsters.begin()->m_nMonLv );

    // 드랍 아이템 정보 
    SiKGCDropItemManager()->AddDropItemListPreSet( kRecv.m_vecMonsterDrop );
    SiKGCDropItemManager()->AddGPListPreSet( kRecv.m_vecGpDrop );
}

void On_EVENT_INFINITY_DUNGEON_REWARD_EXP_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_INFINITY_DUNGEON_REWARD_EXP_BROAD );
    SAFE_DELETE( pkBuff );

    /*
    무한 던전에서 몬스터 KILL 요청시 응답으로 모든 방원들에게 방송됨
    KILL 처리 실패시 패킷 전달되지 않음
    */

    if ( g_pStateGame ) 
        g_pStateGame->DungeonRewardExp( kRecv );
}

void On_EVENT_INFINITY_DUNGEON_REWARD_ITEM_BROAD( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_INFINITY_DUNGEON_REWARD_ITEM_BROAD );
    SAFE_DELETE( pkBuff );

    /*
    무한 던전에서 아이템 획득 요청시 응답으로 모든 방원들에게 방송됨
    kRecv.m_nOK: NET_OK: 성공
    kRecv.m_nOK: ERR_INFINITY_DUNGEON_01: 획득 요청한 아이템이 드랍 예정 아이템 리스트에 없음.
    kRecv.m_nOK: ERR_INFINITY_DUNGEON_02: 아이템을 획득할 유저를 결정할 수 없음.
    kRecv.m_nOK: ERR_INFINITY_DUNGEON_03: 무한던전 아이템 DB지급 실패.
    */

    switch ( kRecv.m_nOK )
    {
    case 0: // 성공.
        {
            if ( g_pStateGame ) 
            {
                // 사용하지 않아서 빈거 하나 만든다.
                std::vector<std::pair< DWORD, std::vector<KItem>>> vecPartyDropItem;
                
                g_pStateGame->DungeonRewardItem( kRecv.m_dwRecvUserUID, kRecv.m_vecDropItem, vecPartyDropItem, kRecv.m_mapUserDice );
            }
        }
        break;
    default: // 알 수 없는 오류.
        break;
    };
}

void On_EVENT_DUNGEON_MISSION_REGIST_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DUNGEON_MISSION_REGIST_ACK );
    SAFE_DELETE( pkBuff );

    //0;  // 성공
    //1;  // 유저가 존재하지 않음
    //2;  // 현재 등록된 미션임
    //3;  // 이미 완료한 미션임
    //4;  // 미션 슬롯이 꽉찼음
    //5;  // 등록된 미션과 연관된 미션이므로 등록불가.
    //7;  // 미션 정보 가져오기 실패.
    //8;  // 캐릭터가 존재하지 않음
    //9;  // 전직 상태가 맞지 않음.
    //10; // 캐릭터 레벨 제한을 만족하지 못함
    //11; // 존재하는 미션이 아님.
    //12; // Count SubMission 목록을 가져 오는중 실패.
    //13; // 등록시 DB 오류.
    //40; // 미션 등록에 필요한 조건에 해당하는 미션을 클리어하지 않았음.
    //-99; // 알수없는 오류

    if( kRecv.m_nOK == 0 )
    {
        g_kGlobalValue.m_kUserMission.AddMission( kRecv.m_kMissiondata.m_dwMissionID );
        g_kGlobalValue.m_kUserMission.RefreshUserMission();
        g_pkUIScene->m_pkMissionUI_S4->RefreshUI();
        g_pkUIScene->m_pkRoomSceneS6->m_bShowMissionUI = true;

        //  룸안이면
        if ( g_MyD3D->m_pStateMachine->IsStateRoom() ) 
        {
            if( !g_MyD3D->m_pStateMachine->IsStateMyInfo() )
            {
                g_pkUIScene->m_pkRoomSceneS6->m_pkRoomDungeonPanel->SetNormalMission(0);
            }

            g_pkUIScene->m_pkRoomSceneS6->UpdateMissionData();
#if defined( USE_GUIDE_SYSTEM )
            //튜토리얼중이고 에픽미션 가이드가 완료되지 않았으면 가이드상태 갱신
            if ( g_pkGameOverlayUI->m_pkAddtionGuide->GetGuideUserState() == STATE_PROGRESS_IN_TUTORIAL_DUNGEON_OUT && !g_MyD3D->m_kGuideMgr.IsCompleteGuide(12) )
            {
                // 가이드 상태조건 갱신
                g_MyD3D->m_kGuideMgr.CheckEnableGuide();
                g_pkUIScene->m_pkGCGuide->ToggleRender( false );
            }
#endif
        }
    }
}

void On_EVENT_FINISHED_MISSION_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_FINISHED_MISSION_LIST_NOT );
    SAFE_DELETE( pkBuff );

    SiKGCMissionManager()->SetClearMissionData( kRecv );
}

void On_EVENT_MISSION_GETTABLE_CONDITION_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_MISSION_GETTABLE_CONDITION_INFO_NOT );
    SAFE_DELETE( pkBuff );

    SiKGCMissionManager()->SetMissionGettableCondditionInfo( kRecv );
}

void On_EVENT_DUNGEON_PERSONAL_RECORD_INFO_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DUNGEON_PERSONAL_RECORD_INFO_NOT );
    SAFE_DELETE( pkBuff );
    /*
    던전 개인 최고 기록 갱신시 캐릭터별로 알림(변경되는 모드의 정보만 전달)
    kRecv.m_nOK: NET_OK: 성공 - 항상 성공. 오류값은 서버에서만 사용
    kRecv.m_cCharType: 캐릭터 번호
    kRecv.m_mapDungeonPersonalRecord: 변경된 기록 정보
    */

    switch( kRecv.m_nOK )
    {
    case NetError::NET_OK: 
        {
            if ( g_kGlobalValue.m_kUserInfo.GetCurrentCharType() == kRecv.m_cCharType )
                g_kGlobalValue.m_kHeroDungeonInfo.SetDungeonPersonalRecord( kRecv.m_mapDungeonPersonalRecord );

            if ( g_pkUIScene->m_pkDungeonRankingDlg )
                g_pkUIScene->m_pkDungeonRankingDlg->UpdateClearData();
        }
        break;
    default:
        {
        }
        break;
    }
}

void On_EVENT_DUNGEON_RANK_CURRENT_SEASON_RANK_PAGE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DUNGEON_RANK_CURRENT_SEASON_RANK_PAGE_ACK );
    SAFE_DELETE( pkBuff );
    /*
    현재 시즌 랭크 리스트 페이지 응답
    kRecv.m_nOK: NET_OK: 성공
    kRecv.m_nOK: ERR_DUNGEON_RANK_01: 랭킹을 처리하는 던전이 아님.
    kRecv.m_nOK: ERR_DUNGEON_RANK_02: 해당 페이지의 랭킹 정보가 없음. 첫 페이지가 비어있을 경우에도 전달
    kRecv.m_nPageNum: 요청한 페이지
    kRecv.m_nModeID: 요청한 모드
    kRecv.m_vecDungeonRankList: 랭크 정보
    */

    switch( kRecv.m_nOK )
    {
    case NetError::NET_OK: 
    case NetError::ERR_DUNGEON_RANK_02:
        {
            g_kGlobalValue.m_kHeroDungeonInfo.SetDungeonRank( true, kRecv.m_nModeID, kRecv.m_nPageNum, kRecv.m_vecDungeonRankList );

            if ( g_pkUIScene->m_pkDungeonRankingDlg )
            {
                g_pkUIScene->m_pkDungeonRankingDlg->LockUI( false );
                g_pkUIScene->m_pkDungeonRankingDlg->UpdateRankingUI();
            }
        }
        break;
    default:
        {
        }
        break;
    }

}

void On_EVENT_DUNGEON_RANK_PREVIOUS_SEASON_RANK_PAGE_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DUNGEON_RANK_PREVIOUS_SEASON_RANK_PAGE_ACK );
    SAFE_DELETE( pkBuff );
    /*
    이전 시즌 랭크 리스트 페이지 응답
    kRecv.m_nOK: NET_OK: 성공
    kRecv.m_nOK: ERR_DUNGEON_RANK_01: 랭킹을 처리하는 던전이 아님.
    kRecv.m_nOK: ERR_DUNGEON_RANK_02: 해당 페이지의 랭킹 정보가 없음. 첫 페이지가 비어있을 경우에도 전달
    kRecv.m_nPageNum: 요청한 페이지
    kRecv.m_nModeID: 요청한 모드
    kRecv.m_vecDungeonRankList: 랭크 정보
    */

    switch( kRecv.m_nOK )
    {
    case NetError::NET_OK: 
    case NetError::ERR_DUNGEON_RANK_02:
        {
            g_kGlobalValue.m_kHeroDungeonInfo.SetDungeonRank( false, kRecv.m_nModeID, kRecv.m_nPageNum, kRecv.m_vecDungeonRankList );

            if ( g_pkUIScene->m_pkDungeonRankingDlg )
            {
                g_pkUIScene->m_pkDungeonRankingDlg->LockUI( false );
                g_pkUIScene->m_pkDungeonRankingDlg->UpdateRankingUI();
            }
        }
        break;
    default:
        {
        }
        break;
    }

}

void On_EVENT_DUNGEON_RANK_CURRENT_SEASON_USER_RANK_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DUNGEON_RANK_CURRENT_SEASON_USER_RANK_ACK );
    SAFE_DELETE( pkBuff );
    /*
    현재 시즌 유저 랭크 응답
    kRecv.m_nOK: NET_OK: 성공. 항상 성공
    kRecv.m_cCharType: 캐릭터 번호
    kRecv.m_nModeID: 요청한 모드
    kRecv.m_kDungeonRankPersonal: 유저 랭크 정보. 해당 유저, 캐릭터의 현재 시즌 순위가 없는 경우 m_nRank 값을 -1로 전달
    */

    switch( kRecv.m_nOK )
    {
    case NetError::NET_OK: 
        {
            if ( g_kGlobalValue.m_kUserInfo.GetCurrentCharType() == kRecv.m_cCharType )
                g_kGlobalValue.m_kHeroDungeonInfo.SetMyDungeonRank( true, kRecv.m_cCharType, kRecv.m_nModeID, kRecv.m_kDungeonRankPersonal );
        }
        break;
    default:
        {
        }
        break;
    }

}

void On_EVENT_DUNGEON_RANK_PREVIOUS_SEASON_USER_RANK_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_DUNGEON_RANK_PREVIOUS_SEASON_USER_RANK_ACK );
    SAFE_DELETE( pkBuff );
    /*
    이전 시즌 유저 랭크 응답
    kRecv.m_nOK: NET_OK: 성공. 항상 성공
    kRecv.m_cCharType: 캐릭터 번호
    kRecv.m_nModeID: 요청한 모드
    kRecv.m_kDungeonRankPersonal: 유저 랭크 정보. 해당 유저, 캐릭터의 이전 시즌 순위가 없는 경우 m_nRank 값을 -1로 전달
    */

    switch( kRecv.m_nOK )
    {
    case NetError::NET_OK: 
        {
            if ( g_kGlobalValue.m_kUserInfo.GetCurrentCharType() == kRecv.m_cCharType )
                g_kGlobalValue.m_kHeroDungeonInfo.SetMyDungeonRank( false, kRecv.m_cCharType, kRecv.m_nModeID, kRecv.m_kDungeonRankPersonal );
        }
        break;
    default:
        {
        }
        break;
    }

}

void On_EVENT_SINGLE_RANDOM_ATTRIBUTE_ITEM_LIST_NOT( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SINGLE_RANDOM_ATTRIBUTE_ITEM_LIST_NOT );
    SAFE_DELETE( pkBuff );
    /*
    개별 랜덤 속성 주문서 아이템 정보
    typedef std::map< DWORD, std::set< GCITEMID > > KEVENT_SINGLE_RANDOM_ATTRIBUTE_ITEM_LIST_NOT
    < 사용가능 최대 레벨, < 주문서 아이템ID > >
    */

    // 개별 속성 랜덤 주문서 리스트
    g_pItemMgr->SetAttributeSingleRandomItemList( kRecv );
}

void On_EVENT_SINGLE_RANDOM_ATTRIBUTE_RANDOM_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_SINGLE_RANDOM_ATTRIBUTE_RANDOM_ACK );
    SAFE_DELETE( pkBuff );
    /*
    개별 랜덤 속성 주문서 사용 응답
    kRecv.m_nOK: NET_OK: 성공
    kRecv.m_nOK: ERR_SINGLE_RANDOM_ATTRIBUTE_01: 속성을 변경할 아이템이 인벤토리에 없음.
    kRecv.m_nOK: ERR_SINGLE_RANDOM_ATTRIBUTE_02: 개별 랜덤 속성 주문서 아이템이 인벤토리에 없음.
    kRecv.m_nOK: ERR_SINGLE_RANDOM_ATTRIBUTE_03: 대상 아이템이 개별 랜덤 속성 주문서를 적용할 수 있는 레벨이 아님.
    kRecv.m_nOK: ERR_SINGLE_RANDOM_ATTRIBUTE_04: 대상 아이템이 개별 랜덤 속성 주문서를 사용할 수 없는 아이템 타입임.
    kRecv.m_nOK: ERR_SINGLE_RANDOM_ATTRIBUTE_05: 대상 아이템에 랜덤으로 변경할 선택된 속성이 없음.
    kRecv.m_nOK: ERR_SINGLE_RANDOM_ATTRIBUTE_06: 대상 아이템에 적용할 속성을 선택하지 못함.
    kRecv.m_nOK: ERR_SINGLE_RANDOM_ATTRIBUTE_07: DB에 기록 중 기록하려는 속성 정보가 없음.
    kRecv.m_nOK: ERR_SINGLE_RANDOM_ATTRIBUTE_08: 대상 아이템의 속성정보 DB 기록 실패.
    kRecv.m_nOK: ERR_SINGLE_RANDOM_ATTRIBUTE_09: 개별 랜덤 속성 아이템의 서버 DB 수량 동기화 실패.

    kRecv.m_nSlotID: 변경된 속성의 번호
    kRecv.m_kTargetItem: 속성 초기화한 아이템 정보
    kRecv.m_kSingleRandomAttributeItem: 개별 랜덤 속성 주문서 아이템 변경정보
    */

    Result_Random_Init_attribute = kRecv.m_nOK;

    switch( kRecv.m_nOK )
    {
    case NetError::NET_OK: 
        {
            g_pItemMgr->m_kInventory.AddItem( kRecv.m_kSingleRandomAttributeItem, true );
            g_pItemMgr->m_kInventory.AddItem( kRecv.m_kTargetItem, true);

            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
            g_pkUIScene->m_pkMyInfoScene->UpdateData();

            g_pkUIScene->m_pkAttributeSelectBox->SetAttributeInfoRandom(kRecv.m_kTargetItem.m_ItemUID, true, false );
            g_pkUIScene->m_pkAttributeSelectBox->SetResultSingle( kRecv.m_nSlotID );
        }
        break;
    case NetError::ERR_SINGLE_RANDOM_ATTRIBUTE_01:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SINGLE_RANDOM_ATTRIBUTE_01 ), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        }
        break;
    case NetError::ERR_SINGLE_RANDOM_ATTRIBUTE_02:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SINGLE_RANDOM_ATTRIBUTE_02 ), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        }
        break;
    case NetError::ERR_SINGLE_RANDOM_ATTRIBUTE_03:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SINGLE_RANDOM_ATTRIBUTE_03 ), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        }
        break;
    case NetError::ERR_SINGLE_RANDOM_ATTRIBUTE_04:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_SINGLE_RANDOM_ATTRIBUTE_04 ), 
                L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true);
        }
        break;    
    default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK );
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_UNKWON_ERROR), strTemp,
                KGCUIScene::GC_MBOX_USE_NORMAL,0,0, true, true );
        }
        break;
    }
}

void On_EVENT_GACHA_PONG_INFO_NOT(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_GACHA_PONG_INFO_NOT);
    SAFE_DELETE(pkBuff);

    g_kGlobalValue.SetGachaPonMachineInfo(kRecv);
}


void On_EVENT_GACHA_PONG_PLAY_INFO_NOT(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_GACHA_PONG_PLAY_INFO_NOT);
    SAFE_DELETE(pkBuff);

    g_kGlobalValue.UpdateGachaPonMachine(kRecv.m_prMachineInfo, kRecv.m_dwLeftCapsules, kRecv.m_dwMainRewardCnt);
    g_pkUIScene->m_pkGachaPongDlg->UpdateCapsuleNumber();
}

void On_EVENT_GACHA_PONG_ACTION_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_GACHA_PONG_ACTION_ACK);
    SAFE_DELETE(pkBuff);

    switch (kRecv.m_nOK)
    {
        case 0:
        {
            std::vector<KItem> vecTempItemList;
            vecTempItemList.push_back(kRecv.m_kGachaPonCoin);
            g_pItemMgr->SetDurationItem(vecTempItemList);

            g_kGlobalValue.UpdateGachaPonMachine(kRecv.m_prMachineInfo, kRecv.m_dwLeftCapsules, kRecv.m_dwMainRewardCnt);

            std::wstring strMsg;
            if (kRecv.m_vecRewardItems.empty() == false)
            {
                std::vector<KItem> vecTemp = kRecv.m_vecRewardItems;
                g_pItemMgr->GetNewReceiveItemNum(kRecv.m_vecRewardItems, vecTemp);

                for (int i = 0; i < (int)kRecv.m_vecRewardItems.size(); i++)
                {
                    GCItem* kItem = g_pItemMgr->GetItemData(kRecv.m_vecRewardItems[i].m_ItemID / 10);
                    KItem& kRewardItem = vecTemp[i];
                    CONTINUE_NIL(kItem);

                    if (kRewardItem.m_nPeriod == KItem::UNLIMITED_ITEM && kRewardItem.m_nCount == KItem::UNLIMITED_ITEM)
                    {
                        strMsg = g_pkStrLoader->GetReplacedString(STR_ID_ITEM_RECEIVE1, "l", kItem->strItemName);
                    }
                    else if (kRewardItem.m_nCount != KItem::UNLIMITED_ITEM)
                    {
                        DWORD dwReceiveCount = kRewardItem.m_nCount;
                        KItem* pkInvenItem = g_pItemMgr->m_kInventory.FindItemByItemID(kRewardItem.m_ItemID / 10);

                        if (pkInvenItem != NULL)
                        {
                            int iShortCutNum = g_MyD3D->GetMyShortCutSlot()->GetCurEquipItemNum(kRecv.m_vecRewardItems[i].m_ItemID / 10);
                            dwReceiveCount -= (pkInvenItem->m_nCount + iShortCutNum);
                        }

                        strMsg = g_pkStrLoader->GetReplacedString(STR_ID_ITEM_RECEIVE2, "li", kItem->strItemName, (int)dwReceiveCount);
                    }
                    else
                    {
                        strMsg = g_pkStrLoader->GetReplacedString(STR_ID_ITEM_RECEIVE3, "li", kItem->strItemName, (int)vecTemp[i].m_nPeriod);
                    }

                    if (-1 != kItem->dwGoodsID)
                    {
                        g_pkUIScene->m_pkTreaureItemBox->SetContentAutoMultiLine(strMsg);
                        g_pkUIScene->m_pkTreaureItemBox->SetItem(kItem->dwGoodsID);
                    }
                }

                g_pkUIScene->m_pkGachaPongDlg->ShowBallRollingEffect();
                g_pItemMgr->m_kInventory.AddItemList(kRecv.m_vecRewardItems, true);
            }
            else
            {
                g_pkUIScene->m_pkGachaPongDlg->CloseDlg();
                g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_PONG_INFO_MISMATCH), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
            }
            g_pkUIScene->m_pkMyInfoScene->UpdateGameData();
        }
        break;
        case 0x70D:
        {
            g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_PONG_INSUFFICIENT_COIN), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
            g_pkUIScene->m_pkGachaPongDlg->RestartMachine();
        }
        break;
        case 0x70B:
        {
            g_pkUIScene->m_pkGachaPongDlg->CloseDlg();
            g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_PONG_INFO_MISMATCH), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
        }
        break;
        default:
        {
            std::wstring strTemp = g_pkStrLoader->GetReplacedString(STR_UNKWON_ERROR_CODE, "ii", wParam, kRecv.m_nOK);
            g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_GACHA_PONG_INFO_ERROR),
                strTemp, KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
            break;
        }
    }
}

void On_EVENT_CHANGE_PVP_ROOM_EXTRA_OPTION_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_CHANGE_PVP_ROOM_EXTRA_OPTION_ACK);
    SAFE_DELETE(pkBuff);

    if (kRecv.m_nOK == 0)
    {
        if (g_MyD3D->m_pStateMachine->IsStateRoom() || g_MyD3D->m_pStateMachine->GetState() == GS_GAME_END)
        {
            SiKGCRoomManager()->UpdateRoomInfo(kRecv.m_kRoomOptions);
        }
    }
    else
    {
        g_pkChatManager->AddChatMsgTo(g_MyD3D->m_pStateMachine->GetState(), g_pkStrLoader->GetString(STR_ID_CHANGE_PVP_ROOM_OPTION_ERROR), KGCChatManager::CHAT_CMD_ADMIN);
    }
}

void On_EVENT_CHANGE_PVP_ROOM_EXTRA_OPTION_BROAD(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KRoomOptions);
    SAFE_DELETE(pkBuff);

    if (g_MyD3D->m_pStateMachine->IsStateRoom() || g_MyD3D->m_pStateMachine->GetState() == GS_GAME_END)
    {
        SiKGCRoomManager()->UpdateRoomInfo(kRecv);
    }
}

void On_EVENT_IN_ROOM_CHANGE_CHARACTER_INFO_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_CHANGE_CHARACTER_INFO_ACK);
    SAFE_DELETE(pkBuff);

    Result_ChangeChar = kRecv.m_nOK;

    switch (kRecv.m_nOK)
    {
    case 0:
    {
        g_pItemMgr->m_kInventory.AddItemList(kRecv.m_vecInv, true);
        g_kGlobalValue.m_kUserCollectionMission.SetUserCollectionMissionList(kRecv.m_vecCollection);
        g_kGlobalValue.m_kUserMission.ClearUserMission();
        g_kGlobalValue.m_kUserMission.SetUserMissionList(kRecv.m_vecMissionSlot);
        g_kGlobalValue.m_kUserInfo.mapStagePlayable = kRecv.m_mapDifficulty;
        g_kGlobalValue.m_kUserInfo.m_vecFontVector = kRecv.m_vecFontVector;
        g_kGlobalValue.m_kUserInfo.m_iPvExp = kRecv.m_iPvExp;

        SiKGCPrivateDungeonManager()->CheckFirstDungeon(GC_CHAR_INVALID);
        GCFUNC::ConvertPetInfo(g_MyD3D->m_mapPetInfo, kRecv.m_mapPetInfo);

        SCharInfo& kCharInfo = g_kGlobalValue.m_kUserInfo.GetCurrentChar(kRecv.m_cCharacter);
        if (kCharInfo == kRecv.m_cCharacter) {
            std::vector< KEquipItemInfo >::const_iterator it = kRecv.m_vecEquipItems.begin();
            for (; it != kRecv.m_vecEquipItems.end(); ++it) {
                if (it->m_dwUID < 0) {
                    continue;
                }

                g_pItemMgr->EquipInventoryItem(&kCharInfo, it->m_dwUID, false);
            }

            it = kRecv.m_vecLookEquips.begin();
            for (; it != kRecv.m_vecLookEquips.end(); ++it) {
                if (it->m_dwUID < 0) {
                    continue;
                }

                g_pItemMgr->EquipInventoryItem(&kCharInfo, it->m_dwUID, true);
            }

            kCharInfo.m_nInvenCapacity = kRecv.m_nInvenCapacity;
            kCharInfo.m_nCoordiCapacity = kRecv.m_nLookInvenCapacity;
            g_kGlobalValue.m_iInvenCapacity = kCharInfo.m_nInvenCapacity;
            g_kGlobalValue.m_iCoordiCapacity = kCharInfo.m_nCoordiCapacity;

            g_kGlobalValue.m_kUserInfo.SetCurrentChar(kRecv.m_cCharacter);

            auto& curChar = g_kGlobalValue.m_kUserInfo.GetCurrentChar();
            curChar.vecPetGlyphInfo.clear();

            for (auto petGlyph : kRecv.m_vecPetGlyphCharData)
            {
                KSimpleItem kItem;
                kItem.m_dwID = petGlyph.m_dwID;
                kItem.m_dwUID = petGlyph.m_dwUID;
                kItem.m_cItemType = petGlyph.m_cType;
                curChar.vecPetGlyphInfo.push_back(kItem);
            }

            curChar.dwPetGlyphSize = curChar.vecPetGlyphInfo.size();

            g_MyD3D->m_TempPlayer.m_kUserInfo = g_kGlobalValue.m_kUserInfo;
            g_kGlobalValue.m_mapChangeWeapon.insert(std::pair<char, std::pair<bool, GCITEMUID>>(kRecv.m_cCharacter, std::pair<bool, GCITEMUID>(kRecv.m_bChangeWeaponLock, kRecv.m_kChangeWeaponItem.m_dwUID)));
            g_kGlobalValue.SetSavedCharType(g_kGlobalValue.m_kUserInfo.GetCurrentChar().iCharType);
            g_kGlobalValue.SendSavedCharType();
        }
    }
    break;
    default:
        break;
    };
}

void On_EVENT_IN_ROOM_CHANGE_INDOOR_USERINFO_BROAD(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KInDoorUserInfo);
    Result_ReceiveInRoomIndoorChangeReq = 0;
    if (g_MyD3D->m_pStateMachine->IsStateRoom() || g_MyD3D->m_pStateMachine->GetState() == GS_GAME_END)
        On_CHANGE_INDOORUSER_INFO(kRecv);
    SAFE_DELETE(pkBuff);
}

void On_EVENT_PVP_ROOM_LIST_SEARCH_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KPagePvPInfo);
    SAFE_DELETE(pkBuff);

    if (kRecv.m_nOK == 0)
    {
        kRecv.m_buffCompList.UnCompress();
        std::vector<KSimpleRoomInfo> kPacket;
        ks.BeginReading(&kRecv.m_buffCompList);
        ks.Get(kPacket);
        ks.EndReading();

        SiKGCRoomListManager()->UpdateRoomList(kPacket, 1, 1);
    }
}

void On_EVENT_COORDIVIEWER_GETSLOT_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_COORDIVIEWER_GETSLOT_ACK);
    SAFE_DELETE(pkBuff);

    g_pkUIScene->m_pkCoordiViewDlg->m_mapSlotInfo = kRecv.m_mapSlotInfo;
    Result_ReceiveCoordiviewSlotGetReq = 0;
}

void On_EVENT_COORDIVIEWER_SETSLOT_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_COORDIVIEWER_SETSLOT_ACK);
    SAFE_DELETE(pkBuff);

    if (kRecv.m_iOK == 0)
    {
        Result_ReceiveCoordiviewSlotSetReq = kRecv.m_iOK;
        g_pkUIScene->m_pkCoordiViewDlg->m_mapSlotInfo[g_pkUIScene->m_pkCoordiViewDlg->m_iCurrentSlot] = g_pkUIScene->m_pkCoordiViewDlg->m_vecCurrentEquipedItems;
        g_pkUIScene->m_pkCoordiViewDlg->CheckCoordiViewerSlots();
        std::wstringstream stm;
        stm << g_pkUIScene->m_pkCoordiViewDlg->m_iCurrentSlot + 1;
        std::wstring strMsg = g_pkStrLoader->GetReplacedString(STR_ID_COORDIVIEW_SUCCESS, "l", stm.str());
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, strMsg, L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
    }
    else
    {
        g_pkUIScene->MessageBox(KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString(STR_ID_COORDIVIEW_UNKOWN), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true);
    }
}

void On_EVENT_PET_MAGIC_STONE_INFO_NOT(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_PET_MAGIC_STONE_INFO_NOT);
    SAFE_DELETE(pkBuff);

    SiGCPetMagicStone()->SetPetGlyphData(kRecv);
}

void On_EVENT_PET_MAGIC_STONE_CHANGE_EQUIP_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_PET_MAGIC_STONE_CHANGE_EQUIP_ACK);
    SAFE_DELETE(pkBuff);

    if (kRecv.m_nOK == 0)
    {
        Result_ReceivePetMagicStoneChangeEquipReq = kRecv.m_nOK;

        KSimpleItemVector vecEquippedGlyph;
        for (auto equippedGlyph : kRecv.m_vecEquippedGlyphs)
        {
            KSimpleItem item;

            item.m_dwID = equippedGlyph.m_dwID;
            item.m_dwUID = equippedGlyph.m_dwUID;
            item.m_cItemType = equippedGlyph.m_cType;

            vecEquippedGlyph.push_back(item);
        }

        g_kGlobalValue.m_kUserInfo.GetCurrentChar().SetPetGlyphInfo(vecEquippedGlyph);
        g_MyD3D->m_TempPlayer.GetCurrentChar().SetPetGlyphInfo(g_kGlobalValue.m_kUserInfo.GetCurrentChar().vecPetGlyphInfo);

        if (g_MyD3D->m_pStateMachine->GetState() == GS_MY_INFO_FROM_ROOM)
        {
            auto pPlayer = g_MyD3D->GetMyPlayer();
            if (pPlayer != nullptr)
            {
                pPlayer->GetCurrentChar().SetPetGlyphInfo(g_kGlobalValue.m_kUserInfo.GetCurrentChar().vecPetGlyphInfo);
            }
        }

        g_pkUIScene->m_pkMyInfoScene->UpdateGameData();

        g_pkUIScene->m_pkPetMagicStoneDlg->UpdatePetGlyphData(kRecv.m_vecEquippedGlyphs.size() == KGCPetMagicStoneDlg::MAX_STONE_TYPE);

    }
}

void On_EVENT_PET_MAGIC_STONE_CHANGE_EQUIP_NOT(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_PET_MAGIC_STONE_CHANGE_EQUIP_NOT);
    SAFE_DELETE(pkBuff);
}

void On_EVENT_LOOK_INVENTORY_EXTEND_INFO_NOT(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE(KEVENT_LOOK_INVENTORY_EXTEND_INFO_NOT);
    SAFE_DELETE(pkBuff);
    g_pItemMgr->SetLookExtendItemInfo(kRecv);
}

void On_EVENT_USE_HERO_TICKET_ACK(WPARAM wParam, LPARAM lParam)
{
    KSerializer ks;
    ACK_DESERIALIZE( KEVENT_USE_HERO_TICKET_ACK );
    SAFE_DELETE( pkBuff );
    Result_ReceiveUseHeroTicketReq = kRecv.iOK;
    switch ( kRecv.iOK )
    {
        case 0:
        {
            DWORD ItemUID = static_cast<DWORD>( kRecv.m_dwItemUID );
            KItem* tempItem = g_pItemMgr->m_kInventory.FindItemByItemUID( ItemUID );
            DWORD ItemID = static_cast<DWORD>( tempItem->m_ItemID );
            tempItem->m_nCount -= 1;
            if ( g_pItemMgr->m_kInventory.FindItemByItemUID( ItemUID )->m_nCount <= 0 )
                g_pItemMgr->m_kInventory.RemoveItem( ItemID, ItemUID );
            g_kGlobalValue.m_kHeroDungeonInfo.SetHeroDungeonPlayTicket( static_cast<int>( SiKGCWorldMapManager()->GetGameMode() ) );
            SiKGCRoomManager()->UpdateRoomUI();
            g_pkUIScene->m_pkRoomSceneS6->Update();
            g_pkUIScene->m_pkRoomSceneS6->m_pkTicketPanel->UpdateDialog();
            g_pkUIScene->m_pkRoomSceneS6->HeroTicketPanelManager( true );
            break;
        }
        default:
        {
            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_HERO_TICKET_SYSTEM_ERROR ), L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, false, true, true );
            break;
        }
    }
}

void On_ENU_ACCOUNT_REGISTER_ACK( WPARAM wParam, LPARAM lParam )
{
    KSerializer ks;
    ACK_DESERIALIZE( KENU_ACCOUNT_REGISTER_ACK );
    Result_Register_User = kRecv.m_nOK;
    if ( Result_Register_User == 0 )
    {
        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_OK, g_pkStrLoader->GetString( STR_ID_REGISTER_TEXT_01 ), L"", KGCUIScene::GC_MBOX_USE_NORMAL );
        g_kGlobalValue.m_bAlreadyRegistered = true;
    }
    SAFE_DELETE(pkBuff);
}

bool Process_Server_Msg(UINT uMsg, WPARAM wParam, LPARAM lParam)            //서버에서 온 메세지를 처리합니다
{
    if ( g_kGlobalValue.m_bIsOnGameClose )
        return false;

    if( uMsg == WM_APP + KP2P::USERPROXY_ID )    // 게임서버 메세지
    {
#define EVENT_TYPE KUserEvent
        switch(wParam)
        {
            SERVER_MSG( EVENT_USE_DURATION_ITEM_ACK )
            SERVER_MSG( EVENT_VERIFY_ACCOUNT_ACK )
            SERVER_MSG( EVENT_ITEM_EXPIRED_NOT )
            SERVER_MSG( EVENT_GIFT_ITEM_NOT )
            SERVER_MSG( EVENT_UDP_PORT_NOT )
            SERVER_MSG( EVENT_REGISTER_NICKNAME_ACK )
            SERVER_MSG( EVENT_RECOMMENDER_ACK )
            SERVER_MSG( EVENT_HOST_MIGRATED_NOT )
            SERVER_MSG( EVENT_INFORM_USER_LEAVE_ROOM_NOT )
            SERVER_MSG( EVENT_QUERY_INVENTORY_INFO_ACK )
            SERVER_MSG( EVENT_SELL_ITEM_ACK )
            SERVER_MSG( EVENT_START_GAME_ACK )
            SERVER_MSG( EVENT_CHANNEL_LIST_ACK )
            SERVER_MSG( EVENT_ENTER_CHANNEL_ACK )
            SERVER_MSG( EVENT_GUILD_EDIT_NOTICE_ACK )
            SERVER_MSG( EVENT_CHANGE_ROOM_INFO_BROAD )
            SERVER_MSG( EVENT_INVITE_NOT )
            SERVER_MSG( EVENT_CREATE_ROOM_ACK )
            SERVER_MSG( EVENT_LEAVE_ROOM_ACK )
            SERVER_MSG( EVENT_USER_LIST_ACK )
            SERVER_MSG( EVENT_ROOM_LIST_ACK )
            SERVER_MSG( EVENT_CHAT_NOT )
            SERVER_MSG( EVENT_WHISPER_ACK )
            SERVER_MSG( EVENT_BUY_FOR_GP_ACK )
            SERVER_MSG( EVENT_BUY_FOR_GEM_ACK)
            SERVER_MSG( EVENT_BUY_FOR_CRYSTAL_ACK )
            SERVER_MSG( EVENT_STRONG_LEVELUP_ACK )
            SERVER_MSG( EVENT_KICK_USER_BY_ADMIN_ACK )
            SERVER_MSG( EVENT_CHANGE_USER_INFO_ACK )
            SERVER_MSG( EVENT_CLOSE_CONNECTION_NOT )
            SERVER_MSG( EVENT_RP_CHANGED_NOT )
            SERVER_MSG( EVENT_DETAIL_USER_INFO_ACK )
            SERVER_MSG( EVENT_USE_CHANGE_NICKNAME_ACK )
            SERVER_MSG( EVENT_USE_CHANGE_NICKCOLOR_ACK )
            SERVER_MSG( EVENT_REGIST_MISSION_ACK )
            SERVER_MSG( EVENT_COMPLETE_MISSION_ACK )
            SERVER_MSG( EVENT_REMOVE_MISSION_ACK )
            SERVER_MSG( EVENT_LEAVE_GAME_ACK )
            SERVER_MSG( EVENT_BUY_FOR_CASH_ACK )
            SERVER_MSG( EVENT_CURRENT_CASH_POINT_ACK )
            SERVER_MSG( EVENT_ENCHANT_GEMCOUNT_ACK )
            SERVER_MSG( EVENT_SERVER_LIST_ACK )
            SERVER_MSG( EVENT_CHANGE_ROOMUSER_INFO_BROAD )
            SERVER_MSG( EVENT_EQUIP_ITEM_ACK )
            SERVER_MSG( EVENT_EQUIP_ITEM_BROAD )
            SERVER_MSG( EVENT_START_GAME_BROAD )
            SERVER_MSG( EVENT_JOIN_ROOM_BROAD )
            SERVER_MSG( EVENT_CHANGE_INDOOR_USERINFO_BROAD );
            SERVER_MSG( EVENT_SHANGHAI_DROP_ACK )
            SERVER_MSG( EVENT_KAIRO_ACK )
            SERVER_MSG( EVENT_KAIRO_ONESHOT_ACK )
            SERVER_MSG( EVENT_ACCUMULRATION_TIME_NOT)
            SERVER_MSG( EVENT_SET_CURRENT_CHARACTER_ACK )
            SERVER_MSG( EVENT_CREATE_PET_ACK )
            SERVER_MSG( EVENT_DELETE_PET_ACK )
            SERVER_MSG( EVENT_FEEDING_PET_ACK )
            SERVER_MSG( EVENT_CHANGE_PET_NAME_ACK )
            SERVER_MSG( EVENT_PRE_COMPLETE_ACK )
            SERVER_MSG( EVENT_USE_INVENTORY_EXTEND_ACK )
            SERVER_MSG( EVENT_VERIFY_INVENTORY_NOT )
            SERVER_MSG( EVENT_REPETITION_PROVIDE_NOT )
            SERVER_MSG( EVENT_FORCE_CHANGE_ROOMUSER_INFO_ACK )
            SERVER_MSG( EVENT_FORCE_CHANGE_ROOMUSER_INFO_BROAD )
            SERVER_MSG( EVENT_CHECK_TRANSFORMATION_PET_ACK )
            SERVER_MSG( EVENT_TRANSFORMATION_PET_ACK )
            SERVER_MSG( EVENT_LOAD_POINTSYSTEM_INFO_ACK )
            SERVER_MSG( EVENT_GET_CURRENT_POINT_ACK )
            SERVER_MSG( EVENT_SEALLING_CALENDAR_ACK )
            SERVER_MSG( EVENT_ACC_TIME_NOT )
            SERVER_MSG( EVENT_WEEKLY_ATTEND_ACK )
            SERVER_MSG( EVENT_LOAD_NEW_CALENDAR_NOT )
            SERVER_MSG( EVENT_MONTHLY_ATTEND_REWARD_ACK )
            SERVER_MSG( EVENT_MONTHLY_ATTEND_REWARD_LIST_NOT )
            SERVER_MSG( EVENT_GET_CALENDAR_ACK )
            SERVER_MSG( EVENT_FORCE_TRANSITION_STATE_ACK )
            SERVER_MSG( EVENT_HATCHING_EGG_ACK )
            SERVER_MSG( EVENT_BUY_GCPOINT_ITEM_ACK )
            SERVER_MSG( EVENT_SELL_GCPOINT_ITEM_ACK )
            SERVER_MSG( EVENT_MONTHLY_REWARD_LIST_NOT )
            SERVER_MSG( EVENT_WEEKLY_REWARD_LIST_NOT )
            SERVER_MSG( EVENT_FH_CHECK_ACCOUNT_TYPE_ACK )
            SERVER_MSG( EVENT_GCPOINT_RECOMMEND_ACK )
            SERVER_MSG( EVENT_FH_RECOMMEND_REGIST_ACK )
            SERVER_MSG( EVENT_FH_RECOMMENDEE_INFO_ACK )
            SERVER_MSG( EVENT_MONTHLY_ATTEND_NOT )
            SERVER_MSG( EVENT_RESET_WIN_LOSE_ACK )
            SERVER_MSG( EVENT_CHANGE_ROOM_OPTION_ACK )
            SERVER_MSG( EVENT_CHANGE_ROOM_OPTION_BROAD )
            SERVER_MSG( EVENT_LUCKYDAY_NOT )
            SERVER_MSG( EVENT_WRONG_STATE_NOT )
            SERVER_MSG( EVENT_YAHOO_BENEFIT_NOT )
            SERVER_MSG( EVENT_MSG_NOT )
            SERVER_MSG( EVENT_GET_NASTY_INFO_NOT )
            SERVER_MSG( EVENT_REPORT_USER_ACK )
            SERVER_MSG( EVENT_REPORT_USER_NOT )
            SERVER_MSG( EVENT_CHATTING_EVENT_MSG_NOT )
            SERVER_MSG( EVENT_BONUS_POINT_REFILL_NOT )
            SERVER_MSG( EVENT_CHANGE_BONUS_COIN_ACK )
            SERVER_MSG( EVENT_USE_BONUS_POINT_ACK )
            SERVER_MSG( EVENT_SLOT_INFO_NOT )
            SERVER_MSG( EVENT_CHANGE_SLOT_EQUIP_ACK )
            SERVER_MSG( EVENT_USE_QUICK_SLOT_ACK )
            SERVER_MSG( EVENT_QUICKSLOT_UPDATE_NOT )
            SERVER_MSG( EVENT_PREMIUM_NOT )
            SERVER_MSG( EVENT_INDIGO_RANK_NOT )
            SERVER_MSG( EVENT_SQUARE_LIST_ACK )
            SERVER_MSG( EVENT_ENTER_SQUARE_ACK )
            SERVER_MSG( EVENT_SQUARE_LOADING_COMPLETE_ACK )
            SERVER_MSG( EVENT_NEW_SQUARE_USER_NOT )
            SERVER_MSG( EVENT_LEAVE_SQUARE_USER_NOT )
            SERVER_MSG( EVENT_LEAVE_SQUARE_ACK )
            SERVER_MSG( EVENT_SQUARE_CHAT_NOT )
            SERVER_MSG( EVENT_SQUARE_CHAT_ACK )
            SERVER_MSG( EVENT_UPDATE_SQUARE_USER_NOT )
            SERVER_MSG( EVENT_SQUARE_USER_SYNC_ACK )
            SERVER_MSG( EVENT_NEW_CHARACTER_ACK )
            SERVER_MSG( EVENT_USE_EMOTICON_NOT )
            SERVER_MSG( EVENT_USE_EMOTICON_ACK )
            SERVER_MSG( EVENT_EMOTICON_MIX_ACK )
            SERVER_MSG( EVENT_TW_USER_AGREEMENT_NOT )
            SERVER_MSG( EVENT_TW_USER_AGREEMENT_ACK )
            SERVER_MSG( EVENT_CHANGE_OBSERVER_ACK )
            SERVER_MSG( EVENT_INVITED_ROOM_FROM_SQUARE_ACK )
            SERVER_MSG( EVENT_SQUARE_USER_LIST_ACK )
            SERVER_MSG( EVENT_SIGN_BOARD_NUM_ACK )
            SERVER_MSG( EVENT_SIGN_BOARD_REG_ACK )
            SERVER_MSG( EVENT_SIGN_BOARD_NOT )
            SERVER_MSG( EVENT_CONNECTION_MSG_ACK )
            SERVER_MSG( EVENT_BAD_USER_INFO_NOT )
            SERVER_MSG( EVENT_BAD_USER_INFO_CHANGE_BROAD )
            SERVER_MSG( EVENT_RANK_PAGE_ACK )
            SERVER_MSG( EVENT_MY_RANK_INFO_NOT )
            SERVER_MSG( EVENT_RANK_SEARCH_ACK )
            SERVER_MSG( EVENT_INVITE_FAIL_NOT )
            SERVER_MSG( EVENT_GET_HELL_ITEM_ACK )
            SERVER_MSG( EVENT_SELL_INFO_ACK )
            SERVER_MSG( EVENT_SELL_COUNT_ITEM_ACK )
            SERVER_MSG( EVENT_BUY_VIRTUAL_CASH_ACK )
            SERVER_MSG( EVENT_CURRENT_VIRTUAL_CASH_NOT )
            SERVER_MSG( EVENT_COLLECTION_MISSION_NOT )
            SERVER_MSG( EVENT_COLLECTION_COMPLETE_ACK )
            SERVER_MSG( EVENT_JOIN_GAME_ACK )
            SERVER_MSG( EVENT_JOIN_GAME_BROAD )
            SERVER_MSG( EVENT_END_GAME_NOT )
            SERVER_MSG( EVENT_P2P_UNIQUE_NUM_BROAD )
            SERVER_MSG( EVENT_RELAY_DATA )
            SERVER_MSG( EVENT_MINIGAME_INFO_NOT )
            SERVER_MSG( EVENT_START_MINIGAME_ACK )
            SERVER_MSG( EVENT_END_MINIGAME_ACK )
            SERVER_MSG( EVENT_EXIT_MINIGAME_ACK )
            SERVER_MSG( EVENT_MINIGAME_RESTART_ACK )
            SERVER_MSG( EVENT_MINIGAME_TOPRANK_ACK )
            SERVER_MSG( EVENT_MINIGAME_MY_RANK_INFO_ACK )
            SERVER_MSG( EVENT_SERVER_TIME_NOT )
            SERVER_MSG( EVENT_GET_FULL_SP_INFO_ACK )
            SERVER_MSG( EVENT_SKILL_TRAINING_ACK )
            SERVER_MSG( EVENT_SET_SKILL_ACK )
            SERVER_MSG( EVENT_SET_SKILL_BROAD )
            SERVER_MSG( EVENT_REMOVE_SKILL_ACK )
            SERVER_MSG( EVENT_UNLOCK_SKILL_ACK )
            SERVER_MSG( EVENT_CHANGE_COUPON_ACK )
            SERVER_MSG( EVENT_GACHA_REWARD_LIST_ACK )
            SERVER_MSG( EVENT_GACHA_ACTION_ACK )
            SERVER_MSG( EVENT_GACHA_OBTAINED_SET_REWARD_ACK )
            SERVER_MSG( EVENT_GACHA_LEVEL_OBTAINED_SET_REWARD_ACK )
            SERVER_MSG( EVENT_GACHA_SET_REWARD_ACK )
            SERVER_MSG( EVENT_GACHA_LEVEL_SET_REWARD_ACK )
            SERVER_MSG( EVENT_GACHA_SET_REWARD_LIST_ACK )
            SERVER_MSG( EVENT_RESET_POSITION_NOT )
            SERVER_MSG( EVENT_FINISH_EVENT_NOT )
            SERVER_MSG( EVENT_TIME_EVENT_NOT )
            SERVER_MSG( EVENT_GACHA_KEY_BUY_COUNT_NOT )
            SERVER_MSG( EVENT_MISSIONSLOT_NOT )
            SERVER_MSG( EVENT_PERIOD_NOTICE_NOT )
            SERVER_MSG( EVENT_FULL_COUPLE_INFO_NOT )
            SERVER_MSG( EVENT_MAKE_COUPLE_ACK )
            SERVER_MSG( EVENT_MAKE_COUPLE_ASK )
            SERVER_MSG( EVENT_USE_COUPLE_ITEM_ACK )
            SERVER_MSG( EVENT_USE_COUPLE_ITEM_NOT )
            SERVER_MSG( EVENT_EQUIP_COUPLE_ITEM_ACK )
            SERVER_MSG( EVENT_EQUIP_COUPLE_ITEM_NOT )
            SERVER_MSG( EVENT_COUPLE_INFORMATION_ACK )
            SERVER_MSG( EVENT_CHANGE_COUPLE_RING_ACK )
            SERVER_MSG( EVENT_CHANGE_COUPLE_RING_ASK )
            SERVER_MSG( EVENT_MAKE_COUPLE_NOT )
            SERVER_MSG( EVENT_DIVORCE_COUPLE_ACK )
            SERVER_MSG( EVENT_DIVORCE_COUPLE_NOT )
            SERVER_MSG( EVENT_DIVORCE_COUPLE_OTHER_NOT )
            SERVER_MSG( EVENT_CHANGE_COUPLE_CHAR_ACK )
            SERVER_MSG( EVENT_CHANGE_COUPLE_CHAR_NOT )
            SERVER_MSG( EVENT_COUPLEITEM_EXPIRED_NOT )
            SERVER_MSG( EVENT_COUPLE_CHAT_ACK )
            SERVER_MSG( EVENT_COUPLE_CHAT_NOT )
            SERVER_MSG( EVENT_COUPLE_WINDOW_STATE_NOT )
            SERVER_MSG( EVENT_PET_COSTUM_LIST_ACK )
            SERVER_MSG( EVENT_GET_USER_DONATION_INFO_ACK )
            SERVER_MSG( EVENT_DONATION_INFO_ACK )
            SERVER_MSG( EVENT_DONATION_POINT_ACK )
            SERVER_MSG( EVENT_ADD_EXP_ACK )
            SERVER_MSG( EVENT_VIP_ITEM_LIST_NOT )
            SERVER_MSG( EVENT_BUY_FOR_VIP_ACK )
            SERVER_MSG( EVENT_LUNA_NEWYEAR_ACK )
            SERVER_MSG( EVENT_CHECK_RECOMMEND_ENABLE_ACK )
            SERVER_MSG( EVENT_RECOMMEND_USER_ACK )
            SERVER_MSG( EVENT_RECOMMEND_FULL_INFO_ACK )
            SERVER_MSG( EVENT_RECOMMENDER_ACCEPT_ACK )
            SERVER_MSG( EVENT_ATTENDANCE_BONUS_ACK )
            SERVER_MSG( EVENT_RECOM_DAILY_ATTENDANCE_ACK )
            SERVER_MSG( EVENT_RECOM_CHANGE_STATE_NOT )
            SERVER_MSG( EVENT_CAPSULE_LIST_NOT )
            SERVER_MSG( EVENT_OPEN_CAPSULE_ACK )
            SERVER_MSG( EVENT_CAPSULE_RESULT_NOT )
            SERVER_MSG( EVENT_GAME_COUPON_LIST_ACK )
            SERVER_MSG( EVENT_USE_GAME_COUPON_ACK )
            SERVER_MSG( EVENT_WEB_GACHA_COIN_TRADE_ACK )
            SERVER_MSG( EVENT_SET_EXP_ACK )
            SERVER_MSG( EVENT_GET_GCCLUB_CONNECT_BONUS_ACK )
            SERVER_MSG( EVENT_GET_GCCLUB_ATTEND_BONUS_ACK )
            SERVER_MSG( EVENT_CHANGE_VIRTUAL_CASH_COUPON_ACK)
            SERVER_MSG( EVENT_DUNGEON_HACKING_USER_NOT )
            SERVER_MSG( EVENT_MISSION_PACK_LIST_NOT )
            SERVER_MSG( EVENT_MISSION_PACK_REGIST_ACK )
            SERVER_MSG( EVENT_HELL_TICKET_FREE_MODE_NOT )
            SERVER_MSG( EVENT_INVITE_FRIEND_LIST_ACK )
            SERVER_MSG( EVENT_JOIN_ROOM_OTHER_CHANNEL_ACK )
            SERVER_MSG( EVENT_CO_OP_EVENT_NOT )
            SERVER_MSG( EVENT_CO_OP_ITEM_BUY_ACK )
            SERVER_MSG( EVENT_NPC_GIFTS_NOT )
            SERVER_MSG( EVENT_NPC_GIFTS_ACK )
            SERVER_MSG( EVENT_SUBSCRIPTION_INFO_NOT )
            SERVER_MSG( EVENT_CURRENT_SUBSCRIPTION_GIFT_NUM_ACK )
            SERVER_MSG( EVENT_SUBSCRIPT_ACK )
            SERVER_MSG( EVENT_CHAT_EVENT_ENABLE_NOT)
            SERVER_MSG( EVENT_GACHA_COIN_COUNT_ACK )
            SERVER_MSG( EVENT_RAINBOW_EVENT_NOT )
            SERVER_MSG( EVENT_RAINBOW_JACKPOT_ITEM_ACK )
            SERVER_MSG( EVENT_MISSION_DATE_CHANGE_NOT )
            SERVER_MSG( EVENT_MISSION_DATE_CHANGE_ACK )
            SERVER_MSG( EVENT_ITEM_TRADE_LIST_NOT )
            SERVER_MSG( EVENT_ITEM_TRADE_ACK )
            SERVER_MSG( EVENT_CHARACTER_STAT_INFO_ACK )
            SERVER_MSG( EVENT_BOARD_GAME_INFO_NOT )
            SERVER_MSG( EVENT_BOARD_GAME_INFO_ACK )
            SERVER_MSG( EVENT_DICE_PLAY_ACK )
            SERVER_MSG( EVENT_DICE_ITEM_TRADE_ACK )
            SERVER_MSG( EVENT_DICE_ITME_BUY_CHECK_ACK )
            SERVER_MSG( EVENT_VIRTUAL_CASH_LIMIT_RATIO_NOT )
            SERVER_MSG( EVENT_TRAFFIC_USER_NOT )
            SERVER_MSG( EVENT_RECOMMEND_LEVELUP_NOT )
            SERVER_MSG( EVENT_CENTER_ROOM_LIST_ACK )
            SERVER_MSG( EVENT_GUILD_LIST_NOT )
            SERVER_MSG( EVENT_JOIN_GUILD_ACK )
            SERVER_MSG( EVENT_CANCEL_JOIN_GUILD_ACK )
            SERVER_MSG( EVENT_CREATE_GUILD_ACK )
            SERVER_MSG( EVENT_EDIT_GUILD_NOTICE_ACK )
            SERVER_MSG( EVENT_EDIT_GUILD_NAME_ACK )
            SERVER_MSG( EVENT_CHANGE_GUILD_JOIN_SETTING_ACK )
            SERVER_MSG( EVENT_EDIT_GUILD_URL_ACK )
            SERVER_MSG( EVENT_BREAKUP_GUILD_ACK )
            SERVER_MSG( EVENT_UPDATE_GUILD_STATE_NOT )
            SERVER_MSG( EVENT_CHANGE_GUILD_MEMBER_LEVEL_ACK )
            SERVER_MSG( EVENT_SELF_DRUMOUT_GUILD_ACK )
            SERVER_MSG( EVENT_ACCEPT_GUILD_JOINER_ACK )
            SERVER_MSG( EVENT_REJECT_GUILD_JOINER_ACK )
            SERVER_MSG( EVENT_EDIT_GUILD_MY_COMMENT_ACK )
            SERVER_MSG( EVENT_EDIT_GUILD_NAME_NOT )
            SERVER_MSG( EVENT_UPDATE_GUILD_URL_NOT )
            SERVER_MSG( EVENT_MARK_UPLOAD_ACK )
            SERVER_MSG( EVENT_GUILD_MARK_STATUS_NOT )
            SERVER_MSG( EVENT_GUILD_RANK_ACK )
            SERVER_MSG( EVENT_GUILD_NOTICE_LIST_ACK )
            SERVER_MSG( EVENT_CHANGE_GUILD_MEMBER_LEVEL_NOT )
            SERVER_MSG( EVENT_ADD_GUILD_USER_NOT )
            SERVER_MSG( EVENT_DEL_GUILD_USER_NOT )
            SERVER_MSG( EVENT_GUILD_DRUMOUT_USER_NOT )
            SERVER_MSG( EVENT_UPGRADE_GUILD_GRADE_GIFT_NOT )
            SERVER_MSG( EVENT_GUILD_TOTAL_POINT_ACK )
            SERVER_MSG( EVENT_GUILD_MEMBER_LIST_ACK )
            SERVER_MSG( EVENT_USER_BINGO_DATA_ACK )
            SERVER_MSG( EVENT_CHANGE_BINGO_COIN_ACK )
            SERVER_MSG( EVENT_BINGO_QUESTION_ACK )
            SERVER_MSG( EVENT_BINGO_ANSWER_ACK )
            SERVER_MSG( EVENT_BINGO_COIN_CHARGE_NOT )
            SERVER_MSG( EVENT_NEW_YEAR_DONATION_NOT )
            SERVER_MSG( EVENT_NEW_YEAR_DONATION_INFO_ACK )
            SERVER_MSG( EVENT_NEW_YEAR_DONATION_ACK )
            SERVER_MSG( EVENT_ATTRIBUTE_LIST_ACK );
            SERVER_MSG( EVENT_ATTRIBUTE_SELECT_ACK );
            SERVER_MSG( EVENT_SOCKET_OPEN_ACK );
            SERVER_MSG( EVENT_MONSTER_CARD_INSERT_ACK );
            SERVER_MSG( EVENT_MONSTER_CARD_REMOVE_ACK );
            SERVER_MSG( EVENT_ITEM_BREAKUP_ACK );
            SERVER_MSG( EVENT_TIME_DROP_NOT );
            SERVER_MSG( EVENT_GET_WEB_CASH_ITEM_ACK );
            SERVER_MSG( EVENT_MANUFACTURES3_CATALOG_ACK );
            SERVER_MSG( EVENT_MANUFACTURES3_MATERIAL_ACK );
            SERVER_MSG( EVENT_MANUFACTURES3_ACK );
            SERVER_MSG( EVENT_ITEM_BREAKUP_PRICE_RATIO_ACK );
            SERVER_MSG( EVENT_PRESENTBOX_INFO_ACK )
            SERVER_MSG( EVENT_PRESENTBOX_TRADE_ACK )
            SERVER_MSG( EVENT_PRESENTBOX_ACTION_ACK )
            SERVER_MSG( EVENT_STRING_INFO_NOT )
            SERVER_MSG( EVENT_ITEM_BUY_CHECK_ACK )
            SERVER_MSG( EVENT_DUNGEON_STATE_ACK )
            SERVER_MSG( EVENT_GET_ROOMUSER_PRESS_STATE_ACK )
            SERVER_MSG( EVENT_PRESS_STATE_NOT )
            SERVER_MSG( EVENT_PRESSURE_USER_NOT )
            SERVER_MSG( EVENT_GET_ROOMUSER_IDLE_STATE_ACK )
            SERVER_MSG( EVENT_IDLE_STATE_NOT )
            SERVER_MSG( EVENT_ROOM_MEMBER_PING_INFO_ACK )
            SERVER_MSG( EVENT_LOW_PING_NOT )
            SERVER_MSG( EVENT_LOAD_COMPLETE_BROAD )
            SERVER_MSG( EVENT_LOADING_TIME_OVER_NOT )
            SERVER_MSG( EVENT_RELAY_LOADING_STATE )
            SERVER_MSG( EVENT_CHANGE_NORMAL_TO_LOOK_ACK )
            SERVER_MSG( EVENT_CHANGE_LOOK_TO_NORMAL_ACK )
            SERVER_MSG( EVENT_SAVE_COORDI_ACK )
            SERVER_MSG( EVENT_CHANGE_LOOK_EQUIP_NOT )
            SERVER_MSG( EVENT_CHANGE_LOOK_EQUIP_ACK )
            SERVER_MSG( EVENT_FULL_LOOK_INFO_NOT )
            SERVER_MSG( EVENT_BUNDLE_SELL_ITEM_ACK );
            SERVER_MSG( EVENT_BUY_FOR_GAMBLE_ACK )
            SERVER_MSG( EVENT_COST_RATE_FOR_GAMBLE_BUY_ACK )
            SERVER_MSG( EVENT_TR_SERVER_INFO_ACK )
            SERVER_MSG( EVENT_HERO_DUNGEON_INFO_NOT )
            SERVER_MSG( EVENT_USER_HERO_DUNGEON_INFO_ACK )
            SERVER_MSG( EVENT_HERO_ITEM_CATALOG_ACK )
            SERVER_MSG( EVENT_HERO_ITEM_MATERIAL_ACK )
            SERVER_MSG( EVENT_BUY_FOR_HERO_ACK )
            SERVER_MSG( EVENT_HERO_DUNGEON_ALARM_NOT )
            SERVER_MSG( EVENT_CHANNELING_REWARD_NOT )
            SERVER_MSG( EVENT_CHAR_PROMOTION_UPDATE_ACK )
            SERVER_MSG( EVENT_ITEM_CHARPROMOTION_LEVEL_NOT )
            SERVER_MSG( EVENT_HERO_DUNGEON_RESET_NOT )
            SERVER_MSG( EVENT_END_GAME_BROAD )
            SERVER_MSG( EVENT_SPECIAL_REWARD_BROAD )
            SERVER_MSG( EVENT_GAWIBAWIBO_INFO_ACK )
            SERVER_MSG( EVENT_GAWIBAWIBO_ACK )
            SERVER_MSG( EVENT_GAWIBAWIBO_GIVE_UP_ACK )
            SERVER_MSG( EVENT_GAWIBAWIBO_TRYPOINT_INFO_ACK )
            SERVER_MSG( EVENT_GAWIBAWIBO_ITEM_TRADE_ACK )
            SERVER_MSG( EVENT_DUNGEON_REWARD_ITEM_ACK )
            SERVER_MSG( EVENT_DUNGEON_REWARD_EXP_ACK )
            SERVER_MSG( EVENT_PVP_REWARD_EXP_GP_ACK )
            SERVER_MSG( EVENT_PVP_TAG_REWARD_EXP_GP_ACK )
            SERVER_MSG( EVENT_STAGE_LOAD_COMPLETE_BROAD )
            SERVER_MSG( EVENT_NONE_INVEN_ITEM_LIST_NOT )
            SERVER_MSG( EVENT_SOCKS_INFO_NOT )
            SERVER_MSG( EVENT_SOCKS_INFO_ACK)
            SERVER_MSG( EVENT_SOCKS_HANGUP_ACK )
            SERVER_MSG( EVENT_SOCKS_COLLECT_ACK )
            SERVER_MSG( EVENT_SOCKS_MATERIAL_EXCHANGE_NOT )
            SERVER_MSG( EVENT_SOCKS_HANGUP_COMPLETE_NOT )
            SERVER_MSG( EVENT_SOCKS_MATERIAL_EXCHANGE_ACK )
            SERVER_MSG( EVENT_INIT_ITEM_ATTRIBUTE_ACK )
            SERVER_MSG( EVENT_INIT_ITEM_GP_ATTRIBUTE_ACK )
            SERVER_MSG( EVENT_GP_ATTRIBUTE_INIT_ITEM_LIST )
            SERVER_MSG( EVENT_GP_ATTRIBUTE_RANDOM_ITEM_LIST )
            SERVER_MSG( EVENT_USER_STAGE_LOAD_COMPLETE_NOT )
            SERVER_MSG( EVENT_UNLOCK_CHANGE_WEAPON_ACK )
            SERVER_MSG( EVENT_ITEM_LEVEL_LIST_ACK )
            SERVER_MSG( EVENT_ITEM_LEVEL_SELECT_ACK )
            SERVER_MSG( EVENT_ITEM_ATTRIBUTE_RANDOM_SELECT_LIST )
            SERVER_MSG( EVENT_ITEM_ATTRIBUTE_RANDOM_SELECT_ACK )
            SERVER_MSG( EVENT_GP_ATTRIBUTE_RANDOM_ACK )
            SERVER_MSG( EVENT_GAWIBAWIBO_TRY_POINT_NOT )
            SERVER_MSG( EVENT_USER_SERVER_ROOM_ACK )
            SERVER_MSG( EVENT_TODAYS_POPUP_INFO_ACK )
            SERVER_MSG( EVENT_INIT_TODAYS_POPUP_NOT )
            SERVER_MSG( EVENT_RESET_SKILL_ACK )
            SERVER_MSG( EVENT_FASHION_CATALOG_ACK )
            SERVER_MSG( EVENT_USER_RECOM_TYPE_ACK )
            SERVER_MSG( EVENT_PLANT_TREE_MAP_NOT )
            SERVER_MSG( EVENT_PLANT_TREE_INFO_ACK )
            SERVER_MSG( EVENT_PLANT_TREE_ACTION_ACK )
            SERVER_MSG( EVENT_PLANT_TREE_REWARD_ACK )
            SERVER_MSG( EVENT_CHOICE_BOX_LIST_ACK )
            SERVER_MSG( EVENT_CHOICE_BOX_INFO_ACK )
            SERVER_MSG( EVENT_CHOICE_BOX_OPEN_ACK )
            SERVER_MSG( EVENT_VIPEVENT_LIST_ACK )
            SERVER_MSG( EVENT_VIPEVENT_USER_INFO_ACK )
            SERVER_MSG( EVENT_VIPEVENT_USER_REWARD_UPDATE_NOT )
            SERVER_MSG( EVENT_MAGIC_BOX_LIST_ACK )
            SERVER_MSG( EVENT_SET_MAGIC_BOX_TARGET_ACK )
            SERVER_MSG( EVENT_USE_MAGIC_BOX_ACK )
            SERVER_MSG( EVENT_MAX_CHAR_SP_LEVEL_NOT )
            SERVER_MSG( EVENT_USER_AUTH_CHECK_ACK )
            SERVER_MSG( EVENT_PACKAGE_INFO_ACK )
            SERVER_MSG( EVENT_PACKAGE_INFO_DETAIL_ACK )
            SERVER_MSG( EVENT_ITEM_ATTRIBUTE_TABLE_ID_ACK )
            SERVER_MSG( EVENT_GUILD_STORE_CATALOG_ACK )
            SERVER_MSG( EVENT_BUY_FOR_GUILD_ACK )
            SERVER_MSG( EVENT_GUILD_LEVEL_TABLE_NOT )
            SERVER_MSG( EVENT_GUILD_ROOM_INFO_CHANGE_NOT )
            SERVER_MSG( EVENT_GET_GUILD_POINT_NOTICE )
            SERVER_MSG( EVENT_RKTORNADO_ITEM_LIST_NOT )
            SERVER_MSG( EVENT_RKTORNADO_ACTION_ACK )
            SERVER_MSG( EVENT_OPEN_CALENDAR_BONUS_POINT_ACK )
            SERVER_MSG( EVENT_SPHINX_ITEM_LIST_NOT )
            SERVER_MSG( EVENT_USER_SPHINX_DATA_ACK )
            SERVER_MSG( EVENT_SPHINX_QUESTION_ACK )
            SERVER_MSG( EVENT_SPHINX_ANSWER_ACK )
            SERVER_MSG( EVENT_CREATE_PARTY_ACK )
            SERVER_MSG( EVENT_CREATE_PARTY_ASK )
            SERVER_MSG( EVENT_INVITE_PARTY_ROOM_BROAD )
            SERVER_MSG( EVENT_INVITE_PARTY_ASK )
            SERVER_MSG( EVENT_INVITE_PARTY_BROAD )
            SERVER_MSG( EVENT_LEAVE_PARTY_USER_ACK )
            SERVER_MSG( EVENT_BREAK_PARTY_NOT )
            SERVER_MSG( EVENT_BAN_PARTY_USER_NOT )
            SERVER_MSG( EVENT_CHANGE_PARTY_HOST_BROAD )
            SERVER_MSG( EVENT_LEAVE_PARTY_BROAD )
            SERVER_MSG( EVENT_ENTER_AGIT_ACK )
            SERVER_MSG( EVENT_ENTER_AGIT_BROAD )
            SERVER_MSG( EVENT_AGIT_LOADING_COMPLETE_ACK )
            SERVER_MSG( EVENT_LEAVE_AGIT_ACK )
            SERVER_MSG( EVENT_LEAVE_AGIT_BROAD )
            SERVER_MSG( EVENT_AGIT_MAP_CATALOGUE_ACK )
            SERVER_MSG( EVENT_BUY_AGIT_MAP_ACK )
            SERVER_MSG( EVENT_CHANGE_AGIT_MAP_BROAD )
            SERVER_MSG( EVENT_SET_AGIT_OPTION_ACK )
            SERVER_MSG( EVENT_AGIT_STORE_CATALOG_ACK )
            SERVER_MSG( EVENT_AGIT_STORE_MATERIAL_ACK )
            SERVER_MSG( EVENT_BUY_FOR_AGIT_ACK )
            SERVER_MSG( EVENT_SELL_FOR_AGIT_ACK )
            SERVER_MSG( EVENT_SEED_FLOWER_POT_ACK )
            SERVER_MSG( EVENT_CHANGE_FLOWER_POT_STATE_BROAD )
            SERVER_MSG( EVENT_HARVEST_FLOWER_POT_ACK )
            SERVER_MSG( EVENT_AGIT_STAY_BONUS_DROP_NOT )
            SERVER_MSG( EVENT_AGIT_CHAT_ACK )
            SERVER_MSG( EVENT_AGIT_CHAT_BROAD )
            SERVER_MSG( EVENT_AGIT_BAN_USER_ACK )
            SERVER_MSG( EVENT_AGIT_BAN_USER_NOT )
            SERVER_MSG( EVENT_SET_AGIT_OBJECT_POS_ACK )
            SERVER_MSG( EVENT_CHANGE_AGIT_OBJECT_POS_BROAD )
            SERVER_MSG( EVENT_AGIT_FRIEND_LIST_ACK )
            SERVER_MSG( EVENT_AGIT_TOP_RANK_LIST_ACK )
            SERVER_MSG( EVENT_AGIT_FAVORITE_LIST_ACK )
            SERVER_MSG( EVENT_AGIT_ADD_FAVORITE_ACK )
            SERVER_MSG( EVENT_AGIT_REMOVE_FAVORITE_ACK )
            SERVER_MSG( EVENT_REGISTER_AGIT_PAGE_ACK )
            SERVER_MSG( EVENT_UNREGISTER_AGIT_PAGE_ACK )
            SERVER_MSG( EVENT_AGIT_PAGE_LIST_ACK )
            SERVER_MSG( EVENT_BROWNIE_STORE_CATALOG_ACK )
            SERVER_MSG( EVENT_BROWNIE_STORE_MATERIAL_ACK )
            SERVER_MSG( EVENT_BUY_FOR_BROWNIE_ACK )
            SERVER_MSG( EVENT_EQUIP_BROWNIE_ACK )
            SERVER_MSG( EVENT_CHANGE_BROWNIE_BROAD )
            SERVER_MSG( EVENT_WATERING_FAIRY_TREE_ACK )
            SERVER_MSG( EVENT_CHANGE_FAIRY_TREE_BROAD )
            SERVER_MSG( EVENT_FAIRY_TREE_BUFF_NOT )
            SERVER_MSG( EVENT_USE_FAIRY_TREE_FRUIT_ACK )
            SERVER_MSG( EVENT_FAIRY_TREE_LV_TABLE_ACK )
            SERVER_MSG( EVENT_AGIT_INIT_SEED_NOT )
            SERVER_MSG( EVENT_AGIT_VISITER_COUNT_BROAD )
            SERVER_MSG( EVENT_DROP_FLOWER_POT_NOT )
            SERVER_MSG( EVENT_AGIT_TUTORIAL_ACK )
            SERVER_MSG( EVENT_AGIT_TUTORIAL_DONE_ACK )
            SERVER_MSG( EVENT_INVITE_AGIT_NOT )
            SERVER_MSG( EVENT_GUESTBOOK_PAGE_ACK )
            SERVER_MSG( EVENT_GUESTBOOK_WRITE_ACK )
            SERVER_MSG( EVENT_GUESTBOOK_WRITE_BROAD )
            SERVER_MSG( EVENT_GUESTBOOK_DELETE_ACK )
            SERVER_MSG( EVENT_GUESTBOOK_DELETE_BROAD )
            SERVER_MSG( EVENT_USE_TRAINING_OBJ_ACK )
            SERVER_MSG( EVENT_UPDATE_TRAINING_OBJ_BROAD )
            SERVER_MSG( EVENT_STRENGTH_MATERIAL_INFO )
            SERVER_MSG( EVENT_STRENGTH_EQUIP_ACK )
            SERVER_MSG( EVENT_STRENGTH_ACTION_ACK )
            SERVER_MSG( EVENT_STRENGTH_BREAKUP_ACK )
            SERVER_MSG( EVENT_STRENGTH_COMPOSE_ACK )
            SERVER_MSG( EVENT_INVEN_BUFF_ITEM_LIST_ACK )
            SERVER_MSG( EVENT_OPEN_AGIT_CHARACTER_ACK )
            SERVER_MSG( EVENT_SET_AGIT_CHARACTER_POS_ACK )
            SERVER_MSG( EVENT_SET_AGIT_CHARACTER_MOTION_ACK )
            SERVER_MSG( EVENT_SET_AGIT_CHARACTER_COORDI_ACK )
            SERVER_MSG( EVENT_SET_AGIT_CHARACTER_SPEECH_ACK )
            SERVER_MSG( EVENT_UPDATE_AGIT_CHARACTER_BROAD )
            SERVER_MSG( EVENT_UPDATE_AGIT_CHARACTER_POS_BROAD )
            SERVER_MSG( EVENT_SHUTDOWN_USER_DISCONNECT_NOT )
            SERVER_MSG( EVENT_SHUTDOWN_ALARM_NOT )
            SERVER_MSG( EVENT_NMNETCAFE_BONUS_ACK )
            SERVER_MSG( EVENT_SURVEY_REWARD_LIST_INFO )
            SERVER_MSG( EVENT_SURVEY_LIST_NOT )
            SERVER_MSG( EVENT_SURVEY_REWARD_ACK )
            SERVER_MSG( EVENT_DUNGEON_TICKET_LIST_NOT )
            SERVER_MSG( EVENT_EXP_TABLE_NOT )
            SERVER_MSG( EVENT_SHA_ENABLE_ACK )
            SERVER_MSG( EVENT_GWC_RANKING_LIST_ACK )
            SERVER_MSG( EVENT_GWC_RANKING_REWARD_ACK )
            SERVER_MSG( EVENT_JUST_IN_TIME_NEXT_TIME_NOT )
            SERVER_MSG( EVENT_JUST_IN_TIME_ON_TIME_NOT )
            SERVER_MSG( EVENT_JUST_IN_TIME_REWARD_ACK )
            SERVER_MSG( EVENT_ESCORT_INFO_NOT )
            SERVER_MSG( EVENT_CHARISMAS_EVENT_NOT )
            SERVER_MSG( EVENT_CHARISMAS_EVENT_INFO_ACK )
            SERVER_MSG( EVENT_CHARISMAS_EVENT_CONNECT_CHECK_ACK )
            SERVER_MSG( EVENT_CHARISMAS_EVENT_PRESENT_ACK )
            SERVER_MSG( EVENT_CHARISMAS_EVENT_PRESENT_NOT )
            SERVER_MSG( EVENT_CHARISMAS_EVENT_DONATION_ACK )
            SERVER_MSG( EVENT_CHARISMAS_EVENT_GRADE_REWARD_ACK )
            SERVER_MSG( EVENT_NEW_POST_LETTER_INFO_NOT )
            SERVER_MSG( EVENT_GET_POST_LETTER_LIST_ACK )
            SERVER_MSG( EVENT_SEND_LETTER_ACK )
            SERVER_MSG( EVENT_RECEIVE_LETTER_NOT )
            SERVER_MSG( EVENT_READ_LETTER_ACK )
            SERVER_MSG( EVENT_GET_ITEM_FROM_LETTER_ACK )
            SERVER_MSG( EVENT_DELETE_LETTER_ACK )
            SERVER_MSG( EVENT_RENEWAL_LETTER_ACK )
            SERVER_MSG( EVENT_ECLIPSE_TIME_EVENT_INFO_NOT )
            SERVER_MSG( EVENT_ECLIPSE_PLOT_INFO_ACK )
            SERVER_MSG( EVENT_ECLIPSE_PLOT_TIME_REWARD_ACK )
            SERVER_MSG( EVENT_ECLIPSE_PLOT_TIME_REWARD_READY_NOT )
            SERVER_MSG( EVENT_ECLIPSE_PLOT_HUNT_REWARD_ACK )
            SERVER_MSG( EVENT_ECLIPSE_PLOT_FINAL_REWARD_ACK )
            SERVER_MSG( EVENT_ECLIPSE_COLLECT_INFO_ACK )
            SERVER_MSG( EVENT_ECLIPSE_COLLECT_REWARD_ACK )
            SERVER_MSG( EVENT_DUNGEON_CLEAR_REWARD_ACK )
            SERVER_MSG( EVENT_EQUIP_LEVEL_DOWN_ACK )
            SERVER_MSG( EVENT_MONSTER_CARD_MIX_ACK )
            SERVER_MSG( EVENT_MONSTER_CARD_MIX_INFO_ACK )
            SERVER_MSG( EVENT_USE_EXP_POTION_ACK )
            SERVER_MSG( EVENT_EXP_POTION_LIST_ACK )
            SERVER_MSG( EVENT_DEPOT_INFO_ACK )
            SERVER_MSG( EVENT_DEPOT_CHAR_TAB_INFO_ACK )
            SERVER_MSG( EVENT_DEPOT_CHAR_TAB_INFO_NOT )
            SERVER_MSG( EVENT_DEPOT_INSERT_ITEM_ACK )
            SERVER_MSG( EVENT_DEPOT_DELETE_ITEM_ACK )
            SERVER_MSG( EVENT_DEPOT_MOVE_ITEM_ACK )
            SERVER_MSG( EVENT_DEPOT_EXTEND_ACK )
            SERVER_MSG( EVENT_UPDATE_DEPOT_DATA_ACK )
            SERVER_MSG( EVENT_JOB_MISSION_GUIDE_NOT )
            SERVER_MSG( EVENT_SKILL_UPDATE_BROAD )
            SERVER_MSG( EVENT_SONGKRAN_SCRIPT_INFO_ACK )
            SERVER_MSG( EVENT_SONGKRAN_USER_INFO_ACK )
            SERVER_MSG( EVENT_SONGKRAN_WATERBOMB_USE_ACK )
            SERVER_MSG( EVENT_SONGKRAN_GRADE_REWARD_ACK )
            SERVER_MSG( EVENT_SONGKRAN_WATERBOMB_SUPPLY_NOT )
            SERVER_MSG( EVENT_SONGKRAN_WATERBOMB_EXCHANGEITEM_USE_ACK )
            SERVER_MSG( EVENT_LEVEL_RESET_EVENT_INFO_ACK )
            SERVER_MSG( EVENT_LEVEL_RESET_EVENT_ITEM_ACK )			
            SERVER_MSG( EVENT_LEVEL_RESET_EVENT_REWARD_ACK )
            SERVER_MSG( EVENT_ADVENTURE_MISSION_MONSTER_DATA_NOT )
            SERVER_MSG( EVENT_ADVENTURE_USER_COLLECT_DATA_NOT )
            SERVER_MSG( EVENT_ADVENTURE_DATA_ACK )
            SERVER_MSG( EVENT_ADVENTURE_CONTINENT_REWARD_ACK )
            SERVER_MSG( EVENT_ADVENTURE_FINAL_REWARD_ACK )			
            SERVER_MSG( EVENT_ATTEND_GET_CHAR_ACK )
            SERVER_MSG( EVENT_TEST_ADD_ITEM_ACK )
            SERVER_MSG( EVENT_SHUTDOWN_CHECKIN_INFO_NOT )
            SERVER_MSG( EVENT_SHUTDOWN_CHECKOUT_INFO_NOT )
            SERVER_MSG( EVENT_OLYMPIC_SCHEDULE_ACK )
            SERVER_MSG( EVENT_OLYMPIC_INFO_ACK )
            SERVER_MSG( EVENT_OLYMPIC_JOIN_GAME_ACK )
            SERVER_MSG( EVENT_OLYMPIC_ALARM_NOT )
            SERVER_MSG( EVENT_OLYMPIC_TREEDROP_RESULT_ACK )
            SERVER_MSG( EVENT_OLYMPIC_BALLOON_RESULT_ACK )
            SERVER_MSG( EVENT_OLYMPIC_WATERBOMB_RESULT_ACK )
            SERVER_MSG( EVENT_OLYMPIC_GAWIBAWIBO_RESULT_ACK )
            SERVER_MSG( EVENT_OLYMPIC_DICEPLAY_RESULT_ACK )
            SERVER_MSG( EVENT_OLYMPIC_REWARD_ACK )
            SERVER_MSG( EVENT_OLYMPIC_INFO_NOT )
            SERVER_MSG( EVENT_GACHA_LOTTERY_ITEM_INFO_NOT )
            SERVER_MSG( EVENT_GACHA_LOTTERY_ACTION_ACK )
            SERVER_MSG( EVENT_NEW_CHAR_CHOICE_ACK )			
            SERVER_MSG( EVENT_NEW_CHAR_CARD_INFO_NOT )
            SERVER_MSG( EVENT_CHAR_LEVEL_REWARD_EVENT_NOT )
            SERVER_MSG( EVENT_USER_CHANGE_WEAPON_NOT )
            SERVER_MSG( EVENT_ITEM_COMPOSE_INFO_NOT )
            SERVER_MSG( EVENT_ITEM_COMPOSE_ACK )
            SERVER_MSG( EVENT_SKILL_OPENKEY_USE_ACK )			
            SERVER_MSG( EVENT_MATCH_INVITE_FRIEND_LIST_ACK )
            SERVER_MSG( EVENT_PARTY_USER_READY_ACK )
            SERVER_MSG( EVENT_PARTY_USER_READY_BROAD )
            SERVER_MSG( EVENT_ADD_MATCH_ACK )
            SERVER_MSG( EVENT_ADD_MATCH_BROAD )
            SERVER_MSG( EVENT_DEL_MATCH_ACK )
            SERVER_MSG( EVENT_DEL_MATCH_BROAD )
            SERVER_MSG( EVENT_CURRENT_MATCH_MODE_COUNT_ACK )
            SERVER_MSG( EVENT_CURRENT_MATCH_MODE_COUNT_BROAD )
            SERVER_MSG( EVENT_DISCONNECT_MATCHSERVER_NOT )
            SERVER_MSG( EVENT_FIND_MATCH_NOT )
            SERVER_MSG( EVENT_ACCEPT_MATCH_BROAD )
            SERVER_MSG( EVENT_START_GAME_POSSIBLE_ACK )
            SERVER_MSG( EVENT_SPECIFIC_ITEM_BREAKUP_INFO_ACK )
            SERVER_MSG( EVENT_JOIN_ROOM_INFO_DIVIDE_ACK )
            SERVER_MSG( EVENT_START_GAME_FAIL_NOT )
            SERVER_MSG( EVENT_MATCH_TIME_TABLE_NOT )
            SERVER_MSG( EVENT_MATCH_MODE_STATE_ACK )
            SERVER_MSG( EVENT_MATCH_ALARM_NOT )
			SERVER_MSG( EVENT_HERO_ITEM_UPGRADE_INFO_ACK )
			SERVER_MSG( EVENT_HERO_ITEM_UPGRADE_ACK )
            SERVER_MSG( EVENT_RITAS_CHRISTMAS_USER_INFO_ACK )
            SERVER_MSG( EVENT_RITAS_CHRISTMAS_PLAY_INFO_ACK )
            SERVER_MSG( EVENT_RITAS_CHRISTMAS_RANK_INFO_ACK )
            SERVER_MSG( EVENT_RITAS_CHRISTMAS_STAGE_START_ACK )
            SERVER_MSG( EVENT_RITAS_CHRISTMAS_EMPTY_BASKET_ACK )
            SERVER_MSG( EVENT_RITAS_CHRISTMAS_STAGE_END_ACK )
            SERVER_MSG( EVENT_RITAS_CHRISTMAS_GET_REWARD_ACK )
            SERVER_MSG( EVENT_RITAS_CHRISTMAS_EXCHANGE_CONTINUE_COIN_ACK )
			SERVER_MSG( EVENT_RITAS_CHRISTMAS_REWARD_VIEW_INFO_ACK )
            SERVER_MSG( EVENT_UPDATE_ITEM_COUNT_NOT )
            SERVER_MSG( EVENT_BUFF_DONATION_LOGIN_INFO_NOT )
            SERVER_MSG( EVENT_BUFF_DONATION_TOTAL_DATA_NOT )
            SERVER_MSG( EVENT_BUFF_DONATION_ACK )
            SERVER_MSG( EVENT_ACCUMULATE_ATTENDANCE_INFO_ACK )
            SERVER_MSG( EVENT_ACCUMULATE_ATTENDANCE_REWARD_ACK )
            SERVER_MSG( EVENT_MATCH_RANK_REWARD_NOT )
            SERVER_MSG( EVENT_MY_MATCH_RANK_INFO_NOT )
            SERVER_MSG( EVENT_MATCH_RANK_PAGE_ACK )
            SERVER_MSG( EVENT_MATCH_RANK_SEARCH_ACK )
            SERVER_MSG( EVENT_MATCH_RANK_CHANGE_NOT )
            SERVER_MSG( EVENT_PET_VESTED_ITEM_NOT )
            SERVER_MSG( EVENT_CASHBACK_RATIO_INFO_NOT )
            SERVER_MSG( EVENT_CASHBACK_EXTRA_RATIO_INFO_ACK )
			SERVER_MSG( EVENT_ERRAND_INIT_INFO_ACK )
            SERVER_MSG( EVENT_ERRAND_REWARD_ACK )
            SERVER_MSG( EVENT_ERRAND_LIST_PROVIDE_NOT )
            SERVER_MSG( EVENT_ERRAND_GAME_END_ACK )
            SERVER_MSG( EVENT_ERRAND_USER_INFO_ACK )
			SERVER_MSG( EVENT_JOIN_ROOM_INFO_ACK )
            SERVER_MSG( EVENT_CLIENT_CONTENTS_OPEN_INFO_NOT )
            SERVER_MSG( EVENT_CLIENT_CONTENTS_FIRST_INIT_INFO_NOT )
            SERVER_MSG( EVENT_ITEM_BUY_INFO_NOT )
            SERVER_MSG( EVENT_UPDATE_EVENT_SCRIPT_NOT )
            SERVER_MSG( EVENT_LOOK_INVENTORY_EXTEND_ACK )
            SERVER_MSG( EVENT_DUNGEON_SUBJECT_REWARD_ACK )			
            SERVER_MSG( EVENT_ATTRIBUTE_MIGRATION_INFO_ACK )
            SERVER_MSG( EVENT_ATTRIBUTE_MIGRATION_SELECT_ACK )
            SERVER_MSG( EVENT_GRADUATE_CHARACTER_USER_INFO_NOT )
            SERVER_MSG( EVENT_SYSTEM_GUIDE_COMPLETE_INFO_NOT )
            SERVER_MSG( EVENT_SYSTEM_GUIDE_ITEM_ACK )
            SERVER_MSG( EVENT_SYSTEM_GUIDE_COMPLETE_ACK )
			SERVER_MSG( EVENT_CYOU_GET_WEB_POINT_ACK )
            SERVER_MSG( EVENT_CYOU_CASH_CHANGE_ACK )
            SERVER_MSG( EVENT_CYOU_LOGIN_ACK )
            SERVER_MSG( EVENT_CYOU_USER_HEART_BEAT_ACK )
            SERVER_MSG( EVENT_ADD_SLOT_ACK )
            SERVER_MSG( EVENT_CHANGE_CHARACTER_INFO_ACK )
            SERVER_MSG( EVENT_VITALITY_INFO_NOT )
            SERVER_MSG( EVENT_VITALITY_CHECK_DUNGEON_INFO_NOT )
            SERVER_MSG( EVENT_DEPOT_RESTRICT_ITEM_NOT )
            SERVER_MSG( EVENT_CONNECTION_GIFTBOX_FIRST_CHARACTER_GET_GIFT_NOT);
            SERVER_MSG( EVENT_CONNECTION_GIFTBOX_NEWUSER_INFO_NOT )
            SERVER_MSG( EVENT_CONNECTION_GIFTBOX_NEWUSER_GET_GIFT_ACK )
            SERVER_MSG( EVENT_CONNECTION_GIFTBOX_EVENTUSER_INFO_NOT )
            SERVER_MSG( EVENT_CONNECTION_GIFTBOX_EVENTUSER_GET_GIFT_ACK )
            SERVER_MSG( EVENT_CONNECTION_GIFTBOX_NEWUSER_GET_ALARM_NOT )
            SERVER_MSG( EVENT_CONNECTION_GIFTBOX_EVENTUSER_GET_ALARM_NOT )
            SERVER_MSG( EVENT_COORDI_COMPOSE_ACK )
            SERVER_MSG( EVENT_VIRTUAL_DEPOT_ITEM_LIST_NOT )
            SERVER_MSG( EVENT_MOVE_ITEM_TO_INVENTORY_FROM_VIRTUAL_DEPOT_ACK )
            SERVER_MSG( EVENT_RELAY_SERVER_STATUS_ACK)
            SERVER_MSG( EVENT_TONG_DONATION_INFO_ACK )
            SERVER_MSG( EVENT_TONG_DONATION_DONATE_ACK )
            SERVER_MSG( EVENT_COORDI_GRADE_UPGRADE_ACK )
            SERVER_MSG( EVENT_COORDI_GRADE_UPGRADE_INFO_ACK )
            SERVER_MSG( EVENT_SKILL_SCROOL_TRAINING_ACK )
			SERVER_MSG( EVENT_NICKNAME_VALIDITY_CHECK_ACK )
            SERVER_MSG( EVENT_INFINITY_DUNGEON_MONSTER_SUMMON_ACK )
            SERVER_MSG( EVENT_INFINITY_DUNGEON_MONSTER_SUMMON_BROAD )
            SERVER_MSG( EVENT_INFINITY_DUNGEON_REWARD_EXP_BROAD )
            SERVER_MSG( EVENT_INFINITY_DUNGEON_REWARD_ITEM_BROAD )
            SERVER_MSG( EVENT_DUNGEON_MISSION_REGIST_ACK )
            SERVER_MSG( EVENT_FINISHED_MISSION_LIST_NOT )
            SERVER_MSG( EVENT_MISSION_GETTABLE_CONDITION_INFO_NOT )
            SERVER_MSG( EVENT_DUNGEON_PERSONAL_RECORD_INFO_NOT )
            SERVER_MSG( EVENT_DUNGEON_RANK_CURRENT_SEASON_RANK_PAGE_ACK )
            SERVER_MSG( EVENT_DUNGEON_RANK_PREVIOUS_SEASON_RANK_PAGE_ACK )
            SERVER_MSG( EVENT_DUNGEON_RANK_CURRENT_SEASON_USER_RANK_ACK )
            SERVER_MSG( EVENT_DUNGEON_RANK_PREVIOUS_SEASON_USER_RANK_ACK )
            SERVER_MSG( EVENT_GACHA_PONG_INFO_NOT )
            SERVER_MSG( EVENT_GACHA_PONG_PLAY_INFO_NOT )
            SERVER_MSG( EVENT_GACHA_PONG_ACTION_ACK )
            SERVER_MSG( EVENT_SINGLE_RANDOM_ATTRIBUTE_ITEM_LIST_NOT )
            SERVER_MSG( EVENT_SINGLE_RANDOM_ATTRIBUTE_RANDOM_ACK )
			SERVER_MSG( EVENT_BILLBOARD_REGISTRATION_ACK )
			SERVER_MSG( EVENT_BILLBOARD_CHAT_MSG_NOT )
            SERVER_MSG( EVENT_IN_ROOM_CHANGE_CHARACTER_INFO_ACK )
			SERVER_MSG( EVENT_IN_ROOM_CHANGE_INDOOR_USERINFO_BROAD )
			SERVER_MSG( EVENT_PVP_ROOM_LIST_SEARCH_ACK )
			SERVER_MSG( EVENT_CHANGE_PVP_ROOM_EXTRA_OPTION_ACK )
			SERVER_MSG( EVENT_CHANGE_PVP_ROOM_EXTRA_OPTION_BROAD ) 
            SERVER_MSG( EVENT_COORDIVIEWER_GETSLOT_ACK )
            SERVER_MSG( EVENT_COORDIVIEWER_SETSLOT_ACK )
			SERVER_MSG( EVENT_PET_MAGIC_STONE_INFO_NOT )
			SERVER_MSG( EVENT_PET_MAGIC_STONE_CHANGE_EQUIP_ACK )
			SERVER_MSG( EVENT_PET_MAGIC_STONE_CHANGE_EQUIP_NOT )
            SERVER_MSG( EVENT_LOOK_INVENTORY_EXTEND_INFO_NOT )
            SERVER_MSG( EVENT_USE_HERO_TICKET_ACK )

        default:
            return false;
        }
        g_pkUIMgr->SendEvent( KActionEvent( NULL, KGCUIScene::D3DWE_RECEIVE_GAME_SERVER_PAPCKET, wParam ) );
    }

    else if(uMsg == WM_APP + KP2P::MSPROXY_ID )
    {
#undef  EVENT_TYPE
#define EVENT_TYPE KMSEvent
        switch(wParam)
        {
        SERVER_MSG( EMS_S2_VERIFY_ACCOUNT_ACK )
        SERVER_MSG( EMS_S2_ADD_FRIEND_ACK )
        SERVER_MSG( EMS_S2_ADD_FRIEND_NOT )
        SERVER_MSG( EMS_S2_DELETE_FRIEND_ACK )
        SERVER_MSG( EMS_S2_ACCEPT_FRIEND_ACK )
        SERVER_MSG( EMS_S2_REJECT_FRIEND_NOT )
        SERVER_MSG( EMS_S2_UPDATE_FRIENDS_NOT )
        SERVER_MSG( EMS_S2_UPDATE_FRIEND_NOT )
        SERVER_MSG( EMS_S2_BLOCK_FRIEND_ACK )
        SERVER_MSG( EMS_S2_UNBLOCK_FRIEND_ACK )
        SERVER_MSG( EMS_S2_BLOCK_MOVE_FRIEND_ACK )
        SERVER_MSG( EMS_S2_UNBLOCK_MOVE_FRIEND_ACK )
        SERVER_MSG( EMS_S2_ADD_GROUP_ACK )
        SERVER_MSG( EMS_S2_DELETE_GROUP_ACK )
        SERVER_MSG( EMS_S2_RENAME_GROUP_ACK )
        SERVER_MSG( EMS_S2_MOVE_FRIEND_TO_GROUP_ACK )
        SERVER_MSG( EMS_S2_SET_EMOTICON_ACK )
        SERVER_MSG( EMS_S2_START_CHAT_NOT )
        SERVER_MSG( EMS_S2_START_CHAT_ACK )
        SERVER_MSG( EMS_S2_LEAVE_CHAT_MEMBER_ACK )
        SERVER_MSG( EMS_S2_LEAVE_CHAT_MEMBER_NOT )
        SERVER_MSG( EMS_S2_INVITE_CHAT_MEMBER_ACK )
        SERVER_MSG( EMS_S2_UPDATE_CHAT_MEMBER_NOT )
        SERVER_MSG( EMS_S2_SEND_CHAT_NOT )
        SERVER_MSG( EMS_S2_SEND_PAPER_ACK )
        SERVER_MSG( EMS_S2_NEW_PAPER_NOT )
        SERVER_MSG( EMS_S2_PAPERBOX_FULL_NOT )
        SERVER_MSG( EMS_S2_UPDATE_SENT_PAPERBOX_NOT )
        SERVER_MSG( EMS_S2_UPDATE_RECV_PAPERBOX_NOT )
        SERVER_MSG( EMS_S2_NOCHANGE_SENT_PAPERBOX_NOT )
        SERVER_MSG( EMS_S2_NOCHANGE_RECV_PAPERBOX_NOT )
        SERVER_MSG( EMS_S2_READ_PAPER_ACK )
        SERVER_MSG( EMS_S2_DEL_SENT_PAPER_ACK )
        SERVER_MSG( EMS_S2_DEL_RECV_PAPER_ACK )
        SERVER_MSG( EMS_S2_SEAL_PAPER_ACK )
        SERVER_MSG( EMS_S2_ADD_FRIEND_FORCE_ACK )
        SERVER_MSG( EMS_S2_ADD_FRIEND_FORCE_NOT )
        SERVER_MSG( EMS_ADD_GUILD_MEMBER_LIST_ACK )
        SERVER_MSG( EMS_DEL_GUILD_MEMBER_LIST_ACK )
        SERVER_MSG( EMS_GUILD_ALL_MEMBER_LIST_ACK )

        default:
            return false;
        }
        g_pkUIMgr->SendEvent( KActionEvent( NULL, KGCUIScene::D3DWE_RECEIVE_MESSENGER_SERVER_PAPCKET, wParam ) );
    }

    else if(uMsg == WM_APP + KP2P::NUSERPROXY_ID ) // 센터서버의 메세지.
    {
#undef  EVENT_TYPE
#define EVENT_TYPE KNUserEvent
        switch(wParam)
        {
            SERVER_MSG(ENU_SERVER_LIST_NOT)
            SERVER_MSG(ENU_VERIFY_ACCOUNT_ACK)
            SERVER_MSG(ENU_WAIT_TIME_NOT)
            SERVER_MSG(ENU_CHANNEL_NEWS_NOT)
            SERVER_MSG(ENU_ITEM_BUY_INFO_NOT )
            SERVER_MSG(ENU_CLIENT_SCRIPT_INFO_NOT)
            SERVER_MSG( ENU_NEW_CLIENT_CONTENTS_OPEN_NOT )
            SERVER_MSG( ENU_SOCKET_TABLE_INFO_NOT )
            SERVER_MSG( ENU_GUIDE_BOOK_LIST_ACK )
            SERVER_MSG( ENU_TEXTURE_DYNAMIC_LOAD_ACK )
            SERVER_MSG( ENU_CLIENT_PING_CONFIG_ACK )
            SERVER_MSG( ENU_CLIENT_CONTENTS_FIRST_INIT_INFO_ACK )
            SERVER_MSG( ENU_SHAFILENAME_LIST_ACK )
            SERVER_MSG( ENU_STAY_SERVER_TIMEOUT )
            SERVER_MSG( ENU_CASHBACK_RATIO_INFO_NOT )
            SERVER_MSG( ENU_CLIENT_CONTENTS_FIRST_INIT_ADDITIONAL_INFO_ACK )
            SERVER_MSG( ENU_ACCOUNT_REGISTER_ACK )
            
        default:
            return false;
        }
        g_pkUIMgr->SendEvent( KActionEvent( NULL, KGCUIScene::D3DWE_RECEIVE_LOGIN_SERVER_PAPCKET, wParam ) );
    }

    else if(uMsg == WM_APP + KP2P::TRUSERPROXY_ID )  // TCP Relay Server
    {
        On_EVENT_P2P_RELAY_ACK(lParam);
    }

    else return false;  // 아무 메세지도 처리하지 않은 경우, return false.

    return true;
}

// --------------------------------------------------------------------------------
// Main window procedure
// --------------------------------------------------------------------------------
LRESULT CD3DApplication::MsgProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    HRESULT hr;
    KSerializer ks; // 050602. florist.

    if( Process_Server_Msg(uMsg,wParam,lParam) )
        return S_OK;

    switch( uMsg )
    {
#if defined( _DEBUG ) || !defined( __PATH__ )
    case WM_CREATE:
        {
            DragAcceptFiles( hWnd, TRUE );
        }
        return TRUE;
    case WM_DROPFILES:
        {
            OnDragDrop( (HDROP)wParam );
        }
        return TRUE;
#endif
#if !defined( __PATH__ )
    case WM_COPYDATA:
        {
            COPYDATASTRUCT *pCopyData = (COPYDATASTRUCT*)lParam;
            char* p_data = (char*)pCopyData->lpData;
            std::wstring wstrMsg;
            wstrMsg = std::wstring( p_data, p_data + strlen(p_data) );

            g_pkChatManager->AnalyzeChatCommand( wstrMsg );
            return TRUE;
        }
#endif
        // IME 메세지 무시하기
    case WM_INPUTLANGCHANGE:
        {
            KGCIme::CancelIME();
            KGCIme::CheckImeMode(g_MyD3D->Get_hWnd());
            //바로 전까지 치던 에디트 창으로 다시 IME를 치도록 셋팅하자.
            if(g_hIMEWnd != NULL)
            {
                SetFocus(g_hIMEWnd);
                SendMessage( g_hIMEWnd, WM_KEYDOWN, VK_RETURN, 0);
                //PostMessage( g_hIMEWnd,WM_IME_SETCONTEXT ,TRUE,0);
            }
            return TRUE;
        }
    case WM_IME_NOTIFY:
    case WM_IME_STARTCOMPOSITION:
    case WM_IME_COMPOSITION:
    case WM_IME_ENDCOMPOSITION:
    case WM_CHAR:
    //case WM_KEYUP:
        return TRUE;

    case WM_KEYUP:
        if( wParam == VK_SNAPSHOT )
        {
            // PrintScreen버튼이다.
            // F4키로 스크린샷을 찍는데..
            // 프린트스크린도 찍게 해줄지..
            // 그냥 예전과 동일하게 둘지 생각중임..
            // ------------------------------------
            // 프린트스크린 샷 키도 F4와 동일하게
            // 스크린샷 찍게 합니다..
            g_MyD3D->ScreenShotJPEG();
        }
#if !defined( NATION_CHINA )
#if !defined( __PATH__ )
        if ( g_kStatsManager.GetToogleHUD() == true )
        {
            if( wParam == VK_INSERT )
            {
                g_kStatsManager.OnFullHPMP();
            }
            else if ( wParam == VK_DELETE )
            {
                g_kStatsManager.OnGodMode();
            }
        }
        if( wParam == VK_F5 )
        {
            KP2P::GetInstance()->Send_InventoryInfoReq( "Server" );
        }
        else if ( wParam == VK_F7 )
        {
            FILE* pFile = fopen ( "DeviceList.txt", "wb" );
            if ( pFile )
            {
		        g_pGCDeviceManager->WriteDeviceList(pFile);
                fclose( pFile );
            }

        }
        else if( wParam == VK_END ) { 
            int iNewChar = 0;
            int iChar = 0;
            int iPromotion = 0;

            KLuaManager luaMgr;
            GCFUNC::LoadLuaScript( luaMgr, "Dev.lua" );
            LUA_GET_VALUE_DEF( "iNewChar", iNewChar, 0 );
            LUA_GET_VALUE_DEF( "iChar", iChar, 0 );
            LUA_GET_VALUE_DEF( "iPromotion", iPromotion, 0 );

            g_pkUIScene->m_pkCharGetInfoDlg->SetInfo( iNewChar > 0, iChar, iPromotion );
            g_pkUIScene->m_pkCharGetInfoDlg->SetShow( true );
        }
        else if( wParam == VK_HOME ) { 
            if ( g_kStatsManager.GetToogleHUD() == true )
                g_pkGameOverlayUI->ToggleRender( !g_pkGameOverlayUI->IsRenderOn() );
        }
#endif
#endif
        return TRUE;

#ifdef DSHOW
        case KShow::WM_GRAPHNOTIFY :    // 총각 : (direct show) 스트림 재생이 끝났음을 알려준다.
        {
            g_KMci.HandleEvent( lParam );  // 재생이 끝난 스트림이 동영상인 경우는 TRUE를 리턴한다.
            break;
        }
#endif // DSHOW

        case WM_PAINT:
        {
            // Handle paint messages when the app is not ready
            /*
            if( m_pd3dDevice && !m_bReady )
            {
                if( m_bWindowed )
                {
                   Render();
                    if(D3D_OK==m_pd3dDevice->Present( NULL, NULL, NULL, NULL ))
                        IsPrimaryBuffer = !IsPrimaryBuffer;
                }
            }
            */
            break;
        }
        case WM_ACTIVATEAPP:
        {
            m_bHasFocus = (BOOL) wParam;

#if defined(NO_USE_WINDOW_MODE) && defined(__PATH__)
            if(  g_MyD3D->m_pStateMachine && g_MyD3D->m_pStateMachine->GetState() > GS_LOGO )
            {
                if(m_bHasFocus == false )
                {
                    MessageBoxA( NULL, (LPSTR)(LPCSTR)GCUTIL_STR::GCStrWideToChar(g_pkStrLoader->GetString(STR_ID_APPMSG_ERR_INITIALIZE_FAIL2).c_str()), "Message", MB_OK );
                    PostMessage( g_MyD3D->Get_hWnd(), WM_CLOSE, 0, 0 );                    
                }
            }            
#endif

            //if( !GetWindow( g_MyD3D->Get_hWnd(), GW_CHILD ) )
            {
                RECT rt;
                ::GetWindowRect( m_hWnd, &rt );

#if defined(NO_USE_WINDOW_MODE)  && defined(__PATH__)
                HWND hWindowProp = HWND_TOPMOST;
#else
                HWND hWindowProp = HWND_NOTOPMOST;
#endif
                //if( m_bHasFocus )
                //    hWindowProp = HWND_TOPMOST;
#if !defined(__PATH__)
                hWindowProp = HWND_NOTOPMOST;
#endif

                ::SetWindowPos( m_hWnd, hWindowProp, rt.left,rt.top, rt.right - rt.left, rt.bottom - rt.top, SWP_SHOWWINDOW );

            }

            g_kGlobalValue.m_bActiveApp = (wParam!=0);
            if(m_bHasFocus) g_MyD3D->Reserve_InputFocus=true;

            if( g_MyD3D->m_pStateMachine != NULL && g_MyD3D->m_pStateMachine->GetState() == GS_GAME
                && g_pkGameOverlayUI != NULL && g_MyD3D->MyHead->IsCheatMode )
            {
                g_pkGameOverlayUI->SetEditText( NULL );
                g_pkGameOverlayUI->SetEditFocus();
                g_pkGameOverlayUI->HandleChatEvent();
            }
            break;
        }
        case WM_GETMINMAXINFO:
            ((MINMAXINFO*)lParam)->ptMinTrackSize.x = 100;
            ((MINMAXINFO*)lParam)->ptMinTrackSize.y = 100;
            break;

        case WM_ENTERSIZEMOVE:
            // Halt frame movement while the app is sizing or moving
            //Pause( TRUE );
            break;

        case WM_SIZE:
            // Check to see if we are losing our window...
            if( SIZE_MAXHIDE==wParam || SIZE_MINIMIZED==wParam )
            {
                if( m_bClipCursorWhenFullscreen && !IsWindowMode() )
                    ClipCursor( NULL );
                //m_bActive = FALSE; // ALT + TAB bug
            }
            else
            {
                m_bActive = TRUE;
            }
            break;

        case WM_EXITSIZEMOVE:
            //Pause( FALSE );

            if( m_bActive && IsWindowMode() )
            {
                RECT rcClientOld;
                rcClientOld = m_rcWindowClient;

                // Update window properties
                GetWindowRect( m_hWnd, &m_rcWindowBounds );
                GetClientRect( m_hWnd, &m_rcWindowClient );

                //W_Width  = m_rcWindowClient.right;
                //W_Height = m_rcWindowClient.bottom;

                POINT pt = { m_rcWindowClient.left, m_rcWindowClient.top, };
                ::ClientToScreen(m_hWnd, &pt);
                W_X = pt.x;
                W_Y = pt.y;

                //W_X=m_rcWindowBounds.left+m_rcWindowClient.left+3;
                //W_Y=m_rcWindowBounds.top+m_rcWindowClient.top+22;

                if( rcClientOld.right - rcClientOld.left !=
                    m_rcWindowClient.right - m_rcWindowClient.left ||
                    rcClientOld.bottom - rcClientOld.top !=
                    m_rcWindowClient.bottom - m_rcWindowClient.top)
                {
                    // A new window size will require a new backbuffer
                    // size, so the 3D structures must be changed accordingly.
                    m_bReady = FALSE;
                    W_Width=m_d3dpp.BackBufferWidth  = m_rcWindowClient.right - m_rcWindowClient.left;
                    W_Height=m_d3dpp.BackBufferHeight = m_rcWindowClient.bottom - m_rcWindowClient.top;

                    // Resize the 3D environment
                    if( FAILED( hr = Resize3DEnvironment() ) )
                    {
                        KMsgBox::Open( g_pkStrLoader->GetString( STR_ID_APPMSG_ERR_ON_RESET_DEVICE1 ).c_str(),
                                       g_pkStrLoader->GetString( STR_ID_APPMSG_ERR_ON_RESET_DEVICE2 ).c_str(),
                                       KMsgBox::MBOX_OK );
                        return 0;
                    }

                    m_bReady = TRUE;
                }
            }

            break;

        case WM_SETCURSOR:
            if(IsWindowMode())
            {
                if(ptCursor.x<W_X || W_X+W_Width<ptCursor.x ||
                    ptCursor.y<W_Y || W_Y+W_Height<ptCursor.y) break;
                SetCursor( NULL );
            }else SetCursor( NULL );
            break;

        case WM_MOUSEMOVE:
            {
                GetCursorPos( &ptCursor );

            //{{ Appended by parkch: 2004-07-16 오전 10:36:29
                // 캡션을 제거했기 때문에 상단 영역을 클릭했을 시에 윈도우을 움직인다.
                if ( wParam & MK_LBUTTON )
                {
                    if(IsWindowMode())
                    {
                        if( g_MyD3D->m_pStateMachine &&
                            g_MyD3D->m_pStateMachine->GetState() != GS_GAME  &&
                            g_MyD3D->m_pStateMachine->GetState() != GS_SQUARE &&
                            SiKGCDragManager()->GetDragState() != KGCDragManager::KGDM_DRAG_PROGRESS
                            )
                        {
                            float fScaleX = 1.0f, fScaleY = 1.0f;
                            if (g_pGCDeviceManager!=NULL)
                            {
                                fScaleX = g_pGCDeviceManager->GetWindowScaleX();
                                fScaleY = g_pGCDeviceManager->GetWindowScaleY();
                            }
                            if ( HIWORD( lParam ) < 23 * fScaleY *GC_SCREEN_DIV_HEIGHT  && LOWORD( lParam ) < 740 * fScaleX * GC_SCREEN_DIV_WIDTH)
                            {
                                ::SendMessage(hWnd, WM_NCLBUTTONDOWN, HTCAPTION, lParam);
                            }
                        }
                    }
                }

            //}} Appended by parkch: 2004-07-16 오전 10:36:29
                break;
            }
        case WM_ENTERMENULOOP:
            // Pause the app when menus are displayed
            Pause(TRUE);
            break;

        case WM_EXITMENULOOP:
            Pause(FALSE);
            break;

        case WM_CONTEXTMENU:
            break;

        case WM_NCHITTEST:
            // Prevent the user from selecting the menu in fullscreen mode
            if( !IsWindowMode() )
                return HTCLIENT;
        //          return HTCAPTION;

            break;

        case WM_POWERBROADCAST:
            switch( wParam )
            {
#ifndef PBT_APMQUERYSUSPEND
#define PBT_APMQUERYSUSPEND 0x0000
#endif
                case PBT_APMQUERYSUSPEND:
                    // At this point, the app should save any data for open
                    // network connections, files, etc., and prepare to go into
                    // a suspended mode.
                    return TRUE;

#ifndef PBT_APMRESUMESUSPEND
#define PBT_APMRESUMESUSPEND 0x0007
#endif
                case PBT_APMRESUMESUSPEND:
                    // At this point, the app should recover any data, network
                    // connections, files, etc., and resume running from when
                    // the app was suspended.
                    return TRUE;
            }
            break;

        case WM_LBUTTONDOWN:
            MPushL=true;
            MOld_PushL=false;
            return TRUE;

        case WM_LBUTTONUP:
            MPushL=false;
            MOld_PushL=true;
            return TRUE;

        case WM_RBUTTONDOWN:
            MPushR=true;
            MOld_PushR=false;

        //#define HACK_TEST
#ifdef HACK_TEST
#ifdef _DEBUG
            {
                ProtectedTypeMgr::g_bHackSafe = false;
                ExitWithHackAlert( L"Test e hyo~~ ^^" );
            }
#endif
#endif


        //#define CRASH_TEST
#ifdef CRASH_TEST
            {
                    std::vector< int > vecCrash;
                    vecCrash[0] = 0;
            }

#endif
            return TRUE;

        case WM_RBUTTONUP:
            MPushR=false;
            MOld_PushR=true;
            return TRUE;

        case WM_KEYDOWN:
#ifndef __PATH__
            if ( wParam == VK_NUMPAD7 )
            {
                g_kStatsManager.SetEnable( !g_kStatsManager.GetEnable() );
            }
            if ( g_kStatsManager.GetEnable() )
                g_kStatsManager.EventProc( wParam );
#endif            
            return TRUE;

        case WM_SYSKEYDOWN:
            switch( wParam )
            {
            case VK_F4:
                if( g_MyD3D->m_pStateMachine &&
                    g_MyD3D->m_pStateMachine->GetState() != GS_GAME_LOADING &&
                    g_MyD3D->m_pStateMachine->GetState() != GS_INIT_LOADING &&
                    g_MyD3D->m_pStateMachine->GetState() != GS_LOGO &&
                    !(SiKGCChannelManager()->CheckChannel( CT_AUTOMATCH ) == true && g_MyD3D->m_pStateMachine->GetState() == GS_ROOM ) )

                {
#if defined(USE_LOGOUT)
                    if(  g_MyD3D->m_pStateMachine &&
                        g_MyD3D->m_pStateMachine->GetState() != GS_SQUARE &&
                        g_MyD3D->m_pStateMachine->GetState() != GS_SQUARE_LOADING &&
                        g_MyD3D->m_pStateMachine->GetState() != GS_SQUARE_END &&
#if defined(NATION_BRAZIL)
                        g_MyD3D->m_pStateMachine->GetState() != GS_GAME &&
#endif
                        g_MyD3D->m_pStateMachine->GetState() != GS_GAME_END )
                    {
                        if(g_pkUIScene->IsStop() == false && !g_pkUIScene->m_pkGCGuide->IsRenderOn() )
                            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_LOGOUT_BOX);
                    }
#else
                    if(g_pkUIScene->IsStop() == false && !g_pkUIScene->m_pkGCGuide->IsRenderOn() )
                        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_EXIT_GAME, g_pkStrLoader->GetString(STR_ID_CONFIRM_EXIT), L"", KGCUIScene::GC_MBOX_USE_GAMEEXIT, 0, 0, false, true );
#endif
                }

    #if !defined( __PATH__ )
                if( g_pkUIScene->m_pkGCGuide->IsRenderOn() )
                    g_pkUIScene->m_pkGCGuide->ToggleRender( false );
    #endif

                return TRUE;
                break;
#if defined(NO_USE_WINDOW_MODE)
            case VK_ESCAPE:
                PostMessage( g_MyD3D->Get_hWnd(), WM_CLOSE, 0, 0 );
                return 0;
#endif
            }
            break;

        case WM_SYSCOMMAND:
        {
            // Prevent moving/sizing and power loss in fullscreen mode
            switch( wParam )
            {
                case SC_CLOSE:
                    if(  g_MyD3D->m_pStateMachine &&
                        g_MyD3D->m_pStateMachine->GetState() != GS_GAME_LOADING &&
                        g_MyD3D->m_pStateMachine->GetState() != GS_INIT_LOADING &&
                        g_MyD3D->m_pStateMachine->GetState() != GS_LOGO &&
                        !(SiKGCChannelManager()->CheckChannel( CT_AUTOMATCH ) == true && g_MyD3D->m_pStateMachine->GetState() == GS_ROOM ))
                    {
#if defined(USE_LOGOUT)
                        if(  g_MyD3D->m_pStateMachine &&
                            g_MyD3D->m_pStateMachine->GetState() != GS_SQUARE &&
                            g_MyD3D->m_pStateMachine->GetState() != GS_SQUARE_LOADING &&
                            g_MyD3D->m_pStateMachine->GetState() != GS_SQUARE_END &&
#if defined(NATION_BRAZIL)
                            g_MyD3D->m_pStateMachine->GetState() != GS_GAME &&
#endif
                            g_MyD3D->m_pStateMachine->GetState() != GS_GAME_END )
                        {
                            if(g_pkUIScene->IsStop() == false && !g_pkUIScene->m_pkGCGuide->IsRenderOn() )
                                g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_LOGOUT_BOX);
                        }
#else
                        if(g_pkUIScene->IsStop() == false && !g_pkUIScene->m_pkGCGuide->IsRenderOn() ){
                            g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_EXIT_GAME, g_pkStrLoader->GetString(STR_ID_CONFIRM_EXIT), L"", KGCUIScene::GC_MBOX_USE_GAMEEXIT, 0, 0, false, true );
                        }
#endif
                    }
                    return TRUE;
                    break;
                case SC_MOVE:
                case SC_SIZE:
                case SC_MAXIMIZE:
                case SC_KEYMENU:
                case SC_MONITORPOWER:
                    if( FALSE == IsWindowMode() ) return 1;
                    break;
                case SC_MINIMIZE:
                    break;
                case SC_PREVWINDOW:
                case SC_NEXTWINDOW:
                    return TRUE;
            }
            break;
        }
        case WM_COMMAND:
        {
            switch( LOWORD(wParam) )
            {
                case IDM_SCREENSHOT: // F4
                {
                    g_MyD3D->ScreenShotJPEG();
                    break;
                }
                case IDM_SCREENSHOT_MANTIS:
                {
#if !defined( NATION_CHINA )
#if !defined(__PATH__)
                    if( g_pkUIScene->m_pkMantisReportDlg &&
                        g_pkUIScene->m_pkMantisReportDlg->IsRenderOn() == false &&
                        g_MyD3D->m_pStateMachine &&
                        g_MyD3D->m_pStateMachine->GetState() > GS_LOGIN ) {
                        g_pkUIScene->m_pkMantisReportDlg->TakeScreenShot();
                        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_MANTIS_REPORT_DLG, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
                    }
#else
                    if( g_kGlobalValue.m_kUserInfo.eGCUserLevel == USERLEVEL_ADMIN &&
                        g_pkUIScene->m_pkMantisReportDlg &&
                        g_pkUIScene->m_pkMantisReportDlg->IsRenderOn() == false &&
                        g_MyD3D->m_pStateMachine &&
                        g_MyD3D->m_pStateMachine->GetState() > GS_LOGIN ) {
                        g_pkUIScene->m_pkMantisReportDlg->TakeScreenShot();
                        g_pkUIScene->MessageBox( KGCUIScene::GC_MBOX_MANTIS_REPORT_DLG, L"", L"", KGCUIScene::GC_MBOX_USE_NORMAL, 0, 0, true, true );
                    }
#endif
#endif
                    break;
                }
                case IDM_SCSHOT: // F12
                {
                    // 2007.09.07 wony
                    // 다른 스크린샷 기능을 만들었음..
                    // 아래 스크린샷 찍는 함수는 찍는데 부하가 너무 커서 사용못함..

                    // NOTE : 스크린샷 저장 기능이 있기는 하나, 의도적인 렉 유발이 우려되어 비활성화함.
                    if( false )
                    //if( g_MyD3D->m_pStateMachine->GetState() > GS_LOGO )
                    {
                        if ( FAILED( g_MyD3D->ScreenShot() ) )
                        {
                            if ( g_pkChatManager != NULL )
                            {
                                g_pkChatManager->AddChatMsg( L">> 스크린샷 저장에 실패했습니다.", KGCChatManager::CHAT_TYPE_INVITE );
                            }
                        }
                    }
                    break;
                }
                case IDM_SHOWFPS: // F6
                {
#if !defined( NATION_CHINA )
                    g_MyD3D->Show_FPS=!g_MyD3D->Show_FPS;
                    break;
#else
					g_MyD3D->Show_FPS= false;
					break;
#endif
                }
                case IDM_CARTOON: // F1
                {
                    g_MyD3D->m_KGCOption.Quality_Change(-1, true);
                    break;
                }
                case IDM_SHADOW: // F2
                {
                    g_MyD3D->m_KGCOption.Quality_Change(1, true);
                    break;
                }
                case IDM_3BACK: // F3
                {
                    // 사용하지 않는다
#if !defined( __PATH__ )
                    g_pGCDeviceManager->OutputLoadedDeviceList();
#endif
                    break;
                }
                case IDM_ENVIROMENT: // F9
                {
                    // 사용하지 않는다
                    //bool bEnv = g_MyD3D->m_KGCOption.IsEnv();
                    //g_MyD3D->m_KGCOption.SetEnv(!bEnv);
                    break;
                }
                case IDM_TOGGLEMUSIC: // F7
                {

                    if (  g_MyD3D->m_pStateMachine &&
                        g_MyD3D->m_pStateMachine->GetState() == GS_LOGO)
                        break; // KOG 로고 화면일 때는 음악 끄기를 하지 않는다.
#if defined(NATION_BRAZIL) 
                    if (  g_MyD3D->m_pStateMachine &&
                        g_MyD3D->m_pStateMachine->GetState() == GS_GAME )
                        break; // 브라질은 게임 중 유져께서 고의로 렉 발생 하시므로 막는다.
#endif

                    g_pOptionMusic->SetToggle();
                    break;
                }
                case IDM_TOGGLESOUND: // F8
                {
                    g_pOptionSound->SetToggle();
                    break;
                }
                //case IDM_JOYSTIC: // F5
                //{
                //    bool bJoystic = g_MyD3D->m_KGCOption.IsJoystic();
                //    g_MyD3D->m_KGCOption.SetJoystic(!bJoystic);
                //    break;
                //}
                case IDM_CHANGEDEVICE:
                {
                    // Prompt the user to select a new device or mode
                    //if( m_bActive && m_bReady )
                    //{
                        //Pause(TRUE);

                        //if( FAILED( hr = UserSelectNewDevice() ) )
                        //    return 0;

                        //Pause(FALSE);
                    //}
                    Pause(TRUE);
                    if(!(g_MyD3D->m_pStateMachine &&
                        g_MyD3D->m_pStateMachine->GetState() < GS_LOGO ))
                    {
                        if (g_MyD3D->ChangeResolution(TRUE)==false)
                        {
                            ::PostMessage( hWnd, WM_CLOSE, 0, 0 );
                            //g_MyD3D->RestoreResoultionSetting();
                            //g_MyD3D->SetResolution(TRUE);
                        }
                    }

                    Pause(FALSE);
                    return 0;
                }
                case IDM_TOGGLEFULLSCREEN: // Toggle the fullscreen/window mode
                {
                    //로딩중에는 ToggleFullscreen를 부를 수 없다.

                    if(  g_MyD3D->m_pStateMachine &&
                        g_MyD3D->m_pStateMachine->GetState() < GS_LOGO )
                        return 0;

#if defined(NO_USE_WINDOW_MODE) && defined(__PATH__)
                    if( !IsWindowMode() )
                        return 0;
#endif

                    // 2007.10.16 wony
                    // 게임중에 ToggleFullScreen을 막은 이유는..
                    // 렉을 유발시켜서 필살기가 여러번 나가는 것 때문인데..
                    // 렉필을 막으면서.. 딱히 게임중이라고 이걸 막을 필요가
                    // 없어보여서 풀겠습니다
#if !defined( _DEBUG )
                    {

                        if(  g_MyD3D->m_pStateMachine &&
                            g_MyD3D->m_pStateMachine->GetState() == GS_GAME )
                            return 0;

                    }
#endif

                    if( m_bActive && m_bReady )
                    {
                        Pause( TRUE );

                        if( !Windowable && IsWindowMode() == FALSE )
                        {
                            // 2008.01.15 wony
                            // 원래는 return 0; 만 있었는데..
                            // 만약 실패했을 때.. 이 코드 없이 그냥 return 해버리면..
                            // 그냥 화면 멈춰버리기 때문에 추가했음..
                            Pause( FALSE );
                            return 0;
                        }
                        if( FAILED( ToggleFullscreen() ) )
                        {
                            // 2008.01.15 wony
                            // 원래는 return 0; 만 있었는데..
                            // 만약 실패했을 때.. 이 코드 없이 그냥 return 해버리면..
                            // 그냥 화면 멈춰버리기 때문에 추가했음..
                            Pause( FALSE );
                            return 0;
                        }

                        Pause( FALSE );
                    }
                    return 0;
                }
            }
            return TRUE;
        }
        case WM_USER+2:
        case WM_CLOSE:
        {
            //  게임 종료시 처리해야할 내용 함수
            g_MyD3D->DestoryProcess();
            ::PostQuitMessage( 0 );
            return 0;
        }
        
        case WM_WINDOWPOSCHANGED:
        {            
            
            POINT pt = { m_rcWindowClient.left, m_rcWindowClient.top, };
            ::ClientToScreen(m_hWnd, &pt);

            if( IsWindowMode() )
            {
                if( W_X != pt.x || W_Y != pt.y)
                {
                    RECT rcClientOld;
                    rcClientOld = m_rcWindowClient;

                    // Update window properties
                    GetWindowRect( m_hWnd, &m_rcWindowBounds );
                    GetClientRect( m_hWnd, &m_rcWindowClient );

                    W_X = pt.x;
                    W_Y = pt.y;
                }
            }
            break;
        }
        case WM_DESTROY:
        {
            
            return 0;
        }
        default:
        {
            break;
        }
    }

    return ::DefWindowProc( hWnd, uMsg, wParam, lParam );
}

#undef ACK_DESERIALIZE


